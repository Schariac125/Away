# 算法：二分

## 知识点：

这一节我已经没有看课了，纯纯看书自己啃的

二分一般分为两种，一种是二分查找，一种则是二分答案

二分查找一般适用于在一个有序的数组中查找元素

而二分答案一般是预设一个答案判断是否符合，适用于最大值最小，最小值最大的这一类问题

空说无用，还是看题吧

## 例题：

## 题目描述

伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。

Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。

Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。

## 输入格式

第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。

第 $2$ 行 $N$ 个整数表示每棵树的高度。

## 输出格式

$1$ 个整数，表示锯片的最高高度。

## 输入输出样例 #1

### 输入 #1

```
4 7
20 15 10 17
```

### 输出 #1

```
15
```

## 输入输出样例 #2

### 输入 #2

```
5 20
4 42 40 26 46
```

### 输出 #2

```
36
```

## 说明/提示

对于 $100\%$ 的测试数据，$1\le N\le10^6$，$1\le M\le2\times10^9$，树的高度 $\le 4\times 10^5$，所有树的高度总和 $>M$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main(){
    int n,m;
    cin>>n>>m;
    int a[1000005];
    int upp=-1;
    int low=0;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        if (a[i]>upp){
            upp=a[i];
        }
    }
    while(low<=upp){
        int mid=(low+upp)/2;
        int sum=0;
        for (int i=1;i<=n;i++){
            if (a[i]>mid){
                sum+=a[i]-mid;
            }
        }
        if (sum<m) upp=mid-1;
        else low=mid+1;//这个地方的逻辑很重要
    }
    cout<<low-1<<endl;
    return 0;
}
```

### 思路：

首先要明确这道题是用二分的 

1. 有单调性

   提高伐木机的高度，显然地，得到的木头会减少。

   同样地，放低得到的木头会增多。

   而正因为答案有单调性，所以我们可以使用二分。

## 例题：养奶牛

## 题目描述

农夫约翰建造了一座有 $n$ 间牛舍的小屋，牛舍排在一条直线上，第 $i$ 间牛舍在 $x_i$ 的位置，但是约翰的 $m$ 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？

## 输入格式

第一行用空格分隔的两个整数 $n$ 和 $m$；

下面 $n$ 行为 $n$ 个用空格隔开的整数，表示位置 $x_i$。

## 输出格式

一行一个整数，表示最大的最小距离值。

## 输入输出样例 #1

### 输入 #1

```
5 3
1
2
8
4
9
```

### 输出 #1

```
3
```

## 说明/提示

【样例解析】把牛放在 $1$，$4$，$8$ 这三个位置，距离是 $3$。容易证明最小距离已经最大。

【数据范围】对于 $100\%$ 的数据，$2 \le n \le 10^5$，$0 \le x_i \le 10^9$，$2 \le m \le n$。不保证 $x$ 数组单调递增。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[1000005];
bool find(int d){
    int sum=0;
    int last=-1000005;
    for (int i=1;i<=n;i++){
        if (a[i]-last>=d){
            last=a[i];
            sum++;
        }
    }
    return sum>=m;
}
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    int l=0;
    int r=1000005;
    int ans=0;
    while (l<=r){
        int mid=(l+r)/2;
        if (find(mid)){
            ans=mid;
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

## 例题：解方程（反复观摩）

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 输入格式

一行，$4$ 个实数 $a, b, c, d$。

## 输出格式

一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。

## 输入输出样例 #1

### 输入 #1

```
1 -5 -4 20
```

### 输出 #1

```
-2.00 2.00 5.00
```

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define eps 1e-4

double a,b,c,d;
double f(double x){
    return a*x*x*x+b*x*x+c*x+d;
}

int main(){
    cin>>a>>b>>c>>d;
    for (int i=-100;i<=100;i++){
        double l=i,r=i+1;
        double mid;
        if (fabs(f(l))<eps){
            printf("%.2lf ",l);
        }else if(fabs(f(r))<eps){
            continue;
        }
        else if(f(l)*f(r)<0){
            while (r-l>eps){
                mid=(l+r)/2;
                if (f(mid)*f(r)>0){
                    r=mid;
                }else{
                    l=mid;
                }
            }
            printf("%.2lf ",l);
        }
    }
    return 0;
}
```

### 思路:

事实上，这个做法只能得到大致解。

eps为什么设置成那个值呢，我们目的不是为了去枚举出真的为0的点，而是那个点的值小于我们设定的这个精度的时候就把它输出出来

还有一点，这一题有一个非常重要的条件，没有这个的话是绝对做不出来的，就是保证两个根之间差大于1

我们从范围内遍历，设置左右点，注意这是一个左闭右开的区间。

## 例题：

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。

## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。

## 输入格式

第一行读入两个整数 $m,n$。

第二行共有 $m$ 个数，表示 $m$ 个学校的预计录取分数。

第三行有 $n$ 个数，表示 $n$ 个学生的估分成绩。

## 输出格式

输出一行，为最小的不满度之和。

## 输入输出样例 #1

### 输入 #1

```
4 3
513 598 567 689
500 600 550
```

### 输出 #1

```
32
```

## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq10^3$，估分和录取线 $\leq10^4$；

对于 $100\%$ 的数据，$1\leq n,m\leq10^5$，估分和录取线 $\leq 10^6$ 且均为非负整数。

### 例题：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[100005];
int b[100005];
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }//a是分数线
    for (int i=1;i<=m;i++){
        cin>>b[i];
    }//b是估分
    int ans=0;
    sort(a+1,a+1+n);
    for (int i=1;i<=m;i++){
        int l=1,r=n;
        if (b[i]<=a[l]){
            ans+=a[l]-b[i];
        }
        else if(b[i]>a[r]){
            ans+=b[i]-a[r];
        }
        else{
            while(l<r){
                int mid=(l+r)/2;
                if (b[i]>=a[mid]){
                    l=mid+1;
                }else{
                    r=mid;
                }
            }
            ans+=min(abs(a[l-1]-b[i]),abs(a[r]-b[i]));
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

思路其实很简单，这个就是对分数线进行排序，然后利用二分找出来最接近的那个答案，结束了

另外我要吐槽一点，luogu你给测试点一点都不考虑题目背景是吧，高考报志愿的背景你能给出来全是估分0分的测试点？

## 例题：

## 题目背景

NOIP2015 Day2T1

## 题目描述

一年一度的“跳石头”比赛又要开始了！

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。

## 输入格式

第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。

接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。

## 输出格式

一个整数，即最短跳跃距离的最大值。

## 输入输出样例 #1

### 输入 #1

```
25 5 2 
2
11
14
17 
21
```

### 输出 #1

```
4
```

## 说明/提示

### 输入输出样例 1 说明

将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。

### 数据规模与约定

对于 $20\%$的数据，$0 \le M \le N \le 10$。    
对于 $50\%$ 的数据，$0 \le M \le N \le 100$。  
对于 $100\%$ 的数据，$0 \le M \le N \le 50000,1 \le L 
 \le 10^9$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int l,n,m;
int a[50005];
bool find(int x){
    int sum=0;
    int i=0;
    int now=0;
    while (i<n+1){
        i++;
        if (a[i]-a[now]<x){
            sum++;
        }else{
            now=i;
        }
    }
    return sum<=m;
}
signed main(){
    cin>>l>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    a[n+1]=l;
    int left=1;
    int right=l;
    int ans=0;
    while (left<=right){
        int mid=(left+right)/2;
        if (find(mid)){
            ans=mid;
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

我先复制一下洛谷大佬的题解思路然后再给出自己的想法

```
这道题如果要使用暴力搜索直接求解会严重超时。实际上，我们可以发现，这个所谓的最短跳跃距离显然不能超过一个范围，而这个范围题目上已经给了出来。也就是说，答案是有一个确定的范围限制的，我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行。

实际上，枚举答案有时候也会超时。这就好比说你要从一本英汉词典上查一个单词，你从头到尾一页一页的翻着找，这样找可以保证一定能找到，但是最坏情况你要把整本词典都翻一遍，那就麻烦了。

有什么改进的方法吗？当然有。

考虑把这个词典从中间分开，看一下中间那一页的主要单词都是啥，然后去判断我要找的单词应该在左半部分还是右半部分，再去那一部分考虑怎么找就好了。同样的，在另一部分也是要进行划分并且判断的操作。这样一直进行下去，便能很快的找到答案，而且根本不需要翻过整个词典来。

可以证明，如果一页一页的找，最多要找n次，但是用这个方法，最多找floor(log2n)次。

我们把这个方法叫做“二分答案”。顾名思义，它用二分的方法枚举答案，并且枚举时判断这个答案是否可行。但是，二分并不是在所有情况下都是可用的，使用二分需要满足两个条件。一个是有界，一个是单调。

二分答案应该是在一个单调闭区间上进行的。也就是说，二分答案最后得到的答案应该是一个确定值，而不是像搜索那样会出现多解。二分一般用来解决最优解问题。刚才我们说单调性，那么这个单调性应该体现在哪里呢？

可以这样想，在一个区间上，有很多数，这些数可能是我们这些问题的解，换句话说，这里有很多不合法的解，也有很多合法的解。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。

最优解一定可行，但可行解不一定最优。我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x'(x'<x)都是可行解。并且，如果有一个数y是非法解，那么一般的，所有的y'(y'>y)都是非法解。

那么什么时候适用二分答案呢？注意到题面：使得选手们在比赛过程中的最短跳跃距离尽可能长。如果题目规定了有“最大值最小”或者“最小值最大”的东西，那么这个东西应该就满足二分答案的有界性（显然）和单调性（能看出来）。

那就好办了。我们二分跳跃距离，然后把这个跳跃距离“认为”是最短的跳跃距离，然后去以这个距离为标准移石头。使用一个judge判断这个解是不是可行解。如果这个解是可行解，那么有可能会有比这更优的解，那么我们就去它的右边二分。为什么去右边？答案是，这个区间是递增的 ，而我们求的是最短跳跃距离的最大值，显然再右边的值肯定比左边大，那么我们就有可能找到比这更优的解，直到找不到，那么最后找到的解就有理由认为是区间内最优解。反过来，如果二分到的这个解是一个非法解，我们就不可能再去右边找了。因为性质，右边的解一定全都是非法解。那么我们就应该去左边找解。整个过程看起来很像递归，实际上，这个过程可以递归写， 也可以写成非递归形式，我个人比较喜欢使用非递归形式。

下一个问题，这个judge怎么实现呢？judge函数每个题有每个题的写法，但大体上的思想应该都是一样的——想办法检测这个解是不是合法。拿这个题来说，我们去判断如果以这个距离为最短跳跃距离需要移走多少块石头，先不必考虑限制移走多少块，等全部拿完再把拿走的数量和限制进行比对，如果超出限制，那么这就是一个非法解，反之就是一个合法解，很好理解吧。

可以去模拟这个跳石头的过程。开始你在i(i=0)位置，我在跳下一步的时候去判断我这个当前跳跃的距离，如果这个跳跃距离比二分出来的mid小，**那这就是一个不合法的石头，应该移走。**为什么？我们二分的是最短跳跃距离，已经是最短了，如果跳跃距离比最短更短岂不是显然不合法，是这样的吧。移走之后要怎么做？先把计数器加上1，再考虑向前跳啊。去看移走之后的下一块石头，再次判断跳过去的距离，如果这次的跳跃距离比最短的长，那么这样跳是完全可以的，我们就跳过去，继续判断，如果跳过去的距离不合法就再拿走，这样不断进行这个操作，直到i = n+1，为啥是n+1？河中间有n块石头，显然终点在n+1处。（这里千万要注意不要把n认为是终点，实际上从n还要跳一步才能到终点）。

模拟完这个过程，我们查看计数器的值，这个值代表的含义是我们以mid作为答案需要移走的石头数量，然后判断这个数量 是不是超了就行。如果超了就返回false，不超就返回true。
```

这一题实际上和前面的那个养奶牛的题目非常像，都是同一个类型的

**那么什么时候适用二分答案呢？注意到题面：使得选手们在比赛过程中的最短跳跃距离尽可能长。如果题目规定了有“最大值最小”或者“最小值最大”的东西，那么这个东西应该就满足二分答案的有界性（显然）和单调性（能看出来）。**

这两题有一个共同的特征，就是题目里面都出现了最小值最大这个条件，这种题目的思路就是在原本的长度区间内枚举答案，然后再进行每一个答案的判断

写一个返回值为bool的函数，里面的条件就是开始枚举每一个点与下一个点之间的距离，如果可行，就计数器加一，然后和题目给定的条件进行一下判断就行。

## 例题：木材加工

## 题目背景

要保护环境

## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。

## 输入格式

第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。

接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。

## 输出格式

仅一行，即 $l$ 的最大值。

如果连 $\text{1cm}$ 长的小段都切不出来，输出 `0`。

## 输入输出样例 #1

### 输入 #1

```
3 7
232
124
456
```

### 输出 #1

```
114
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int n,k;
int a[100005];
bool find(int x){
    int sum=0;
    for (int i=1;i<=n;i++){
        sum+=a[i]/x;
    }
    return sum>=k;
}
signed main(){
    cin>>n>>k;
    int maxx=0;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        maxx=max(maxx,a[i]);
    }
    int l=1;
    int r=maxx;
    int ans=0;
    while (l<=r){
        int mid=(l+r)/2;
        if (find(mid)){
            ans=mid;
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

没有思路，全是套路， 把上面几题吃干抹净了这题就绝对会做了。

顺便吐槽一点啊，现在给我干的有点ptsd了，不开long long见祖宗，于是我每个代码开头都有这一段

```cpp
#define int long long
```

## 例题：路标

## 题目背景

B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。

## 题目描述

现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。

## 输入格式

第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。


第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。

## 输出格式

输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。

## 输入输出样例 #1

### 输入 #1

```
101 2 1
0 101
```

### 输出 #1

```
51
```

## 说明/提示

公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。

$50\%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。

$100\%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。

$100\%$ 的数据中，$0 < L \leq 10000000$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int l,n,k;
int a[1000005];
bool find(int x){
    int sum=0;
    for (int i=1;i<=n;i++){
        int diff=a[i]-a[i-1];
        if (diff>x){
            if (diff%x==0){
                sum+=(diff/x-1);
            }else{
                sum+=diff/x;
            }
        }
    }
    return sum<=k;
}
signed main(){
    cin>>l>>n>>k;
    int maxx;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        maxx=max(maxx,a[i]);
    }
    int li=1;
    int ri=l;
    int ans=0;
    while (li<=ri){
        int mid=(li+ri)/2;
        if (find(mid)){
            ans=mid;
            ri=mid-1;
        }else{
            li=mid+1;
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

## 例题：

## 题目描述

对于给定的一个长度为 $N$ 的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。

关于最大值最小：

例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。

将其如下分段：

$$[4\ 2][4\ 5][1]$$

第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。

将其如下分段：

$$[4][2\ 4][5\ 1]$$

第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。

并且无论如何分段，最大值不会小于 $6$。

所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。

## 输入格式

第 $1$ 行包含两个正整数 $N,M$。  

第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。

## 输出格式

一个正整数，即每段和最大值最小为多少。

## 输入输出样例 #1

### 输入 #1

```
5 3
4 2 4 5 1
```

### 输出 #1

```
6
```

## 说明/提示

对于 $20\%$ 的数据，$N\leq 10$。

对于 $40\%$ 的数据，$N\leq 1000$。

对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int n,m;
int a[1000005];
int l=0;
int r=0;
bool find(int x){
    int tot=0,num=0;
    for(int i=1;i<=n;i++)
    {
        if(tot+a[i]<=x)tot+=a[i];
        else tot=a[i],num++;
    }
    return num>=m;
}
signed main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        l=max(l,a[i]);
        r+=a[i];
    }
    int ans=0;
    while (l<=r){
        int mid=(l+r)/2;
        if (find(mid)){
            l=mid+1;
        }else{
            ans=mid;
            r=mid-1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

我一定要提一嘴，这一题的题目样例非常鸡贼，误导性很强

这一题的方法其实还是二分答案，写一个bool函数，然后开始遍历数组中的元素，查找下一个元素，如果这几个和大于了规定的值，那么就把这个划分为一个区间，sum++。

## 例题：

## 题目描述

当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。

## 输入格式

三个用空格隔开的正整数。

第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。

## 输出格式

一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\%$。

数据保证答案不超过 $300.0\%$。

## 输入输出样例 #1

### 输入 #1

```
1000 100 12
```

### 输出 #1

```
2.9
```

## 说明/提示

数据保证，$1 \leq w_0, w\leq 2^{31}-1$，$1 \leq m\leq 3000$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
double n,m,k,l,r;
bool pd(double x){//判断当前答案是否满足 
	return (pow(1.0/(1.0+x),k)>=1-n/m*x);//pow函数，上文已讲
}
int main(){
	cin>>n>>m>>k;
   	///////////////////////二分模板
	l=0;r=10;//月利率可能大于1
	while(r-l>=0.0001){//注意精度问题 
		double mid=(l+r)/2;
		if(pd(mid))r=mid;
		else l=mid;
	}
   	///////////////////////
	cout<<fixed<<setprecision(1)<<l*100;//输出一位小数哦 
	return 0;
} 

```

### 思路：

你知道的，这题最难的不是oi部分，是你可能不知道利率怎么算（

![img](C:\Users\asus\Desktop\程序设计\算法笔记\大章二分\算法：二分.assets\68913dc9230d60f38eeca691f55a62b6.png)
