# 杂

## 二分

```cpp
实数：
const double eps =1e-7;        //精度。如果下面用for，可以不要eps
while(right - left > eps){     //for(int i = 0; i<100; i++){
      double mid = left+(right-left)/2;
      if (check(mid)) right = mid;           //判定，然后继续二分
      else            left  = mid;
}
//[l,r)
int upperBound(int l, int r)
{
    while(l + 1 < r) //循环条件为区间长度>=2
    {
        int mid = (l + r) / 2;
        if(check(mid)) l = mid; //检查mid是否符合题目要求
        else r = mid;
    }
    return l;
}
//(l,r]
int lowerBound(int l, int r)
{
    while(l + 1 < r) //循环条件为区间长度>=2
    {
        int mid = (l + r) / 2;
        if(check(mid)) r = mid; //检查mid是否符合题目要求
        else l = mid;
    }
    return r;
}
```

## 三分

实数

```cpp
double a[N],n,l,r;

double f(double x) {
    double ans = 0;
    for (int i = 0;i <= n;++i) ans += a[i] * pow(x,i);
    return ans;
}

signed main() {
    cin >> n >> l >> r;
    for (int i = n;i >= 0;--i) cin >> a[i];
    while (r -l > eps) {
        double lmid = l + (r-l)/3,rmid = r - (r-l)/3;
        if (f(lmid) <= f(rmid)) l = lmid;
        else r = rmid;
    }
    //也可以：
    for(int i = 0; i < 300; i++) {
        double lmid = l + (r - l) / 3;
        double rmid = r - (r - l) / 3;
        if(calc(rmid) >= calc(lmid))	r = rmid;
        else 	l = lmid;
    }
    printf("%.5lf",l);
	return 0;
}
```

整数

```cpp
//凸函数的极大值
ll l, r;
while(l < r) {
    ll lmid = l + (r - l) / 3;
    ll rmid = r - (r - l) / 3;
    if(calc(lmid) <= calc(rmid))	l = lmid + 1;//凹函数就变成r = rmid - 1;
    else r = rmid - 1;
}
printf("%lld\n", max(calc(l), calc(r)));
```

## 离散化

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[102],b[102];
int main(){
	cin>>n;
	for (int i=1;i<=n;i++)  cin>>a[i];
	for (int i=1;i<=n;i++)  b[i]=a[i];
	sort(b+1,b+n+1);
	int cur=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++) 
		a[i]=lower_bound(b+1,b+cur+1,a[i])-b;
	for (int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
}
```

## 悬线法

棋盘相邻的格子不同色。

第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2003;
int n,m,a[N][N];
int max_zheng,max_ju;
int Left[N][N],Right[N][N],up[N][N];
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) 
		for (int j=1;j<=m;j++)  {
			scanf("%d",&a[i][j]);			
			Left[i][j]=j,Right[i][j]=j;  //大写！（小写会CE） 
			up[i][j]=1;
		}
	for (int i=1;i<=n;i++) 
		for (int j=2;j<=m;j++)  //!!! 
			if (a[i][j]!=a[i][j-1]) Left[i][j]=Left[i][j-1];
	for (int i=1;i<=n;i++) 
		for (int j=m-1;j>=1;j--) 
			if (a[i][j]!=a[i][j+1]) Right[i][j]=Right[i][j+1];
	for (int i=1;i<=n;i++) 
		for (int j=1;j<=m;j++) {
			if (i!=1 && a[i][j]!=a[i-1][j]) {  //!!! (i!=1)  
				Left[i][j]=max(Left[i-1][j],Left[i][j]);
				Right[i][j]=min(Right[i-1][j],Right[i][j]);
				up[i][j]=up[i-1][j]+1;
			}
			int t=Right[i][j]-Left[i][j]+1;
			max_zheng=max(max_zheng,min(t,up[i][j])*min(t,up[i][j]));
			max_ju=max(max_ju,t*up[i][j]);
		}
	printf("%d\n",max_zheng);
	printf("%d\n",max_ju);
	return 0;
}
```



# 数据结构

## 并查集维护size+拓展域并查集

```cpp
void init() {
    for (int i = 1;i <= n;++i) f[i] = i,f[i+n] = i+n,siz[i] = 1,siz[i+n] = 0;
}
int find(int x) {
      if(x!=f[x])return f[x]=find(f[x]);
      return f[x];
}

void merge(int x,int y) {
	x=find(x),y=find(y);//很重要别漏了。
    if (x == y) return ;
    siz[y] += siz[x];siz[x] = 0;f[x] = y;
}
```

## 对顶堆

```cpp
multiset <ll> xgd;
multiset <ll,greater <ll>> bgd;
//插入一个数a[i]
if (bgd.empty()) {
    xgd.insert(a[i]);
    s2 += a[i];
} else {
    if (a[i] > *bgd.begin()) xgd.insert(a[i]),s2 += a[i];
    else bgd.insert(a[i]),s1 += a[i];
}
while (judge(bgd.size(),xgd.size()) > 1) {
    if (bgd.size() > xgd.size()) {
        ll x = *bgd.begin();
        s2 += x;s1 -= x;
        xgd.insert(x);bgd.erase(bgd.begin());
    } else {
        ll x = *xgd.begin();
        s1 += x;s2 -= x;
        bgd.insert(x);xgd.erase(xgd.begin());
    }
}
//提取中位数
ll val1 = 0;
if (bgd.size() >= xgd.size()) {
    val1 = *bgd.begin();
} else {
    val1 = *xgd.begin();
}
```

## 可并堆

![image-20241031233634841](D:\SynologyDrive\document\板子.assets\image-20241031233634841.png)

```cpp
 #include <bits/stdc++.h>
 #define int long long 
using namespace std;
 const int maxn=100010;
 int n,m,op,x,y;
 int lc[maxn],rc[maxn],dist[maxn],rt[maxn];
 bool tf[maxn];
 struct node
 {
 int id,v;
 bool operator<(node x)const{return v==x.v?id<x.id:v<x.v;}
 }v[maxn];
 int find(int x){return rt[x]==x?x:rt[x]=find(rt[x]);}
 int merge(int x,int y)
 {
 if(!x||!y)return x+y;
 if(v[y]<v[x])swap(x,y);
    rc[x]=merge(rc[x],y);
 if(dist[lc[x]]<dist[rc[x]])swap(lc[x],rc[x]);
    dist[x]=dist[rc[x]]+1;
 return x;
 }
 signed main() {
    dist[0]=-1;
 scanf("%lld%lld",&n,&m);
 for(int i=1;i<=n;i++)scanf("%d",&v[i].v),rt[i]=i,v[i].id=i;
 while(m--)
    {
 scanf("%lld%lld",&op,&x);
 if(op==1)
        {
 scanf("%lld",&y);
 if(tf[x]||tf[y])continue;
            x=find(x);y=find(y);
 if(x!=y)rt[x]=rt[y]=merge(x,y);
        }
 if(op==2)
        {
 if(tf[x]){printf("-1\n");continue;}
            x=find(x);
 printf("%lld\n",v[x].v);
            tf[x]=true;
            rt[lc[x]]=rt[rc[x]]=rt[x]=merge(lc[x],rc[x]);
            lc[x]=rc[x]=dist[x]=0;
        }
    }
 return 0;
 }
```



## 单调栈

```cpp

int s[N],top,n,f[N],a[N];

void insert(int x) {
    while (a[s[top]] < a[x] && top) f[s[top--]] = x;
    s[++top] = x;
}

```

## 单调队列



## ST表

```cpp
int st[K][N],n,m;
int query(int l,int r) {
	int len =log(r - l + 1) / log(2);
	return max(st[len][l],st[len][r - (1 << len) + 1]);
}
for (int i = 1;i <= n;++i) read(st[0][i]);
for (int i = 1;i <= 20;++i) {
    for (int j = 1;j + (1 << i) - 1 <= n;++j) {
        st[i][j] = max(st[i-1][j],st[i-1][j + (1 << (i - 1))]);
    }
}
```

## 动态开点线段树

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename Info>
struct Segment_Tree{
    int n;
    struct Node{int lc, rc;};
    vector<Node> t;
    Segment_Tree(){t.resize(1);}
    int init(int n_){
        n = n_;
        t.resize(1);
        return build(1, n);
    }
    int newNode(){
        t.emplace_back();
        return t.size() - 1;
    }
    int build(int L, int R){
        int rt = newNode();
        if (L == R) return rt;
        int MID = L + R >> 1;
        int LC =  build(L, MID),RC = build(MID + 1, R);
        t[rt].lc = LC;
        t[rt].rc = RC;
        cout << rt << " " << t[rt].lc << " " << t[rt].rc << endl;
        cout << "____________________" << endl;
        return rt;
    }
};
signed main(){
    Segment_Tree<int> sgt;
    sgt.init(4);
}

```



## 线段树（多tag）

```cpp
int n,m,mod,a[N];

struct node {
    int l,r;
    ll sum,tag1,tag2;
}tree[N<<2];

void pushup(int p) {
    tree[p].sum = (tree[p << 1].sum + tree[p << 1 | 1].sum) % mod;
}

void build(int p,int l,int r) {
    tree[p].l = l,tree[p].r = r;tree[p].tag2 = 1;
    if (l == r) {
        tree[p].sum = a[l];
        return ;
    }
    int mid = l + r >> 1;
    build(p << 1,l,mid);
    build(p << 1 | 1,mid + 1,r);
    pushup(p);
}

void pushdown(int p) {
    if (tree[p].tag1 || tree[p].tag2 != 1) {
        tree[p<<1].tag1 = ((tree[p<<1].tag1 * tree[p].tag2) + tree[p].tag1)% mod;
        tree[p<<1|1].tag1 = ((tree[p<<1|1].tag1 * tree[p].tag2) + tree[p].tag1) % mod;
        tree[p<<1].tag2 = tree[p<<1].tag2 * tree[p].tag2 % mod;
        tree[p<<1|1].tag2 = tree[p<<1|1].tag2 * tree[p].tag2 % mod;
        tree[p<<1].sum = (1LL * tree[p<<1].sum * tree[p].tag2 + (tree[p<<1].r - tree[p<<1].l + 1) * tree[p].tag1) % mod;
        tree[p<<1|1].sum = (1LL * tree[p<<1|1].sum * tree[p].tag2 + (tree[p<<1|1].r - tree[p<<1|1].l + 1) * tree[p].tag1) % mod;
        tree[p].tag2 = 1,tree[p].tag1 = 0;
    }
}

void change1(int p,int x,int y,int k) {
    if (tree[p].l >= x && tree[p].r <= y) {
        tree[p].sum = (tree[p].sum + (tree[p].r - tree[p].l + 1) * k % mod) % mod;
        tree[p].tag1 = (tree[p].tag1 + k) % mod;
        return ;
    }
    pushdown(p);
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (x <= mid) change1(p << 1,x,y,k);
    if (y > mid) change1(p << 1 | 1,x,y,k);
    pushup(p);
}

void change2(int p,int x,int y,int k) {
    if (tree[p].l >= x && tree[p].r <= y) {
        tree[p].sum = (tree[p].sum * k) % mod;
        tree[p].tag1 = (tree[p].tag1 * k) % mod;
        tree[p].tag2 = (tree[p].tag2 * k) % mod;
        return ;
    }
    pushdown(p);
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (x <= mid) change2(p << 1,x,y,k);
    if (y > mid) change2(p << 1 | 1,x,y,k);
    pushup(p);
}

ll query(int p,int x,int y) {
    if (tree[p].l >= x && tree[p].r <= y) {
        return tree[p].sum % mod;
    }
    pushdown(p);
    int mid = (tree[p].l + tree[p].r) >> 1;
    ll ans = 0;
    if (x <= mid) ans = (ans + query(p << 1,x,y)) % mod;
    if (y > mid) ans = (ans + query(p << 1 | 1,x,y)) % mod;
    return ans;
}
```

## 线段树合并

```cpp
const int N = 1e6 + 10;

int n,m,tot,f[20][N],dep[N],root[N],r,ans[N];
vector <int> G[N];

struct node {
    int l,r;
	int cnt,typ;
}tree[N<<4];

void pushup(int p) {
	if (tree[tree[p].l].cnt > tree[tree[p].r].cnt) tree[p].cnt = tree[tree[p].l].cnt,tree[p].typ = tree[tree[p].l].typ;
	else if (tree[tree[p].l].cnt == tree[tree[p].r].cnt) tree[p].cnt = tree[tree[p].l].cnt,tree[p].typ = min(tree[tree[p].l].typ,tree[tree[p].r].typ);
	else tree[p].cnt = tree[tree[p].r].cnt,tree[p].typ = tree[tree[p].r].typ;
}

int modify(int p,int x,int k,int l,int r) {
	if (!p) p = ++tot;
	if (l == r) {
		tree[p].typ = l;tree[p].cnt += k;
		return p;
	}
	int mid = (l + r) >> 1;
	if (x <= mid) tree[p].l = modify(tree[p].l,x,k,l,mid);
	else tree[p].r = modify(tree[p].r,x,k,mid + 1,r);
	pushup(p);
	return p;
}

int merge(int p,int q,int l,int r) {
	if (!p) return q;
	if (!q) return p;
	if (l == r) {
		tree[p].cnt += tree[q].cnt;
		tree[p].typ = l;
		return p;
	}
	int mid = (l + r) >> 1;
	tree[p].l = merge(tree[p].l,tree[q].l,l,mid);
	tree[p].r = merge(tree[p].r,tree[q].r,mid + 1,r);
	pushup(p);
	return p;
}
```

## 线段树分治+可撤销并查集

```cpp
const int N = 4e5 + 10;

struct node {
    int l,r;
    vector <int> edg;
}tree[N<<2];

vector <pii> e;

int ans[N],n,m,k,f[N],h[N],top;
pii st[N];

int find(int x) {return x == f[x] ? x : find(f[x]);}

void merge(int x,int y) {
    int fx = find(x),fy = find(y);
    if (h[fx] > h[fy]) swap(fx,fy);
    f[fx] = fy;
    st[++top] = mp(fx,h[fx] == h[fy]);
    if (h[fx] == h[fy]) ++h[fy];
}


void build(int p,int l,int r) {
    tree[p].l = l,tree[p].r = r;
    if (l == r) {
        return ;
    }
    int mid = (l + r) >> 1;
    build(p << 1,l,mid);
    build(p << 1 | 1,mid + 1,r);
}

void modify(int p,int x,int y,int k) {
    if (tree[p].l >= x && tree[p].r <= y) {
        tree[p].edg.push_back(k);
        return ;
    }
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (x <= mid) modify(p << 1,x,y,k);
    if (y > mid) modify(p << 1 | 1,x,y,k);
    return ;
}

void solve(int p) {
    bool done = 0;
    int lst = top;
    for (auto num : tree[p].edg) {
        pii ed = e[num];
        int x = ed.first,y = ed.second;
        if (find(x) == find(y)) {
            for (int i = tree[p].l;i <= tree[p].r;++i) ans[i] = -1;
            done = 1;
            break;
        }
        merge(x,y + n);
        merge(y,x + n);
    }
    if (!done) {
        if (tree[p].l == tree[p].r) {
            ans[tree[p].l] = 1;
        } else {
            int mid = (tree[p].l,tree[p].r) >> 1;
            solve(p << 1);
            solve(p << 1 | 1);
        }
    }

    for (;top > lst;--top) {
        h[f[st[top].first]] -= st[top].second;
        f[st[top].first] = st[top].first;
    }
}

signed main() {
    read(n,m,k);    
    build(1,1,k);
    for (int i = 1;i <= m;++i) {
        int x,y,l,r;read(x,y,l,r);
        e.push_back(mp(x,y));
        modify(1,l+1,r,e.size() - 1);
    }
    for (int i = 1;i <= 2 * n;++i) f[i] = i,h[i] = 1;
    solve(1);
    for (int i = 1;i <= k;++i) {
        if (ans[i] == -1) puts("No");
        else puts("Yes");
    }
	return 0;   
}
```



## 笛卡尔树

```cpp
const int N = 1e7 + 10;
ll l[N],r[N],n,p[N],st[N],top;

signed main() {
	read(n);
    for (int i = 1;i <= n;++i) read(p[i]);
    for (int i = 1;i <= n;++i) {
        int k = top;
        while (k && p[st[k]] >= p[i]) --k;
        if (k) r[st[k]] = i;
        if (k < top) l[i] = st[k + 1];
        st[++k] = i;top = k;
    }
    ll ans1 = 0,ans2 = 0;
    for (ll i = 1;i <= n;++i) {
        ans1 ^= (ll)i * (l[i] + 1);ans2 ^= (ll)i * (r[i] + 1);
    }
    printf("%lld %lld\n",ans1,ans2);
	return 0;
}
```

## 树链剖分

```cpp
const int N = 3e5 + 10;
const int mod = 998244353;

int n,m,r,dep[N],siz[N],top[N],fat[N],son[N],dfn[N],rk[N],cnt,a[N];

vector <int> G[N];

void dfs1(int x,int f) {
	dep[x] = dep[f] + 1;
	siz[x] = 1;
	fat[x] = f;
	son[x] = 0;
	for (auto y : G[x]) {
		if (y != f) {
			dfs1(y,x);
			siz[x] += siz[y];
			if (siz[y] > siz[son[x]]) {
				son[x] = y;
			}
		}
	}
}

void dfs2(int x,int f) {
	dfn[x] = ++cnt;rk[cnt] = x;
	if (son[f] == x) top[x] = top[f];
	else top[x] = x;
	if (son[x]) {
		dfs2(son[x],x);
	}
	for (auto y : G[x]) {
		if (y != f && y != son[x]) {
			dfs2(y,x);
		}
	}
}

ll ffpow(ll x,ll k) {
    ll ans = 1;
    for (;k;k >>= 1) {
        if (k & 1) ans = ans *x %mod;
        x = x * x % mod;
    }
    return ans;
}

struct tree {
    int k;
    struct node {
        int l,r;
        int sum;
    }tree[N<<2];

    void pushup(int p) {
        tree[p].sum = (ll)(tree[p << 1].sum + tree[p << 1 | 1].sum) % mod;
    }

    void build(int p,int l,int r) {
        tree[p].l = l,tree[p].r = r;
        if (l == r) {
            tree[p].sum = ffpow(a[rk[l]],k);
            return ;
        }
        int mid = l+r >> 1;
        build(p << 1,l,mid);
        build(p << 1 | 1,mid + 1,r);
        pushup(p);
    }

    int query(int p,int x,int y) {
        if (tree[p].l >= x && tree[p].r <= y) {
            return tree[p].sum;
        }
        int mid = (tree[p].l + tree[p].r) >> 1,ans = 0;
        if (x <= mid) ans = (ll)(ans + query(p << 1,x,y)) % mod;
        if (y > mid) ans = (ll)(ans + query(p << 1 | 1,x,y)) % mod;
        return ans;
    }
}sgt[51];

int queryline(int x,int y,int k) {
    int ans = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x,y);
        ans = (ll)(ans + sgt[k].query(1,dfn[top[x]],dfn[x])) % mod;
        x = fat[top[x]];
    }
    if (dep[x] > dep[y]) swap(x,y);
    ans = (ll)(ans + sgt[k].query(1,dfn[x],dfn[y])) % mod;
    return ans;
}
```

## FHQ-Treap

```cpp
const int N = 1e5 + 10;

int getrand() {
    return (ll)rand() * rand() % 998244353;
}

struct node {
    int val,cnt,rnd;
    int ls,rs;
}tree[N];

int root,tot,n;

int newnode(int val) {
    tree[++tot].val = val;
    tree[tot].cnt = 1;
    tree[tot].rnd = getrand();
    return tot;
}

void pushup(int p) {
    tree[p].cnt = (tree[tree[p].ls].cnt + tree[tree[p].rs].cnt + 1);
}

void split(int p,int val,int &x,int &y) {
    if (!p) {
        x = y = 0;
        return ;
    }
    if (tree[p].val <= val) {
        x = p;
        split(tree[p].rs,val,tree[p].rs,y);
    } else {
        y = p;
        split(tree[p].ls,val,x,tree[p].ls);
    }
    pushup(p);
}

int merge(int x,int y) {
    if (!x || !y) {
        return x | y;
    }
    if (tree[x].rnd < tree[y].rnd) {
        tree[x].rs = merge(tree[x].rs,y);
        pushup(x);
        return x;
    } else {
        tree[y].ls = merge(x,tree[y].ls);
        pushup(y);
        return y;
    }
}

void insert(int val) {
    int x,y;
    split(root,val,x,y);
    root = merge(merge(x,newnode(val)),y);
}

void del(int val) {
    int x,y,z;
    split(root,val,x,z);
    split(x,val - 1,x,y);
    y = merge(tree[y].ls,tree[y].rs);
    root = merge(merge(x,y),z);
}

int findkth(int p,int val) {
    for (;;) {
        if (val <= tree[tree[p].ls].cnt) p = tree[p].ls;
        else if (val == tree[tree[p].ls].cnt + 1) return p;
        else val -= tree[tree[p].ls].cnt + 1,p = tree[p].rs;
    }
}

int findrnk(int val) {
    int x,y;
    split(root,val - 1,x,y);
    int ans = tree[x].cnt + 1;
    root = merge(x,y);
    return ans;
}

int findpre(int val) {
    int x,y;
    split(root,val-1,x,y);
    int ans = tree[findkth(x,tree[x].cnt)].val;
    root = merge(x,y);
    return ans;
}

int findnxt(int val) {
    int x,y;
    split(root,val,x,y);
    int ans = tree[findkth(y,1)].val;
    root = merge(x,y);
    return ans;
}
```

## 扫描线

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
#define int long long 
#define lson (x << 1)
#define rson (x << 1 | 1)
using namespace std;
const int MAXN = 1e6 + 10;
int n, cnt = 0;
int x1, y1, x2, y2, X[MAXN << 1];

struct ScanLine {
	int l, r, h;
	int mark;
//  mark用于保存权值 (1 / -1)
	bool operator < (const ScanLine &rhs) const {
		return h < rhs.h;
	}
} line[MAXN << 1];

struct SegTree {
	int l, r, sum;
	int len;
//  sum: 被完全覆盖的次数；
//  len: 区间内被截的长度。
} tree[MAXN << 2];

void build_tree(int x, int l, int r) {
//  我觉得最不容易写错的一种建树方法
	tree[x].l = l, tree[x].r = r;
	tree[x].len = 0;
	tree[x].sum = 0;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build_tree(lson, l, mid);
	build_tree(rson, mid + 1, r);
	return;
}

void pushup(int x) {
	int l = tree[x].l, r = tree[x].r;
	if(tree[x].sum /* 也就是说被覆盖过 */ )
		tree[x].len = X[r + 1] - X[l];
//      更新长度        
	else
		tree[x].len = tree[lson].len + tree[rson].len;
//      合并儿子信息
}

void edit_tree(int x, int L,int R, int c) {
	int l = tree[x].l, r = tree[x].r;
//  注意，l、r和L、R的意义完全不同
//  l、r表示这个节点管辖的下标范围
//  而L、R则表示需要修改的真实区间
	if(X[r + 1] <= L || R <= X[l])
		return;
//  这里加等号的原因：
//  假设现在考虑 [2,5], [5,8] 两条线段，要修改 [1,5] 区间的sum
//  很明显，虽然5在这个区间内，[5,8] 却并不是我们希望修改的线段
//  所以总结一下，就加上了等号
	if(L <= X[l] && X[r + 1] <= R) {
		tree[x].sum += c;
		pushup(x);
		return;
	}
	edit_tree(lson, L, R, c);
	edit_tree(rson, L, R, c);
	pushup(x);
}

signed main() {
	cin>>n;
	for(int i = 1; i <= n; i++) {
		cin>>x1>>y1>>x2>>y2;
		X[2 * i - 1] = x1, X[2 * i] = x2;
		line[2 * i - 1] = (ScanLine) {x1, x2, y1, 1};
		line[2 * i] = (ScanLine) {x1, x2, y2, -1};
//      一条线段含两个端点，一个矩形的上下边都需要扫描线扫过
	}
	n <<= 1;
//  直接把 n <<= 1 方便操作
	sort(line + 1, line + n + 1);
	sort(X + 1, X + n + 1);
	int tot = unique(X + 1, X + n + 1) - X - 1;
//  去重最简单的方法：使用unique！（在<algorithm>库中）
	build_tree(1, 1, tot - 1);
//  为什么是 tot - 1 ：
//  因为右端点的对应关系已经被篡改了嘛…
//  [1, tot - 1]描述的就是[X[1], X[tot]]
	int ans = 0;
	for(int i = 1; i < n /* 最后一条边是不用管的 */ ; i++) {
		edit_tree(1, line[i].l, line[i].r, line[i].mark);
//      先把扫描线信息导入线段树
		ans += tree[1].len * (line[i + 1].h - line[i].h);
//      然后统计面积
	}
	cout<<ans;
	return 0;
}
```

## CDQ分治

```cpp

int n,k;

int t[N];
void change(int x,int v) {for (;x <= k; x += (x & (-x))) t[x]+=v;}
int query(int x) {int ans = 0;for (;x;x -= (x & (-x))){ans += t[x];}return ans;}

struct node {
	int a,b,c,cnt,ans;
	friend inline bool operator != (const node & a,const node &b) {
		if (a.a != b.a || a.b != b.b || a.c != b.c) return 1;
		return 0;
	}
}pre[N],cdq[N];

inline bool cmp1(node x,node y) {
	if (x.a == y.a) {
		if (x.b == y.b) return x.c < y.c;
		return x.b < y.b;
	}
	return x.a < y.a;
}

inline bool cmp2(node x,node y) {
	if (x.b == y.b) return x.c < y.c;
	return x.b < y.b;
}

int vie[N],rep,tot,su[N];

void CDQ(int l,int r) {
	if (l == r) return ;
	int mid = (l + r) >> 1;
	CDQ(l,mid);
	CDQ(mid+1,r);
	sort(cdq+l,cdq+1+mid,cmp2);
	sort(cdq+mid+1,cdq+1+r,cmp2);
    int i,j = l;
	for (i = mid + 1;i <= r;++i) {
		while (cdq[i].b >= cdq[j].b && j <= mid) {
			change(cdq[j].c,cdq[j].cnt);
			++j;
		}
		cdq[i].ans += query(cdq[i].c);
	}										
	for (i = l;i < j;++i) {
		change(cdq[i].c,-cdq[i].cnt);
	}
}
signed main() {
	read(n,k);
	for (int i = 1;i <= n;++i) read(pre[i].a,pre[i].b,pre[i].c);
	sort(pre+1,pre+1+n,cmp1);
	for (int i = 1;i <= n;++i) {
		++rep;
		if (pre[i] != pre[i+1]) {
			cdq[++tot].a = pre[i].a;cdq[tot].b = pre[i].b;cdq[tot].c = pre[i].c;cdq[tot].cnt = rep;
			rep = 0;
		}
	}
	CDQ(1,tot);
	for (int i = 1;i <= tot;++i) {
		//printf("%d %d %d %d %d\n", cdq[i].a,cdq[i].b,cdq[i].c,cdq[i].ans,cdq[i].cnt);
		su[cdq[i].ans + cdq[i].cnt - 1] += cdq[i].cnt;
	}
	for (int i = 0;i < n;++i) {
		printf("%d\n", su[i]);
	}
	return 0;
}
```



# 图论

## 强连通分量

```cpp
const int N = 1e4 + 10;

vector <int> G1[N],G2[N];

int n,m,siz[N],dfn[N],low[N],c[N],col[N],a[N],cnt,tot,ind[N],f[N];
int s[N],top;
bool ins[N];

void tarjan(int x)  {
	dfn[x] = low[x] = ++cnt;
	s[++top] = x;ins[x] = 1;
	for (auto y : G1[x]) {
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x],low[y]);
		} else if (ins[y]) {
			low[x] = min(low[x],low[y]);
		}
	}
	if (dfn[x] == low[x]) {
		int y;col[x] = ++tot;
		do {
			y = s[top--];
			col[y] = tot;
			ins[y] = 0;
			c[tot] += a[y];
		} while (x != y);
	}
}

signed main() {
	read(n,m);
	for (int i = 1;i <= n;++i) read(a[i]);
	for (int i = 1;i <= m;++i) {
		int x,y;read(x,y);G1[x].push_back(y);
	}
	for (int i = 1;i <= n;++i) {
		if (!dfn[i]) tarjan(i);
	}
	for (int x = 1;x <= n;++x) {
		for (auto y : G1[x]) {
			if (col[x] != col[y]) {
				G2[col[x]].push_back(col[y]);
				ind[col[y]]++;
			}
		}
	}
}
```

## 差分约束

```cpp

const int N = 5e3 + 10;

int dis[N],cnt[N],n,m;
bool vis[N];

vector <pii> G[N]; 

bool SPFA() {
    queue <int> q;
    memset(dis,0x3f,sizeof dis);
    q.push(dis[0] = 0);vis[0] = 1;
    while (!q.empty()) {
        int x = q.front();q.pop();
        vis[x] = 0;
        for (auto e : G[x]) {
            int y = e.first,w = e.second;
            if (dis[y] > dis[x] + w) {
                dis[y] = dis[x] + w;
                cnt[y] = cnt[x] + 1;
                if (!vis[y]) {
                    if (cnt[y] >= n) {
                        return 1;
                    }
                    q.push(y);vis[y] = 1;
                }
            }
        }
    }
    return 0;
}

signed main() {
    read(n,m);
    for (int i = 1;i <= n;++i) {
        G[0].push_back(mp(i,0));
    }
    for (int i = 1;i <= m;++i) {
        int x,y,w;read(x,y,w);
        G[y].push_back(mp(x,w));
    }
    if (SPFA()) puts("NO");
    else {
        for (int i = 1;i <= n;++i) printf("%d ",dis[i]);
    }
	return 0;
}
```



## 2-SAT

```cpp
signed main() {
    read(n,m);
    for (int i = 1;i <= m;++i) {
        int x,a,y,b;read(x,a,y,b);
        G[x + n * (a & 1)].push_back(y + n * (b ^ 1));
        G[y + n * (b & 1)].push_back(x + n * (a ^ 1)); 
    }
    for (int i = 1;i <= 2*n;++i) {
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 1;i <= n;++i) {
        if (c[i] == c[i+n]) {
            puts("IMPOSSIBLE");
            return 0;
        }
    }
    puts("POSSIBLE");
    for (int i = 1;i <= n;++i) {
        printf("%d ",c[i] < c[i+n]);
    } 
	return 0;
}
```

## 割点

```cpp
vector <int> G[N];

int n,m,dfn[N],low[N],cut[N],root,flag,cnt;

void tarjan(int x) {
    dfn[x] = low[x] = ++cnt;
    int flag = 0;
    for (auto y : G[x]) {
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x],low[y]);
            if (low[y] >= dfn[x]) {
                ++flag;
                if (root != x || flag > 1) cut[x] = 1;
            }
        } else {
            low[x] = min(low[x],dfn[y]);
        }
    }
}

```

## 割边

```cpp
int hd[N],to[M],nxt[M],tot = 1,cnt,n,m,low[N],dfn[N];

inline void add(int x,int y) {
    to[++tot] = y;nxt[tot] = hd[x];hd[x] = tot;
}

inline void addedge(int x,int y) {
    add(x,y);add(y,x);
}

bool bri[M];

void tarjan(int x,int ine) {
    dfn[x] = low[x] = ++cnt;
    for (int i = hd[x];i;i = nxt[i]) {
        int y = to[i];
        if (!dfn[y]) {
            tarjan(y,i);
            low[x] = min(low[x],low[y]);
            if (low[y] > dfn[x]) bri[i] = bri[i ^ 1] = 1;
        } else if (i != (ine ^ 1)) {
            low[x] = min(low[x],dfn[y]);
        }
    }
}
```

## 点分治

```cpp
const int N = 1e4 + 10;
const int M = 1e7 + 10;

int n,m,que[N],siz[N],w[N],tot,root,dis[N],ans[N];
vector <pii> G[N];
vector <int> tmp;
bool vis[M],cz[M];

void findroot(int x,int f) {
    siz[x] = 1;w[x] = 0;
    for (auto e : G[x]) {
        int y = e.first;
        if (!vis[y] && y != f) {
            findroot(y,x);
            siz[x] += siz[y];
            w[x] = max(w[x],siz[y]);
        }
    }
    w[x] = max(w[x],tot - siz[x]);
    if (w[root] > w[x]) root = x;
}

void getdis(int x,int f) {
    tmp.push_back(dis[x]);
    for (auto e : G[x]) {
        int y = e.first,w = e.second;
        if (y != f && !vis[y]) {
            dis[y] = dis[x] + w;
            getdis(y,x);
        }
    }
}

void calc(int x,int f) {
    cz[0] = 1;
    vis[x] = 1;
    vector <int> rec;rec.push_back(0);
    for (auto e : G[x]) {
        int y = e.first,w = e.second;
        if (y != f && !vis[y]) {
            dis[y] = w;
            getdis(y,x);
            for (auto qwq : tmp) {
                for (int j = 1;j <= m;++j) {
                    if (que[j] >= qwq) {
                        ans[j] |= cz[que[j] - qwq];
                    }
                }
            } 
            for (auto qwq : tmp) {
                rec.push_back(qwq);
                cz[qwq] = 1;
            }
            tmp.clear();
        }
    }
    for (auto qwq : rec) {
        cz[qwq] = 0;
    }
    for (auto e : G[x]) {
        int y = e.first;
        if (y != f && !vis[y]) {
            tot = siz[y];
            w[root = 0] = 0x3f3f3f3f;
            findroot(y,x);
            findroot(root,-1);
            calc(root,x);
        }
    }
}

signed main() {
    read(n,m);
    for (int i = 1;i < n;++i) {
        int x,y,z;read(x,y,z);
        G[x].push_back(mp(y,z));
        G[y].push_back(mp(x,z));
    }
    for (int i = 1;i <= m;++i) read(que[i]);
    w[root] = 0x3f3f3f3f;tot = n;
    findroot(1,-1); 
    findroot(root,-1);
    calc(root,-1);
    for (int i = 1;i <= m;++i) {
        if (ans[i]) puts("AYE");
        else puts("NAY");
    } 
}
```



## Dinic

```cpp
template<class T>
struct Flow {
    const int n;
    struct Edge {
        int to;
        T cap;
        Edge(int to, T cap) : to(to), cap(cap) {}
    };
    std::vector<Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<int> cur, h;
    Flow(int n) : n(n), g(n) {}
    
    bool bfs(int s, int t) {
        h.assign(n, -1);
        std::queue<int> que;
        h[s] = 0;
        que.push(s);
        while (!que.empty()) {
            const int u = que.front();
            que.pop();
            for (int i : g[u]) {
                auto [v, c] = e[i];
                if (c > 0 && h[v] == -1) {
                    h[v] = h[u] + 1;
                    if (v == t) {
                        return true;
                    }
                    que.push(v);
                }
            }
        }
        return false;
    }
    
    T dfs(int u, int t, T f) {
        if (u == t) {
            return f;
        }
        auto r = f;
        for (int &i = cur[u]; i < int(g[u].size()); ++i) {
            const int j = g[u][i];
            auto [v, c] = e[j];
            if (c > 0 && h[v] == h[u] + 1) {
                auto a = dfs(v, t, std::min(r, c));
                e[j].cap -= a;
                e[j ^ 1].cap += a;
                r -= a;
                if (r == 0) {
                    return f;
                }
            }
        }
        return f - r;
    }
    void addEdge(int u, int v, T c) {
        g[u].push_back(e.size());
        e.emplace_back(v, c);
        g[v].push_back(e.size());
        e.emplace_back(u, 0);
    }
    T maxFlow(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n, 0);
            ans += dfs(s, t, std::numeric_limits<T>::max());
        }
        return ans;
    }
};
```

## MCMF(Ford)

```cpp
const int N = 1e6 + 10;

vector <pii> G[N];

struct edge {
	int from,cap,flow,cost;
}e[N];

int tot = -1,s,t;

void addedge(int u,int v,int w,int co) {
    e[++tot].cap = w;e[tot].cost = co;e[tot].flow = 0;e[tot].from = u;
    G[u].push_back(mp(v,tot));
    e[++tot].cap = 0;e[tot].cost = -co;e[tot].flow = 0;e[tot].from = v;
    G[v].push_back(mp(u,tot));
}

int dis[N],inq[N],p[N],a[N],n,m;

bool Ford(int &flow,int &cost) {
    memset(dis,0x3f,sizeof dis);
    memset(inq,0,sizeof inq);
    queue <int> q;
    dis[s] = 0;
    inq[s] = 1;
    p[s] = 0;a[s] = 0x3f3f3f3f;
    q.push(s);
    while (!q.empty()) {
        int x = q.front();q.pop();
        inq[x] = 0;
        for (auto now : G[x]) {
            int y = now.first;
            edge& edg = e[now.second];
            if (edg.cap > edg.flow && dis[y] > dis[x] + edg.cost) {
                dis[y] = dis[x] + edg.cost;
                p[y] = now.second;
                a[y] = min(a[x],edg.cap - edg.flow);
                if (!inq[y]) {
                    q.push(y);
                    inq[y] = 1;
                }
            }
        }
    }
    if (dis[t] == 0x3f3f3f3f) return 0;
    flow += a[t];cost += dis[t] * a[t];
    int x = t;
    while (x != s) {
        e[p[x]].flow += a[t];
        e[p[x] ^ 1].flow -= a[t];
        x = e[p[x]].from;
    }
    return 1;
}

pii MCMF() {
    int cost = 0,flow = 0;
    while (Ford(flow,cost));
    return mp(flow,cost);
} 
```

## SPFA判负环

```cpp
const int N = 5e3 + 10;

int dis[N],cnt[N],n,m;
bool vis[N];

vector <pii> G[N]; 

bool SPFA() {
    queue <int> q;
    memset(dis,0x3f,sizeof dis);
    q.push(dis[0] = 0);vis[0] = 1;
    while (!q.empty()) {
        int x = q.front();q.pop();
        vis[x] = 0;
        for (auto e : G[x]) {
            int y = e.first,w = e.second;
            if (dis[y] > dis[x] + w) {
                dis[y] = dis[x] + w;
                cnt[y] = cnt[x] + 1;
                if (!vis[y]) {
                    if (cnt[y] >= n) {
                        return 1;
                    }
                    q.push(y);vis[y] = 1;
                }
            }
        }
    }
    return 0;
}
```

## Dijkstra

```cpp
const int N = 1e5 + 10;

vector <pii> G[N];
int n,m,s,dis[N];
bool vis[N];

struct node {
    int pos,dis;
    friend inline bool operator < (const node &a,const node &b) {
        return a.dis > b.dis;
    }
};

priority_queue <node> q;

void Dijkstra(int s) {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    q.push((node){s,dis[s] = 0});
    //vis[s] = 1;
    while (!q.empty()) {
        node p = q.top();q.pop();
        int x = p.pos;
        if (vis[x]) continue;
        vis[x] = 1;
        for (auto e : G[x]) {
            int y = e.first,w = e.second;
            if (dis[y] > dis[x] + w) {
                dis[y] = dis[x] + w;
                    q.push((node){y,dis[y]});
                
            }
        }
    }
}
```

## 匈牙利

```cpp
vector <int> G[N];

int n,m,e,vis[N],mat[N];

bool match(int x) {
    for (auto y : G[x]) {
        if (!vis[y]) {
            vis[y] = 1;
            if (!mat[y] || match(mat[y])) {
                mat[y] = x;
                return 1;
            }
        }
    }
    return 0;
}

signed main() {
    read(n,m,e);
    for (int i = 1;i <= e;++i) {
        int x,y;read(x,y);
        G[x].push_back(y+n);
    }
    int ans = 0;
    for (int i = 1;i <= n;++i) {
        memset(vis,0,sizeof vis);
        if (match(i)) {
            ++ans;
        }
    }
}
```

## 倍增LCA

```cpp
const int N = 5e5 + 10;
vector <int> G[N];
int n,m,f[20][N],dep[N],s;

void dfs(int x,int fa) {
    f[0][x] = fa;
    dep[x] = dep[fa] + 1;
    for (int i = 1;i <= 19;++i) {
        f[i][x] = f[i-1][f[i-1][x]];
    }
    for (auto y : G[x]) {
        if (y != fa) dfs(y,x);
    }
}

int LCA(int x,int y) {
    if (dep[x] > dep[y]) swap(x,y);
    for (int i = 19;i >= 0;--i) {
        if (dep[f[i][y]] >= dep[x]) y = f[i][y];
    }
    if (x == y) return x;
    
    for (int i = 19;i >= 0;--i) {
        if (f[i][x] != f[i][y]) {x = f[i][x];y = f[i][y];}
    }
    return f[0][x];
}
```

## 欧拉路径

```cpp
const int N = 1e5 + 10;
vector <pii> G[N];
vector <int> ans;
int n,m,tot,d1[N],d2[N],cur[N];
bool vis[N];

void dfs(int x) {
    //printf("%d\n",x);
    for (int &i = cur[x];i < G[x].size();++i) {
        pii &e = G[x][i];
        int y = e.first;
        if (!e.second) {
            e.second = 1;
            dfs(y);
        }
    }
    ans.push_back(x);
}

signed main() {
	read(n,m);
    for (int i = 1;i <= m;++i) {
        int x,y;read(x,y);
        G[x].push_back(mp(y,0));
        d1[x]++,d2[y]++;
    }
    for (int i = 1;i <= n;++i) sort(G[i].begin(),G[i].end());
    bool flag = 1;
    int cnt1 = 0,cnt2 = 0,s = 1;
    for (int i = 1;i <= n;++i) {
        if (d1[i] != d2[i]) flag = 0;
        if (d1[i] - d2[i] == 1)++cnt1,s = i;
        if (d2[i] - d1[i] == 1)++cnt2;
    }
    if (!flag && !(cnt1 == 1 && cnt2 == 1)) {
        puts("No");
        return 0;
    }
    dfs(s);
    reverse(ans.begin(),ans.end());
    //if (ans.size() != n) puts("No");
    for (auto x : ans) printf("%d ",x);
	return 0;
}
```

## 最小斯坦纳树

给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。

再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G'=(V',E')$，使得：

1. $S\subseteq V'$；

2. $G'$ 为连通图；

3. $E'$ 中所有边的权值和最小。

你只需要求出 $E'$ 中所有边的权值和。

```cpp
const int N = 5e3 + 10;

int n,m,k,f[N][N],poi[N];
bool vis[N];

struct node {
    int dis,pos;
    friend inline bool operator < (const node &a,const node &b) {
        return a.dis > b.dis;
    }
};

vector <pii> G[N];
priority_queue <node> q;

void Dijkstra(int s) {
    memset(vis,0,sizeof vis);
    while (!q.empty()) {
        node p = q.top();q.pop();
        int x = p.pos;
        if (vis[x]) continue;
        vis[x] = 1;
        for (auto e : G[x]) {
            int y = e.first,w = e.second;
            if (f[y][s] > f[x][s] + w) {
                f[y][s] = f[x][s] + w;
                q.push((node){f[y][s],y});
            }
        }
    }
}

signed main() {
    read(n,m,k);
    for (int i = 1;i <= m;++i) {
        int x,y,w;read(x,y,w);
        G[x].push_back(mp(y,w));
        G[y].push_back(mp(x,w));
    }
    memset(f,0x3f,sizeof f);
    for (int i = 1;i <= k;++i) read(poi[i]),f[poi[i]][1<<(i-1)] = 0;
    for (int s = 1;s < (1 << k);++s) {
        for (int x = 1;x <= n;++x) {
            for (int sub = s;sub;sub = (sub - 1) & s) {
                f[x][s] = min(f[x][s],f[x][sub] + f[x][s ^ sub]);
            }
            if (f[x][s] != 0x3f3f3f3f) {
                q.push((node){f[x][s],x});
            }
        }
        Dijkstra(s);
    }
    printf("%d",f[poi[k]][(1 << k) - 1]);
	return 0;
}

```



# 字符串

## Manacher

```cpp
const int N = 3e7 + 10;

char c[N],s[N];
int n,m,d[N];

signed main() {
    scanf("%s",c+1);
    m = strlen(c+1);
    s[0] = '#';
    for (int i = 1;i <= m;++i) {
        s[++n] = c[i];s[++n] = '#';
    }
    int l = 0,r = -1,ans = 0;
    for (int i = 0;i <= n;++i) {
        int k = (i > r) ? 1 : min(d[l + r - i],r - i + 1);
        while (k <= i && i + k <= n && s[i+k] == s[i-k]) ++k;
        d[i] = --k;
        ans = max(ans,d[i]);
        if (i + k > r) {
            l = i-k;r = i+k;
        }
    }
    printf("%d\n",ans);

	return 0;
}
```

## KMP

```cpp
char s[N],t[N];
int n,m,nxt[N],f[N];

signed main() {
    scanf("%s",s+1);
    scanf("%s",t+1);
    n = strlen(s+1),m = strlen(t+1);
    for (int i = 2,j = 0;i <= m;++i) {
        while (j && t[i] != t[j+1]) j = nxt[j];
        if (t[i] == t[j + 1]) ++j;
        nxt[i] = j;
    }
    for (int i = 1,j = 0;i <= n;++i) {
        while (j && s[i] != t[j+1]) j = nxt[j];
        if (s[i] == t[j + 1]) ++j;
        f[i] = j;
    }
    for (int i = 1;i <= n;++i) {
        if (f[i] == m) printf("%d\n",i - m + 1);
    }
    for (int i = 1;i <= m;++i) printf("%d ",nxt[i]);


	return 0;
}
```

## Trie

```cpp
const int  maxn = 3e6+100 ;
using namespace std;
int tot;
struct node{
	int son[63];
	int val;
}tree[maxn];
int getnum(char x){
    if(x>='A'&&x<='Z')
        return x-'A';
    else if(x>='a'&&x<='z')
        return x-'a'+26;
    else
        return x-'0'+52;
} 
void insert(string s){
	int len=s.length(),root=0;
	for(int i=0;i<len;++i){
		int ch=getnum(s[i]);
		if(!tree[root].son[ch]) 
			tree[root].son[ch]=++tot;
		root=tree[root].son[ch];
		tree[root].val++;
	}
}
int ans(string s){
	int len=s.length(),root=0;
	for(int i=0;i<len;++i){
		int ch=getnum(s[i]);
		if(!tree[root].son[ch]) return 0;
		root=tree[root].son[ch];
	}
	return tree[root].val;
}
```

## ACAM

```CPP

const int N = 2e5 + 10;

char s[N*11];
int n,trie[N][26],tag[N*26+10],tot,root,fail[N*26+10],cnt[N*26+10],endd[N];
vector <int> G[N*26+10];

void insert(char *s,int whi) {
    int p = root,len = strlen(s+1);
    for (int i = 1;i <= len;++i) {
        int now = s[i] - 'a';
        if (!trie[p][now]) trie[p][now] = ++tot;
        p = trie[p][now];
    }
    endd[whi] = p;
}

void getfail() {
    queue <int> q;
    for (int i = 0;i < 26;++i) {
        if (trie[0][i]) {
            q.push(trie[0][i]);
        }
        fail[trie[0][i]] = 0;
    }
    while(!q.empty()) {
        int x = q.front();q.pop();
        //printf("%d\n",x);
        for (int i = 0;i < 26;++i) {
            if (trie[x][i]) {
                fail[trie[x][i]] = trie[fail[x]][i];
                q.push(trie[x][i]);
            } else {
                trie[x][i] = trie[fail[x]][i];
            }
        }   
    }
}

void dfs(int x,int fa) {
    for (auto y : G[x]) {
        if (y != fa) {
            dfs(y,x);
            cnt[x] += cnt[y];
        }
    }
}

signed main() {
    #ifndef ONLINE_JUDGE
        freopen("test.in","r",stdin);
        freopen("test.out","w",stdout);
    #endif
    
    scanf("%d",&n);
    for (int i = 1;i <= n;++i){
        scanf("%s",s+1);
        insert(s,i);
    }
    getfail();
    for (int i = 1;i <= tot;++i) {
        G[fail[i]].push_back(i);
        G[i].push_back(fail[i]);
        //printf("%d %d\n",fail[i],i);
    }
    scanf("%s",s+1);
    int len = strlen(s+1),p = 0;
    for (int i = 1;i <= len;++i) {
        int now = s[i] - 'a';
        //printf("%d ",p);
        p = trie[p][now];cnt[p]++;
    }

    dfs(0,-1);

    //for (int i = 1;i <= tot;++i) printf("%d %d\n",i,cnt[i]);
    for (int i = 1;i <= n;++i) printf("%d\n",cnt[endd[i]]);
    #ifndef ONLINE_JUDGE
        fclose(stdin);fclose(stdout);
    #endif
	return 0;
}

```



# 数学

## 线性筛素数

```cpp
const int N = 1e8 + 10;
int cnt,p[N],tot,n,q;
bool vis[N];

void euler() {
    for (int i = 2;i <= n;++i) {
        if (!vis[i]) p[++tot] = i;
        for (int j = 1;j <= tot && i * p[j] <= n;++j) {
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
}
```

## BSGS

求解 $b^l\bmod n(\bmod p)$

```CPP
ll ffpow(ll a,ll b,ll p) {
	ll ans = 1;
	for (;b;b >>= 1) {
		if (b & 1) ans = ans * a % p;
		a = a * a % p;
	}
	return ans % p;
}

ll BSGS(ll a,ll b,ll p) {
	unordered_map <ll,ll> hash;
	ll tmp = b * a % p,t = sqrt(p) + 1;
	for (ll i = 1;i <= t;++i) {
		hash[tmp] = i; 
		//printf("%lld %lld\n",tmp,i);
		tmp = (tmp * a) % p;
	}
	ll at = ffpow(a,t,p),now = at;
	for (ll i = 1;i <= t;++i) {
		if (hash[now]) {
			return i * t - hash[now];
		}
		now = (now * at) % p;
	}
	return -1;
}
```

## exBSGS

```cpp

unordered_map <ll,ll> h;
inline ll exbsgs(ll a, ll b, ll p)
{
    a %= p, b %= p;
    if(b == 1) return 0; 										//特判2
    ll g, d = 0;
    ll c = 1;
    while((g = gcd(a, p)) > 1)
    {
        if(b % g) return -1;
        b /= g, p /= g, c = c * (a / g) % p, ++d;
        if(c == b) return d; 						//特判3（其实等价于特判2）
    }
    h.clear();
    ll t = sqrt(p * 1.0) + 1;
    ll base = b;									//计算右半部分的值
    for(ll i = 0; i < t; i++)
        h[base] = i, base = base * a % p;
    base = ffpow(a, t, p); 							//用左半边的值验证
    ll now = c;
    for(ll i = 1; i <= t + 1; i++)
    {
        now = now * base % p;
        if(h.count(now))
            return i * t - h[now] + d;				//返回解
    }
    return -1;										//无解
}
```

## 高斯消元

```cpp

double a[N][N],ans[N];
int n;
bool flag;
void Gauss() {
    for (int i = 1;i <= n;++i) {
        int pos = i;
        for (int j = i + 1;j <= n;++j) {
            if (fabs(a[j][i]) > fabs(a[pos][i])) {
                pos = j;
            }
        }
        if (fabs(a[pos][i]) < eps) {
            puts("No Solution");
            flag = 1;
            return ;
        }
        if (pos != i) swap(a[i],a[pos]);
        double tmp = a[i][i];
        for (int j = i;j <= n + 1;++j) a[i][j] /= tmp;
        for (int j = i + 1;j <= n;++j) {
            tmp = a[j][i];
            for (int k = i;k <= n + 1;++k) {
                a[j][k] -= a[i][k] * tmp;
            }
        }
    }
    //up-triangle matrix.
    ans[n] = a[n][n+1];
    for (int i = n - 1;i >= 1;--i) {
        ans[i] = a[i][n + 1];
        for (int j = i + 1;j <= n;++j) {
            ans[i] -= (a[i][j] * ans[j]);
        }
    }
}
```

## 矩阵快速幂

```cpp
struct matrix {
    ll a[N][N];

    friend inline matrix operator * (const matrix& A,const matrix &B) {
        matrix C;
        for (int i = 1;i <= n;++i) {
            for (int j = 1;j <= n;++j) {
                C.a[i][j] = 0;
                for (int k = 1;k <= n;++k) {
                    C.a[i][j] = (C.a[i][j] + (A.a[i][k] * B.a[k][j])) % mod;
                }
            }
        }
        return C;
    }
}A,E;

matrix ffpow(matrix a,ll b) {
    matrix ans = E;
    for (;b;b >>= 1) {
        if (b & 1) ans = ans * a;
        a = a * a;
    }
    return ans;
}

signed main() {
    read(n,k);
    for (int i = 1;i <= n;++i) {
        for (int j = 1;j <= n;++j)  {
            E.a[i][i] = 1;
            read(A.a[i][j]);
        }
    }
    matrix ans = ffpow(A,k);
    for (int i = 1;i <= n;++i) {
        for (int j = 1;j <= n;++j) {
            printf("%d ",ans.a[i][j]);
        }
        puts("");
    }
	return 0;
}
```



## 线性基

```cpp
ll n,a[N],s[N];

void insert(ll x) {
    for (int i = 50;i >= 0;--i) {
        if (x & (1LL << i)) {
            if (s[i]) x ^= s[i];
            else {
                for (int j = 0;j < i;++j) {
                    if (x & (1LL << j)) x ^= s[j];
                }
                for (int j = i + 1;j <= 50;++j) {
                    if (s[j] & (1LL << i)) s[j] ^= x;
                }
                s[i] = x;
                return ;
            }
        }
    }
}

signed main() {
	read(n);
    for (int i = 1;i <= n;++i) read(a[i]),insert(a[i]);
    ll ans = 0;
    for (int i = 0;i <= 50;++i) ans ^= s[i];
    printf("%lld\n",ans);
    return 0;
}

```

## 杜教筛

```cpp

ll phi[N],maxn,maxm,n,mu[N],pri[N],tot,prephi[M],premu[M];
bool vis[N];


void init() {
    phi[1] = mu[1] = 1;
    for (int i = 2;i <= N-10;++i) {
        if (!vis[i]) pri[++tot] = i,mu[i] = -1,phi[i] = i - 1;
        for (int j = 1;j <= tot && pri[j] * i <= N - 10;++j) {
            vis[pri[j] * i] = 1;
            if (i % pri[j] == 0) {
                phi[i * pri[j]] = phi[i] * pri[j];
                break;
            }
            phi[i * pri[j]] = phi[i] * phi[pri[j]];
            mu[i * pri[j]] = -mu[i];
        }
    }
    for (int i = 1;i <= N-10;++i) mu[i] += mu[i-1],phi[i] += phi[i-1];
}

ll getphi(ll x) {
    //printf("%lld ",x);
    if (x < N-10) return phi[x];
    ll now = n / x;
    if (prephi[now]) return prephi[now];
    ll ans = x * (x + 1) / 2;
    for (ll l = 2,r;l <= x;l = r + 1) {
        r = x / (x / l);
        ans -= (r - l + 1) * getphi(x / l);
    }
    return prephi[now] = ans;
}

ll getmu(ll x) {
    if (x < N-10) return mu[x];
    ll now = n / x;
    if (premu[now]) return premu[now];
    ll ans = 1;
    for (ll l = 2,r;l <= x;l = r + 1) {
        r = x / (x / l);
        ans -= (r - l + 1) * getmu(x / l);
    }
    return premu[now] = ans;
}

```

## NTT

```cpp

const double Pi = acos(-1);
const int N = 3000010;
const int mod = 998244353;//假装有mod
const int G = 3;
const int Gi = 332748118;
int a[N],b[N],c[N],n,m,lim = 1,rev[N],len;

int ffpow(int a,int b) {
    int ans = 1;
    for (;b;b >>= 1) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
    }
    return ans;
}

void NTT(int *A,int typ) {
    for (int i = 0;i < lim;++i) if (i < rev[i]) swap(A[i],A[rev[i]]);
    for (int mid = 1;mid < lim;mid <<= 1) {
        ll gn = ffpow(typ==1?G:Gi,(mod - 1) / (mid << 1));
        for (int j = 0;j < lim;j += (mid << 1)) {
            ll w = 1;
            for (int k = 0;k < mid;++k,w = (w * gn) % mod) {
                int x = A[j + k],y = w * A[j + k + mid] % mod;
                A[j + k] = (x + y) % mod;
                A[j + k + mid] = (x - y + mod) % mod;
            }
        }
    }
}
```

## FFT

```cpp
const int INF = 0x3f3f3f3f;
const ll inf = 0x3f3f3f3f3f3f3f3fLL;
const double Pi = acos(-1);
const int N = 3000010;

struct Complex {
    double r,i;//r+i; 
    Complex() {r = 0,i = 0;}
    Complex(double aa,double bb):r(aa),i(bb){};
    friend inline Complex operator + (Complex a,Complex b) {
        return Complex(a.r + b.r,a.i + b.i);
    }
    friend inline Complex operator - (Complex a,Complex b) {
        return Complex(a.r - b.r,a.i - b.i);
    }
    friend inline Complex operator * (Complex a,Complex b) {
        return Complex(a.r * b.r - a.i * b.i,a.r * b.i + a.i * b.r);
    }
}a[N],b[N];

int n,m,lim = 1,len,rev[N];

void FFT(Complex* a,int opt) {
    for (int i = 0;i < lim;++i) if (i < rev[i]) std::swap(a[i],a[rev[i]]);
    for (int dep = 1;dep <= (log(lim) / log(2));++dep) {
        int m = 1 << dep;
        Complex wn = Complex(cos(2.0 * Pi / m),opt * sin(2.0 * Pi / m));
        for (int k = 0;k < lim;k += m) {
            Complex w = Complex(1,0);
            for (int j = 0;j < m/2;++j) {
                Complex t = w * a[j+k+m/2];
                Complex u = a[k+j];
                a[k+j] = u + t;
                a[k+j+m/2] = u - t;
                w = w * wn;
            }
        }
    }
    if (opt == -1) for (int i = 0;i < lim;++i) a[i].r /= lim;
}

```



# 计算几何

```cpp
/*一：【准备工作】*/
#define LL long long
#define Point Point
using namespace std;
const int N = 2e5 + 10;
const double eps = 1e-8,Pi = acos(-1.0);
int dcmp(double a){return a<-eps?-1:(a>eps?1:0);}//处理精度
double Abs(double a){return a*dcmp(a);}//取绝对值
struct Point{
    double x,y;Point(double X=0,double Y=0){x=X,y=Y;}
    void in(){scanf("%lf%lf",&x,&y);}
    void out(){printf("%.2lf %.2lf\n",x,y);}
};


/*二：【向量】*/
double Dot(Point a,Point b){return a.x*b.x+a.y*b.y;}//【点积】
double Cro(Point a,Point b){return a.x*b.y-a.y*b.x;}//【叉积】
double Len(Point a){return sqrt(Dot(a,a));}//【模长】
double Angle(Point a,Point b){return acos(Dot(a,b)/Len(a)/Len(b));}//【两向量夹角】
Point Normal(Point a){return Point(-a.y,a.x);}//【法向量】
Point operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}
Point operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}
Point operator*(Point a,double b){return Point(a.x*b,a.y*b);}
bool operator==(Point a,Point b){return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);}//两点坐标重合则相等


/*三：【点、向量的位置变换】*/

/*1.【点、向量的旋转】*/
Point turn_P(Point a,double theta){//【点A\向量A顺时针旋转theta(弧度)】
    double x=a.x*cos(theta)+a.y*sin(theta);
    double y=-a.x*sin(theta)+a.y*cos(theta);
    return Point(x,y);
}
Point turn_PP(Point a,Point b,double theta){//【将点A绕点B顺时针旋转theta(弧度)】
    double x=(a.x-b.x)*cos(theta)+(a.y-b.y)*sin(theta)+b.x;
    double y=-(a.x-b.x)*sin(theta)+(a.y-b.y)*cos(theta)+b.y;
    return Point(x,y);
}


/*四：【图形与图形之间的关系】*/

/*1.【点与线段】*/
int pan_PL(Point p,Point a,Point b){//【判断点P是否在线段AB上】
    return !dcmp(Cro(p-a,b-a))&&dcmp(Dot(p-a,p-b))<=0;//做法一
//  return !dcmp(Cro(p-a,b-a))&&dcmp(min(a.x,b.x)-p.x)<=0&&dcmp(p.x-max(a.x,b.x))<=0&&dcmp(min(a.y,b.y)-p.y)<=0&&dcmp(p.y-max(a.y,b.y))<=0;//做法二
    //PA,AB共线且P在AB之间(其实也可以用len(p-a)+len(p-b)==len(a-b)判断，但是精度损失较大)
}
double dis_PL(Point p,Point a,Point b){//【点P到线段AB距离】
    if(a==b)return Len(p-a);//AB重合
    Point x=p-a,y=p-b,z=b-a;
    if(dcmp(Dot(x,z))<0)return Len(x);//P距离A更近
    if(dcmp(Dot(y,z))>0)return Len(y);//P距离B更近
    return Abs(Cro(x,z)/Len(z));//面积除以底边长
}

/*2.【点与直线】*/
int pan_PL_(Point p,Point a,Point b){//【判断点P是否在直线AB上】
    return !dcmp(Cro(p-a,b-a));//PA,AB共线
}
Point FootPoint(Point p,Point a,Point b){//【点P到直线AB的垂足】
    Point x=p-a,y=p-b,z=b-a;
    double len1=Dot(x,z)/Len(z),len2=-1.0*Dot(y,z)/Len(z);//分别计算AP,BP在AB,BA上的投影
    return a+z*(len1/(len1+len2));//点A加上向量AF
}
Point Symmetry_PL(Point p,Point a,Point b){//【点P关于直线AB的对称点】
    return p+(FootPoint(p,a,b)-p)*2;//将PF延长一倍即可
}

/*3.【线与线】*/
Point cross_LL(Point a,Point b,Point c,Point d){//【两直线AB,CD的交点】
    Point x=b-a,y=d-c,z=a-c;
    return a+x*(Cro(y,z)/Cro(x,y));//点A加上向量AF
}
int pan_cross_L_L(Point a,Point b,Point c,Point d){//【判断直线AB与线段CD是否相交】
    return pan_PL(cross_LL(a,b,c,d),c,d);//直线AB与直线CD的交点在线段CD上
}
int pan_cross_LL(Point a,Point b,Point c,Point d){//【判断两线段AB,CD是否相交】
    double c1=Cro(b-a,c-a),c2=Cro(b-a,d-a);
    double d1=Cro(d-c,a-c),d2=Cro(d-c,b-c);
    return dcmp(c1)*dcmp(c2)<0&&dcmp(d1)*dcmp(d2)<0;//分别在两侧
}

/*4.【点与多边形】*/
int PIP(Point *P,int n,Point a){//【射线法】判断点A是否在任意多边形Poly以内
    int cnt=0;double tmp;
    for(int i=1;i<=n;++i){
        int j=i<n?i+1:1;
        if(pan_PL(a,P[i],P[j]))return 2;//点在多边形上
        if(a.y>=min(P[i].y,P[j].y)&&a.y<max(P[i].y,P[j].y))//纵坐标在该线段两端点之间
            tmp=P[i].x+(a.y-P[i].y)/(P[j].y-P[i].y)*(P[j].x-P[i].x),cnt+=dcmp(tmp-a.x)>0;//交点在A右方
    }
    return cnt&1;//穿过奇数次则在多边形以内
}
int judge(Point a,Point L,Point R){//判断AL是否在AR右边
    return dcmp(Cro(L-a,R-a))>0;//必须严格以内
}
int PIP_(Point *P,int n,Point a){//【二分法】判断点A是否在凸多边形Poly以内
    //点按逆时针给出
    if(judge(P[1],a,P[2])||judge(P[1],P[n],a))return 0;//在P[1_2]或P[1_n]外
    if(pan_PL(a,P[1],P[2])||pan_PL(a,P[1],P[n]))return 2;//在P[1_2]或P[1_n]上
    int l=2,r=n-1;
    while(l<r){//二分找到一个位置pos使得P[1]_A在P[1_pos],P[1_(pos+1)]之间
        int mid=l+r+1>>1;
        if(judge(P[1],P[mid],a))l=mid;
        else r=mid-1;
    }
    if(judge(P[l],a,P[l+1]))return 0;//在P[pos_(pos+1)]外
    if(pan_PL(a,P[l],P[l+1]))return 2;//在P[pos_(pos+1)]上
    return 1;
}

/*5.【线与多边形】*/

/*6.【多边形与多边形】*/
int judge_PP(Point *A,int n,Point *B,int m){//【判断多边形A与多边形B是否相离】
    for(int i1=1;i1<=n;++i1){
        int j1=i1<n?i1+1:1;
        for(int i2=1;i2<=m;++i2){
            int j2=i2<m?i2+1:1;
            if(pan_cross_LL(A[i1],A[j1],B[i2],B[j2]))return 0;//两线段相交
            if(PIP(B,m,A[i1])||PIP(A,n,B[i2]))return 0;//点包含在内
        }
    }
    return 1;
}


/*五：【图形面积】*/

/*1.【任意多边形面积】*/
double PolyArea(Point *P,int n){//【任意多边形P的面积】
    double S=0;
    for(int i=1;i<=n;++i)S+=Cro(P[i],P[i<n?i+1:1]);
    return S/2.0;
}

/*2.【圆的面积并】*/

/*3.【三角形面积并】*/


/*六：【凸包】*/

/*1.【求凸包】*/
bool cmp1(Point a,Point b){return a.x==b.x?a.y<b.y:a.x<b.x;};//按坐标排序
int ConvexHull(Point *P,int n,Point *cp){//【水平序Graham扫描法（Andrew算法）】求凸包
    sort(P+1,P+n+1,cmp1);
    int t=0;
    for(int i=1;i<=n;++i){//下凸包
        while(t>1&&dcmp(Cro(cp[t]-cp[t-1],P[i]-cp[t-1]))<=0)--t;
        cp[++t]=P[i];
    }
    int St=t;
    for(int i=n-1;i>=1;--i){//上凸包
        while(t>St&&dcmp(Cro(cp[t]-cp[t-1],P[i]-cp[t-1]))<=0)--t;
        cp[++t]=P[i];
    }
    return --t;//要减一
}
/*2.【旋转卡壳】*/

int sta[N], top;  // 将凸包上的节点编号存在栈里，第一个和最后一个节点编号相同

ll pf(ll x) { return x * x; }

ll dis(int p, int q) { return pf(a[p].x - a[q].x) + pf(a[p].y - a[q].y); }

ll sqr(int p, int q, int y) { return abs((a[q] - a[p]) * (a[y] - a[q])); }

ll mx;

void get_longest() {  // 求凸包直径
  int j = 3;
  if (top < 4) {
    mx = dis(sta[1], sta[2]);
    return;
  }
  for (int i = 1; i < top; ++i) {
    while (sqr(sta[i], sta[i + 1], sta[j]) <=
           sqr(sta[i], sta[i + 1], sta[j % top + 1]))
      j = j % top + 1;
    mx = max(mx, max(dis(sta[i + 1], sta[j]), dis(sta[i], sta[j])));
  }
}

/*3.【半平面交】*/
struct Line{
    Point a,b;double k;Line(Point A=Point(0,0),Point B=Point(0,0)){a=A,b=B,k=atan2(b.y-a.y,b.x-a.x);}
    bool operator<(const Line &O)const{return dcmp(k-O.k)?dcmp(k-O.k)<0:judge(O.a,O.b,a);}//如果角度相等则取左边的
}L[N],Q[N];
Point cross(Line L1,Line L2){return cross_LL(L1.a,L1.b,L2.a,L2.b);}//获取直线L1,L2的交点
int judge(Line L,Point a){return dcmp(Cro(a-L.a,L.b-L.a))>0;}//判断点a是否在直线L的右边
int halfcut(Line *L,int n,Point *P){//【半平面交】
    sort(L+1,L+n+1);int m=n;n=0;
    for(int i=1;i<=m;++i)if(i==1||dcmp(L[i].k-L[i-1].k))L[++n]=L[i];
    int h=1,t=0;
    for(int i=1;i<=n;++i){
        while(h<t&&judge(L[i],cross(Q[t],Q[t-1])))--t;//当队尾两个直线交点不是在直线L[i]上或者左边时就出队
        while(h<t&&judge(L[i],cross(Q[h],Q[h+1])))++h;//当队头两个直线交点不是在直线L[i]上或者左边时就出队
        Q[++t]=L[i];
    }
    while(h<t&&judge(Q[h],cross(Q[t],Q[t-1])))--t;
    while(h<t&&judge(Q[t],cross(Q[h],Q[h+1])))++h;
    n=0;
    for(int i=h;i<=t;++i)P[++n]=cross(Q[i],Q[i<t?i+1:h]);
    return n;
}

/*4.【闵可夫斯基和】*/
Point V1[N],V2[N];
int Mincowski(Point *P1,int n,Point *P2,int m,Point *V){//【闵可夫斯基和】求两个凸包{P1},{P2}的向量集合{V}={P1+P2}构成的凸包
    for(int i=1;i<=n;++i)V1[i]=P1[i<n?i+1:1]-P1[i];
    for(int i=1;i<=m;++i)V2[i]=P2[i<m?i+1:1]-P2[i];
    int t=0,i=1,j=1;V[++t]=P1[1]+P2[1];
    while(i<=n&&j<=m)++t,V[t]=V[t-1]+(dcmp(Cro(V1[i],V2[j]))>0?V1[i++]:V2[j++]);
    while(i<=n)++t,V[t]=V[t-1]+V1[i++];
    while(j<=m)++t,V[t]=V[t-1]+V2[j++];
    return t;
}

/*5.【动态凸包】*/

/*七：【圆】*/

/*1.【三点确定一圆】*/
#define S(a) ((a)*(a))
struct Circle{Point O;double r;Circle(Point P,double R=0){O=P,r=R;}};
Circle getCircle(Point A,Point B,Point C){//【三点确定一圆】暴力解方程
    double x1=A.x,y1=A.y,x2=B.x,y2=B.y,x3=C.x,y3=C.y;
    double D=((S(x2)+S(y2)-S(x3)-S(y3))*(y1-y2)-(S(x1)+S(y1)-S(x2)-S(y2))*(y2-y3))/((x1-x2)*(y2-y3)-(x2-x3)*(y1-y2));
    double E=(S(x1)+S(y1)-S(x2)-S(y2)+D*(x1-x2))/(y2-y1);
    double F=-(S(x1)+S(y1)+D*x1+E*y1);
    return Circle(Point(-D/2.0,-E/2.0),sqrt((S(D)+S(E)-4.0*F)/4.0));
}
Circle getcircle(Point A,Point B,Point C){//【三点确定一圆】向量垂心法
    Point P1=(A+B)*0.5,P2=(A+C)*0.5;
    Point O=cross_LL(P1,P1+Normal(B-A),P2,P2+Normal(C-A));
    return Circle(O,Len(A-O));
}

/*2.【最小覆盖圆】*/
int PIC(Circle C,Point a){return dcmp(Len(a-C.O)-C.r)<=0;}//判断点A是否在圆C内
void Random(Point *P,int n){for(int i=1;i<=n;++i)swap(P[i],P[rand()%n+1]);}//随机一个排列
Circle Min_Circle(Point *P,int n){//【求点集P的最小覆盖圆】
//  random_shuffle(P+1,P+n+1);
    Random(P,n);Circle C=Circle(P[1],0);
    for(int i=2;i<=n;++i)if(!PIC(C,P[i])){
        C=Circle(P[i],0);
        for(int j=1;j<i;++j)if(!PIC(C,P[j])){
            C.O=(P[i]+P[j])*0.5,C.r=Len(P[j]-C.O);
            for(int k=1;k<j;++k)if(!PIC(C,P[k]))C=getcircle(P[i],P[j],P[k]);
        }
    }
    return C;
}

/*3.【三角剖分】*/
double calc(Point A,Point B,Point O,double R){//【三角剖分】
    if(A==O||B==O)return 0;
    int op=dcmp(Cro(A-O,B-O))>0?1:-1;double ans=0;
    Point x=A-O,y=B-O;
    int flag1=dcmp(Len(x)-R)>0,flag2=dcmp(Len(y)-R)>0;
    if(!flag1&&!flag2)ans=Abs(Cro(A-O,B-O))/2.0;//两个点都在里面
    else if(flag1&&flag2){//两个点都在外面
        if(dcmp(dis_PL(O,A,B)-R)>=0)ans=R*R*Angle(x,y)/2.0;//完全包含了圆弧
        else{//分三段处理 △+圆弧+△
            if(dcmp(Cro(A-O,B-O))>0)swap(A,B);//把A换到左边
            Point F=FootPoint(O,A,B);double lenx=Len(F-O),len=sqrt(R*R-lenx*lenx);
            Point z=turn_P(F-O,Pi/2.0)*(len/lenx);Point B_=F+z,A_=F-z;
            ans=R*R*(Angle(A-O,A_-O)+Angle(B-O,B_-O))/2.0+Cro(B_-O,A_-O)/2.0;
        }
    }
    else{//一个点在里面，一个点在外面
        if(flag1)swap(A,B);//使A为里面的点，B为外面的点
        Point F=FootPoint(O,A,B);double lenx=Len(F-O),len=sqrt(R*R-lenx*lenx);
        Point z=turn_P(F-O,Pi/2.0)*(len/lenx);Point C=dcmp(Cro(A-O,B-O))>0?F-z:F+z;
        ans=Abs(Cro(A-O,C-O))/2.0+R*R*Angle(C-O,B-O)/2.0;
    }
    return ans*op;
}
```

