# æ¿å­

## å¥‡æŠ€æ·«å·§

### æµ®ç‚¹æ•°ç²¾åº¦æ§åˆ¶

```cpp
double roundPrecision(double value, int decimalPlaces) {
    if (decimalPlaces < 0) return value;
    
    double factor = std::pow(10.0, decimalPlaces);
    return std::round(value * factor) / factor;
}
```

### å¿«é€Ÿå¹‚æ‰‹å†™powå‡½æ•°

```cpp
long long fastPower(long long base, int exponent) {
    // å¤„ç†ç‰¹æ®Šæƒ…å†µ
    if (exponent < 0) {
        throw std::invalid_argument("Exponent must be non-negative");
    }
    
    if (exponent == 0) {
        return 1; // ä»»ä½•æ•°çš„0æ¬¡æ–¹éƒ½æ˜¯1
    }
    
    long long result = 1;
    long long current = base;
    int exp = exponent;
    
    // å¿«é€Ÿå¹‚ç®—æ³•æ ¸å¿ƒ
    while (exp > 0) {
        // å¦‚æœå½“å‰æŒ‡æ•°ä½æ˜¯å¥‡æ•°ï¼Œå°†å½“å‰åº•æ•°ä¹˜å…¥ç»“æœ
        if (exp & 1) {
            result *= current;
        }
        
        // åº•æ•°å¹³æ–¹
        current *= current;
        
        // æŒ‡æ•°å³ç§»ä¸€ä½ï¼ˆç›¸å½“äºé™¤ä»¥2ï¼‰
        exp >>= 1;
    }
    
    return result;
}

// å¸¦æ¨¡è¿ç®—çš„å¿«é€Ÿå¹‚ç‰ˆæœ¬ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
long long fastPowerMod(long long base, int exponent, long long mod) {
    if (exponent < 0) {
        throw std::invalid_argument("Exponent must be non-negative");
    }
    
    if (mod == 0) {
        throw std::invalid_argument("Modulus cannot be zero");
    }
    
    if (exponent == 0) {
        return 1 % mod;
    }
    
    base %= mod; // å…ˆå–æ¨¡é˜²æ­¢æº¢å‡º
    long long result = 1;
    
    while (exponent > 0) {
        if (exponent & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exponent >>= 1;
    }
    
    return result;
}
```

C++è‡ªå¸¦çš„powå‡½æ•°è¿”å›doubleå®åœ¨æ˜¯å°ä¼—ä¸”å˜æ€ï¼Œé‡æ–°å†™ä¸€ä¸ªè¿”å›long longçš„powå‡½æ•°éå¸¸æœ‰å¿…è¦ã€‚

### é«˜ç²¾åº¦åŠ å‡ä¹˜é™¤

```cpp
//åŠ æ³•
string addition(string a,string b){
    while(a.size()<b.size()){
        a='0'+a;
    }
    while(b.size()<a.size()){
        b='0'+b;
    }//è¿™é‡Œæˆ‘å‰é¢æåˆ°è¿‡äº†ï¼Œæ˜¯ä¸ºäº†æ–¹ä¾¿åé¢çš„ä¸»ç¨‹åºåšçš„é¢„å¤„ç†ã€‚
    int n=a.size();
    string ans1,ans;//ans1æ˜¯åˆæ­¥ç»“æœï¼Œansæ˜¯è¿”å›ç»“æœï¼Œè¿™ä¸ªå˜é‡åèµ·çš„æœ‰ç‚¹å˜æ€ã€‚
    int t=0;//tæ˜¯ä¸Šä¸€æ¬¡å‰©ä¸‹çš„æº¢å‡ºæ•°
    for (int i=n-1;i>=0;i--){//æœ€åä¸€ä½æ‰æ˜¯ä¸ªä½
        int x=a[i]-'0';
        int y=b[i]-'0';//è½¬åŒ–ä¸ºintç±»å‹ï¼Œæ³¨æ„ä¸èƒ½ç”¨stoi
        char c=(x+y+t)%10+'0';
        t=(x+y+t)/10;//è®¡ç®—æº¢å‡ºçš„æ•°å­—
        ans1=c+ans1;//åŠ å…¥ç­”æ¡ˆ
    }
    if (t!=0){
        ans1=char('0'+t)+ans1;//å¾ªç¯ç»“æŸä¹‹åæŠŠæº¢å‡ºæ•°åŠ ä¸Šå»
    }
    bool flag=0;//å»å‰å¯¼0é€»è¾‘
    for (int i=0;i<ans1.size();i++){
        if (flag){
            ans+=ans1[i];
        }else if(!flag&&ans1[i]!='0'){//é‡åˆ°ç¬¬ä¸€ä¸ªé0æ•°å­—ï¼Œç«‹åˆ»ç»“æŸå»0
            ans+=ans1[i];
            flag=1;
        }
    }
    return ans;
}

//å‡æ³•
string subtraction(string a,string b){
    string res,ans;
    bool flag=0;
    if (!cmp(a,b)){
        swap(a,b);
        flag=1;//æ§åˆ¶æ­£è´Ÿ
    }
    while (b.size()<a.size()){
        b='0'+b;
    }
    int n=a.size();
    int p=0;
    for (int i=n-1;i>=0;i--){
        int x=(a[i]-'0')-p;
        int y=(b[i]-'0');
        if (x>=y){
            int temp=(x-y);
            res+=(char)('0'+temp);
            p=0;
        }else{
            int temp=(10+x-y);
            res+=(char)('0'+temp);
            p=1;
        }
    }
    reverse(res.begin(),res.end());
    int pos=0;
    while (pos<res.size()&&res[pos]=='0'){
        pos++;
    }//æ–°çš„å»0é€»è¾‘ã€‚
    if (pos==res.size()) return "0";
    else{
        ans=res.substr(pos);
        if (flag) ans='-'+ans;
    }
    return ans;
}

//é™¤æ³•
string div(string a, int b, int &r){
    r = 0;                  // å½“å‰ä½™æ•°
    string res;

    for (int i = 0; i < a.size(); i++){
        r = r * 10 + (a[i] - '0');  // åŠ å…¥å½“å‰ä½
        res += char(r / b + '0');   // å•†çš„å½“å‰ä½
        r %= b;                     // æ›´æ–°ä½™æ•°
    }

    // å»æ‰å‰å¯¼é›¶
    int i = 0;
    while (i + 1 < res.size() && res[i] == '0') i++;
    return res.substr(i);
}

//ä¹˜æ³•
string mul(string a, string b){
    // å»æ‰å‰å¯¼é›¶
    while (a.size() > 1 && a[0] == '0') a.erase(a.begin());
    while (b.size() > 1 && b[0] == '0') b.erase(b.begin());
    if (a == "0" || b == "0") return "0";

    int n = a.size(), m = b.size();
    vector<int> c(n + m, 0);

    // ä»æœ€ä½ä½å¼€å§‹ä¹˜ï¼ˆå€’ç€ï¼‰
    for (int i = n - 1; i >= 0; i--) {
        for (int j = m - 1; j >= 0; j--) {
            int x = (a[i] - '0') * (b[j] - '0');
            int p = i + j + 1;
            int q = i + j;
            c[p] += x;
            c[q] += c[p] / 10;
            c[p] %= 10;
        }
    }

    // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    string res;
    int i = 0;
    while (i < c.size() && c[i] == 0) i++; // å»æ‰å‰å¯¼é›¶
    for (; i < c.size(); i++) res += char(c[i] + '0');

    return res == "" ? "0" : res;
}
```

### çº¿æ€§ç­›ç´ æ•°

```cpp
const int N = 1e8 + 10;
int cnt,p[N],tot,n,q;
bool vis[N];

void euler() {
    for (int i = 2;i <= n;++i) {
        if (!vis[i]) p[++tot] = i;
        for (int j = 1;j <= tot && i * p[j] <= n;++j) {
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
}
```

### å®Œå…¨å¹³æ–¹æ•°åˆ¤æ–­ï¼ˆåŸºäºäºŒåˆ†ï¼‰

```cpp
class Solution {
public:
    bool isPerfectSquare(int x) {
        if (x < 0) return false;
        if (x < 2) return true;     // 0 å’Œ 1 ç›´æ¥è¿”å› true

        int l = 1, r = x / 2;       // æ ¹å· x ä¸å¯èƒ½è¶…è¿‡ x/2ï¼ˆxâ‰¥2ï¼‰
        while (l <= r) {
            int mid = l + (r - l) / 2;
            long long sq = 1LL * mid * mid;

            if (sq == x) return true;
            if (sq < x) l = mid + 1;
            else r = mid - 1;
        }
        return false;
    }
};
```

### ç®—æ•°å¹³æ–¹æ ¹æŸ¥æ‰¾ï¼ˆåŸºäºäºŒåˆ†ï¼‰

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int l=1,r=x;
        int ans=0;
        while (l<=r){
            int mid=l+(r-l)/2;
            if ((long long)mid*mid<=x){
                ans=mid;
                l=mid+1;
            }else{
                r=mid-1;
            }
        }
        return ans;
    }
};
```

### ç´ æ•°åˆ¤æ–­

```cpp
bool isprime(int x){
    if (x<=1) return false;
    if (x==2) return true;
    for (int i=2;i*i<=x;i++){
        if (x%i==0){
            return false;
        }
    }
    return true;
}
```

### è¿›åˆ¶è½¬æ¢

```cpp
string toBase(long long n, int d) {
    if (n == 0) return "0";
    const string DIG = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    string s;
    while (n > 0) {
        s.push_back(DIG[n % d]);
        n /= d;
    }
    reverse(s.begin(), s.end());
    return s;
}
```

### å›æ–‡æ•°åˆ¤æ–­

```cpp
bool isback_num(string a){
    string b;
    int n=a.size();
    for (int i=n-1;i>=0;i--){
        b+=a[i];
    }
    if (a==b){
        return true;
    }else{
        return false;
    }
}
```

### ä¹å®«æ ¼æ•°ç‹¬åˆç†åˆ¤æ–­

```cpp
bool is(vector<vector<int>> &sq){
    for (int i=0;i<9;i++){
        set<int> s;
        for (int j=0;j<9;j++){
            if (sq[i][j]<1||sq[i][j]>9){
                return false;
            }
            s.insert(sq[i][j]);
        }
        if (s.size()!=9){
            return false;
        }
    }
    for (int i=0;i<9;i++){
        set<int> s;
        for (int j=0;j<9;j++){
            if (sq[j][i]<1||sq[j][i]>9){
                return false;
            }
            s.insert(sq[j][i]);
        }
        if (s.size()!=9){
            return false;
        }
    }
    int top=0,bottom=3;
    while (top<9){
        int left=0,right=3;
        while (left<9){
            set<int> s;
            for (int i=top;i<bottom;i++){
                for (int j=left;j<right;j++){
                    s.insert(sq[i][j]);
                }
            }
            if (s.size()!=9){
                return false;
            }
            left+=3;
            right+=3;
        }
        top+=3;
        bottom+=3;
    }
    return true;
}
```

### è¡Œåˆ—å¯¹è§’çº¿Nçš‡ååˆ¤æ–­

```cpp
bool is(vector<vector<int>> &sq){
    for (int i=0;i<9;i++){
        set<int> s;
        for (int j=0;j<9;j++){
            if (sq[i][j]<1||sq[i][j]>9){
                return false;
            }
            s.insert(sq[i][j]);
        }
        if (s.size()!=9){
            return false;
        }
    }
    for (int i=0;i<9;i++){
        set<int> s;
        for (int j=0;j<9;j++){
            if (sq[j][i]<1||sq[j][i]>9){
                return false;
            }
            s.insert(sq[j][i]);
        }
        if (s.size()!=9){
            return false;
        }
    }
    int top=0,bottom=3;
    while (top<9){
        int left=0,right=3;
        while (left<9){
            set<int> s;
            for (int i=top;i<bottom;i++){
                for (int j=left;j<right;j++){
                    s.insert(sq[i][j]);
                }
            }
            if (s.size()!=9){
                return false;
            }
            left+=3;
            right+=3;
        }
        top+=3;
        bottom+=3;
    }
    return true;
}
```

### èºæ—‹çŸ©é˜µ

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int main(){
    cin>>n;
    vector<int> a(n);
    for (int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a.begin(),a.end(),greater<int>());
    int x=1,y=n,j,minn=10000;
    for (int i=1;i*i<=n;i++){
        if (n%i==0){
            j=n/i;
            if (j-i<minn){
                x=i;
                y=j;
                minn=j-i;
            }
        }
    }
    int left=0,right=x-1,topp=0,bottom=y-1;
    int cur=0;
    vector<vector<int>> ans(y,vector<int>(x));
    while (topp<=bottom&&left<=right){
        for (int i=left;i<=right;i++){
            ans[topp][i]=a[cur];
            cur++;
        }
        ++topp;
        for (int i=topp;i<=bottom;i++){
            ans[i][right]=a[cur];
            cur++;
        }
        --right;
        if (topp<=bottom){
            for (int i=right;i>=left;i--){
                ans[bottom][i]=a[cur];
                cur++;
            }
            --bottom;
        }
        if (left<=right){
            for (int i=bottom;i>=topp;i--){
                ans[i][left]=a[cur];
                cur++;
            }
            left++;
        }
    }
    for (int i=0;i<y;i++){
        for (int j=0;j<x;j++){
            if (j==x-1){
                cout<<ans[i][j];
            }else{
                cout<<ans[i][j]<<" ";
            }
        }
        cout<<endl;
    }
    return 0;
}
```

### ç¦»æ•£åŒ–

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[102],b[102];
int main(){
	cin>>n;
	for (int i=1;i<=n;i++)  cin>>a[i];
	for (int i=1;i<=n;i++)  b[i]=a[i];
	sort(b+1,b+n+1);
	int cur=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++) 
		a[i]=lower_bound(b+1,b+cur+1,a[i])-b;
	for (int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
}
```

> å¥½çš„ï¼ä½ è´´çš„è¿™ä¸ªä»£ç æ˜¯ **å…¸å‹çš„ä¸€ç»´ç¦»æ•£åŒ–æ¨¡æ¿**ï¼Œæˆ‘æ¥å¸®ä½ **é€è¡Œè§£é‡Š**ï¼Œä¿è¯ä½ èƒ½å½»åº•ç†è§£æ¯ä¸€è¡Œçš„ä½œç”¨å’ŒèƒŒåçš„åŸç†ã€‚
>
> ------
>
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> ```
>
> - å¼•å…¥äº† C++ æ‰€æœ‰å¸¸ç”¨å¤´æ–‡ä»¶ã€‚
> - ä½¿ç”¨ `std` å‘½åç©ºé—´ï¼Œæ–¹ä¾¿ç›´æ¥ç”¨ `cin`ã€`cout`ã€`sort`ã€`unique` ç­‰ã€‚
>
> ------
>
> ```cpp
> int n;
> int a[102], b[102];
> ```
>
> - `n`ï¼šè¡¨ç¤ºæ•°ç»„é•¿åº¦ã€‚
> - `a[102]`ï¼šåŸå§‹æ•°ç»„ï¼Œç”¨æ¥å­˜è¾“å…¥çš„æ•°æ®ã€‚
> - `b[102]`ï¼šè¾…åŠ©æ•°ç»„ï¼Œç”¨æ¥å­˜ä¸€ä»½ **åŸæ•°ç»„çš„å‰¯æœ¬**ï¼Œç”¨äºç¦»æ•£åŒ–æ“ä½œï¼ˆæ’åºã€å»é‡ï¼‰ã€‚
>
> ------
>
> ```cpp
> cin >> n;
> for (int i = 1; i <= n; i++) cin >> a[i];
> ```
>
> - è¾“å…¥æ•°ç»„é•¿åº¦ nã€‚
> - è¯»å…¥æ•°ç»„ aï¼Œ**ä¸‹æ ‡ä» 1 å¼€å§‹**ï¼ˆå¾ˆå¤š OI æ¨¡æ¿ä¹ æƒ¯ä» 1 å¼€ï¼‰ã€‚
>
> ------
>
> ```cpp
> for (int i = 1; i <= n; i++) b[i] = a[i];
> ```
>
> - æŠŠåŸæ•°ç»„ a æ‹·è´åˆ° bã€‚
> - ä¸ºä»€ä¹ˆè¦æ‹·è´ï¼Ÿå› ä¸º b ä¼šè¢« **æ’åºå»é‡**ï¼Œè€Œ a ä»ç„¶ä¿æŒåŸæ¥çš„é¡ºåºï¼Œç”¨äºæœ€åæ˜ å°„ä¸‹æ ‡ã€‚
>
> ------
>
> ```cpp
> sort(b + 1, b + n + 1);
> ```
>
> - å¯¹ b è¿›è¡Œæ’åºã€‚
> - æ’åºåï¼Œæ•°ç»„ b ä¸­å…ƒç´ æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—ã€‚
> - ç¦»æ•£åŒ–çš„ç›®çš„æ˜¯æ ¹æ®å¤§å°æ’åºç»™æ¯ä¸ªæ•°ä¸€ä¸ªâ€œæ’åâ€ï¼Œæ‰€ä»¥å…ˆæ’åºã€‚
>
> ------
>
> ```cpp
> int cur = unique(b + 1, b + n + 1) - b - 1;
> ```
>
> - `unique` ç”¨äº **å»é‡ç›¸é‚»é‡å¤å…ƒç´ **ï¼Œè¿”å›æ–°æ•°ç»„æœ«å°¾çš„è¿­ä»£å™¨ã€‚
> - `b + 1` åˆ° `b + n + 1` æ˜¯è¦å¤„ç†çš„åŒºé—´ï¼ˆå› ä¸ºä¸‹æ ‡ä» 1 å¼€ï¼‰ã€‚
> - `unique(b+1,b+n+1)-b-1`ï¼š
>   1. `unique(b+1,b+n+1)` è¿”å›å»é‡åæœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªä½ç½®çš„æŒ‡é’ˆã€‚
>   2. å‡å» `b` â†’ å¾—åˆ°ç¦» b èµ·å§‹ä½ç½®çš„åç§»é‡ã€‚
>   3. å†å‡ 1 â†’ å¾—åˆ°**ç¦»æ•£åŒ–åæ•°ç»„çš„é•¿åº¦ cur**ã€‚
> - ç»“æœï¼š`b[1..cur]` æ˜¯ **æ’åºä¸”å»é‡åçš„æ•°ç»„**ã€‚
>
> ------
>
> ```cpp
> for (int i = 1; i <= n; i++) 
>     a[i] = lower_bound(b + 1, b + cur + 1, a[i]) - b;
> ```
>
> - å¯¹åŸæ•°ç»„ a è¿›è¡Œç¦»æ•£åŒ–æ˜ å°„ï¼š
>   1. `lower_bound(b+1, b+cur+1, a[i])` æ‰¾åˆ° **a[i] åœ¨ b ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®**ã€‚
>   2. å‡å» `b` â†’ å¾—åˆ°æ•´æ•°ä¸‹æ ‡ã€‚
> - ç»“æœï¼š`a[i]` è¢«æ˜ å°„ä¸º **å°çš„è¿ç»­æ•´æ•°**ï¼Œå³ç¦»æ•£åŒ–åçš„å€¼ã€‚
> - **æ³¨æ„**ï¼šè¿™é‡Œæ˜ å°„ä» 1 å¼€å§‹ï¼ˆå› ä¸º b ä¸‹æ ‡ä» 1 å¼€ï¼‰ã€‚
>
> ------
>
> ```cpp
> for (int i = 1; i <= n; i++) cout << a[i] << " ";
> ```
>
> - è¾“å‡ºç¦»æ•£åŒ–åçš„æ•°ç»„ aã€‚
> - ç©ºæ ¼åˆ†éš”ã€‚
>
> ------
>
> ```cpp
> return 0;
> ```
>
> - ç»“æŸç¨‹åºã€‚
>
> ------
>
> # ğŸ“ **æ€»ç»“è¿™ä¸ªç¦»æ•£åŒ–æ¨¡æ¿åšäº†ä»€ä¹ˆ**
>
> 1. æ‹·è´åŸæ•°ç»„ â†’ b
> 2. å¯¹ b æ’åº â†’ å¾—åˆ°æ•°å€¼ä»å°åˆ°å¤§çš„é¡ºåº
> 3. å»é‡ â†’ å¾—åˆ°è¿ç»­ä¸”å”¯ä¸€çš„å€¼
> 4. åŸæ•°ç»„æ¯ä¸ªå…ƒç´  â†’ åœ¨ b ä¸­æ‰¾æ’å â†’ æ˜ å°„æˆè¿ç»­æ•´æ•°
> 5. è¾“å‡ºæ˜ å°„ç»“æœ
>
> ------
>
> # âš¡ **å…³é”®ç‚¹å’Œæ˜“é”™ç‚¹**
>
> - `sort + unique` æ˜¯å»é‡å¿…å¤‡ç»„åˆã€‚
> - `lower_bound` ç”¨æ¥æ‰¾åˆ° **å…ƒç´ åœ¨æ’åºæ•°ç»„ä¸­çš„æ’å**ã€‚
> - æ³¨æ„ **ä¸‹æ ‡ä» 1 å¼€å§‹**ï¼Œæ‰€ä»¥ `- b` å¾—åˆ°åç§»æ—¶ä¸ç”¨å†å‡ 1ã€‚
> - å¦‚æœæ•°ç»„å¾ˆå¤§ï¼Œè®°å¾—ç”¨ `vector` æˆ– `long long`ï¼Œä¸è¦å†™å›ºå®šé•¿åº¦æ•°ç»„ã€‚
> - æ˜ å°„åçš„æ•°å€¼ **å¯ä»¥ç›´æ¥ä½œä¸ºæ ‘çŠ¶æ•°ç»„/çº¿æ®µæ ‘çš„ä¸‹æ ‡ä½¿ç”¨**ã€‚
>
> ------
>
> å¦‚æœä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥å¸®ä½ ç”»ä¸€ä¸ª **å›¾ç¤ºæ¼”ç¤ºç¦»æ•£åŒ–è¿‡ç¨‹**ï¼ŒæŠŠåŸæ•°ç»„ â†’ æ’åºå»é‡ â†’ lower_bound â†’ ç¦»æ•£åŒ–ä¸‹æ ‡ï¼Œè§†è§‰åŒ–ä¸€ä¸‹ï¼Œä¼šç‰¹åˆ«ç›´è§‚ã€‚
>
> ä½ æƒ³è®©æˆ‘ç”»å—ï¼Ÿ

### å››èˆäº”å…¥

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace Round {

// --------------------
// æµ®ç‚¹æ•°å››èˆäº”å…¥åˆ°æ•´æ•°
// --------------------
inline long long roundToInt(double x) {
    return x >= 0 ? (long long)(x + 0.5) : (long long)(x - 0.5);
}

// --------------------
// æµ®ç‚¹æ•°ä¿ç•™ n ä½å°æ•°
// --------------------
inline double roundN(double x, int n) {
    double factor = pow(10.0, n);
    return (x >= 0 ? floor(x * factor + 0.5) : floor(x * factor - 0.5)) / factor;
}

// --------------------
// æ•´æ•°é™¤æ³•å››èˆäº”å…¥
// --------------------
// a/b å››èˆäº”å…¥ï¼Œæ­£è´Ÿæ•°å‡å¯
inline long long divRound(long long a, long long b) {
    if (b == 0) throw runtime_error("division by zero");
    // åŒå·
    if ((a >= 0 && b > 0) || (a <= 0 && b < 0))
        return (a + b/2) / b;
    else
        return (a - b/2) / b;
}

} // namespace Round

// --------------------
// ä½¿ç”¨ç¤ºä¾‹
// --------------------
int main() {
    double x;
    cin >> x;
    cout << "å››èˆäº”å…¥åˆ°æ•´æ•°: " << Round::roundToInt(x) << "\n";

    int n;
    cin >> n;
    cout << "ä¿ç•™ " << n << " ä½å°æ•°: " << fixed << setprecision(n) << Round::roundN(x,n) << "\n";

    long long a,b;
    cin >> a >> b;
    cout << "æ•´æ•°é™¤æ³•å››èˆäº”å…¥: " << Round::divRound(a,b) << "\n";

    return 0;
}
```

### è®°å¿†åŒ–æœç´¢é˜¶ä¹˜

```cpp
#include <bits/stdc++.h>
using namespace std;

// ç”¨ unordered_map ç¼“å­˜ç»“æœ
unordered_map<long long, long long> memo;

// è®°å¿†åŒ–é€’å½’æ±‚é˜¶ä¹˜
long long factorial(int n){
    if(n == 0 || n == 1) return 1; // é˜¶ä¹˜åŸºå‡†
    if(memo.count(n)) return memo[n]; // å¦‚æœå·²ç»è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›

    memo[n] = n * factorial(n-1); // é€’å½’ + è®°å¿†åŒ–
    return memo[n];
}

int main(){
    int n;
    cin >> n;
    cout << factorial(n) << endl;
    return 0;
}
```

### ç»„åˆæ•°ä¸æ’åˆ—æ•°

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long MOD = 1e9+7;

// ----------------------------
// å…¨å±€æ•°ç»„è¯´æ˜ï¼š
// fac[i] : ä¿å­˜ i! % MOD
// inv[i] : ä¿å­˜ i! çš„é€†å…ƒ % MODï¼Œç”¨äºå¿«é€Ÿè®¡ç®—ç»„åˆæ•°
// ----------------------------
const int N = 1e6+5;
long long fac[N], inv[N];

// ----------------------------
// å¿«é€Ÿå¹‚å‡½æ•°
// ç”¨äºæ±‚ a^b % MOD
// ----------------------------
long long qpow(long long a, long long b) {
    long long res = 1;
    while(b) {
        if(b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// ----------------------------
// é˜¶ä¹˜å’Œé€†å…ƒé¢„å¤„ç†
// fac[i] = i! % MOD
// inv[i] = (i!)^-1 % MODï¼Œç”¨äºè®¡ç®—ç»„åˆæ•° C(n,k)
// ----------------------------
void init(int n) {
    fac[0] = 1;
    for(int i = 1; i <= n; i++) fac[i] = fac[i-1] * i % MOD;
    inv[n] = qpow(fac[n], MOD-2); // æ ¹æ®è´¹é©¬å°å®šç†æ±‚é€†å…ƒ
    for(int i = n-1; i >= 0; i--) inv[i] = inv[i+1] * (i+1) % MOD;
}

// ----------------------------
// ç»„åˆæ•° C(n, k)
// åˆ©ç”¨å…¬å¼ C(n,k) = n! / (k! * (n-k)!)
// fac ä¸ inv å·²ç»é¢„å¤„ç†è¿‡
// ----------------------------
long long C(int n, int k){
    if(k < 0 || k > n) return 0;
    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;
}

// ----------------------------
// æ’åˆ—æ•° P(n, k)
// åˆ©ç”¨å…¬å¼ P(n,k) = n! / (n-k)!
// fac ä¸ inv å·²ç»é¢„å¤„ç†è¿‡
// ----------------------------
long long P(int n, int k){
    if(k < 0 || k > n) return 0;
    return fac[n] * inv[n-k] % MOD;
}

int main(){
    int n, k;
    cin >> n >> k;
    init(n); // é¢„å¤„ç†é˜¶ä¹˜å’Œé€†å…ƒ
    cout << "C(" << n << "," << k << ") = " << C(n,k) << endl;
    cout << "P(" << n << "," << k << ") = " << P(n,k) << endl;
    return 0;
}
```

### æ±‚å¯¹æ•°

```cpp
#include <bits/stdc++.h>
using namespace std;

// ----------------------------
// åŠŸèƒ½ï¼šè®¡ç®—ä»¥ base ä¸ºåº•çš„å¯¹æ•° log_base(x)
// å‚æ•°ï¼šx > 0, base > 0 ä¸” base != 1
// è¿”å›ï¼šdouble ç±»å‹
// ----------------------------
double log_base(double x, double base){
    if(x <= 0 || base <= 0 || base == 1){
        cerr << "Invalid input for logarithm" << endl;
        return NAN; // éæ³•è¾“å…¥è¿”å› NaN
    }
    return log(x) / log(base); // åˆ©ç”¨è‡ªç„¶å¯¹æ•°æ¢åº•å…¬å¼
}

int main(){
    double x, base;
    cin >> x >> base;
    double ans = log_base(x, base);
    cout << fixed << setprecision(6) << ans << endl;
    return 0;
}

```

### æ±‚ä¸‰è§’å‡½æ•°

```cpp
#include <bits/stdc++.h>
using namespace std;

// ----------------------------
// å¸¸ç”¨ä¸‰è§’å‡½æ•°
// ----------------------------
double deg2rad(double deg){ return deg * M_PI / 180.0; } // è§’åº¦ â†’ å¼§åº¦
double rad2deg(double rad){ return rad * 180.0 / M_PI; } // å¼§åº¦ â†’ è§’åº¦

int main(){
    double angle_deg = 30;       // è§’åº¦
    double angle_rad = deg2rad(angle_deg); // è½¬ä¸ºå¼§åº¦

    // è®¡ç®—ä¸‰è§’å‡½æ•°å€¼
    double s = sin(angle_rad);   // æ­£å¼¦
    double c = cos(angle_rad);   // ä½™å¼¦
    double t = tan(angle_rad);   // æ­£åˆ‡

    // åä¸‰è§’å‡½æ•°ï¼ˆç»“æœä¸ºå¼§åº¦ï¼‰
    double asin_val = asin(s);   // åæ­£å¼¦
    double acos_val = acos(c);   // åä½™å¼¦
    double atan_val = atan(t);   // åæ­£åˆ‡

    cout << fixed << setprecision(6);
    cout << "sin(" << angle_deg << ") = " << s << endl;
    cout << "cos(" << angle_deg << ") = " << c << endl;
    cout << "tan(" << angle_deg << ") = " << t << endl;
    cout << "asin(sin) = " << rad2deg(asin_val) << " degrees" << endl;
    cout << "acos(cos) = " << rad2deg(acos_val) << " degrees" << endl;
    cout << "atan(tan) = " << rad2deg(atan_val) << " degrees" << endl;

    return 0;
}
```

## æ’åºåŸç†

### å†’æ³¡æ’åº

```cpp
#include <bits/stdc++.h>
using namespace std;

void bubble_sort(vector<int>& a){
    int n = a.size();
    for(int i = 0; i < n-1; i++){
        for(int j = 0; j < n-1-i; j++){
            if(a[j] > a[j+1]) swap(a[j], a[j+1]);
        }
    }
}

int main(){
    vector<int> a = {5,2,9,1,5,6};
    bubble_sort(a);
    for(int x : a) cout << x << " ";
}

```

### æ’å…¥æ’åº

```cpp
void insertion_sort(vector<int>& a){
    int n = a.size();
    for(int i = 1; i < n; i++){
        int key = a[i], j = i - 1;
        while(j >= 0 && a[j] > key){
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = key;
    }
}
```

### é€‰æ‹©æ’åº

```cpp
void selection_sort(vector<int>& a){
    int n = a.size();
    for(int i = 0; i < n-1; i++){
        int min_idx = i;
        for(int j = i+1; j < n; j++)
            if(a[j] < a[min_idx]) min_idx = j;
        swap(a[i], a[min_idx]);
    }
}
```

### å¿«é€Ÿæ’åº

```cpp
void quick_sort(vector<int>& a, int l, int r){
    if(l >= r) return;
    int pivot = a[r], i = l;
    for(int j = l; j < r; j++){
        if(a[j] < pivot) swap(a[i++], a[j]);
    }
    swap(a[i], a[r]);
    quick_sort(a, l, i-1);
    quick_sort(a, i+1, r);
}

```

### å½’å¹¶æ’åº

```cpp
void merge(vector<int>& a, int l, int m, int r){
    vector<int> tmp(r-l+1);
    int i=l, j=m+1, k=0;
    while(i<=m && j<=r){
        if(a[i]<=a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while(i<=m) tmp[k++] = a[i++];
    while(j<=r) tmp[k++] = a[j++];
    for(int t=0; t<tmp.size(); t++) a[l+t] = tmp[t];
}

void merge_sort(vector<int>& a, int l, int r){
    if(l>=r) return;
    int m = l + (r-l)/2;
    merge_sort(a, l, m);
    merge_sort(a, m+1, r);
    merge(a, l, m, r);
}
```

| æ’åºç®—æ³•                | æ ¸å¿ƒåŸç†                                                    | ç¨³å®šæ€§ | ç©ºé—´å¤æ‚åº¦      | æ—¶é—´å¤æ‚åº¦      |
| ----------------------- | ----------------------------------------------------------- | ------ | --------------- | --------------- |
| å†’æ³¡æ’åº Bubble Sort    | ç›¸é‚»å…ƒç´ ä¸¤ä¸¤æ¯”è¾ƒï¼ŒæŠŠå¤§/å°çš„â€œå†’æ³¡â€åˆ°æ•°ç»„æœ«ç«¯                 | ç¨³å®š   | O(1)            | O(nÂ²)           |
| æ’å…¥æ’åº Insertion Sort | å°†å½“å‰å…ƒç´ æ’å…¥åˆ°å·²æ’åºçš„å­æ•°ç»„ä¸­                            | ç¨³å®š   | O(1)            | O(nÂ²)           |
| é€‰æ‹©æ’åº Selection Sort | æ¯æ¬¡é€‰æ‹©æœªæ’åºéƒ¨åˆ†çš„æœ€å°/æœ€å¤§å€¼æ”¾åˆ°å‰é¢                     | ä¸ç¨³å®š | O(1)            | O(nÂ²)           |
| å¿«é€Ÿæ’åº Quick Sort     | åˆ†æ²»æ³•ï¼Œé€‰åŸºå‡†å…ƒç´ ï¼Œå°†æ•°ç»„åˆ†ä¸ºå°äº/å¤§äºåŸºå‡†çš„ä¸¤éƒ¨åˆ†é€’å½’æ’åº | ä¸ç¨³å®š | O(log n) é€’å½’æ ˆ | O(n log n) å¹³å‡ |
| å½’å¹¶æ’åº Merge Sort     | åˆ†æ²»æ³•ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤åŠåˆ†åˆ«æ’åºï¼Œå†åˆå¹¶                      | ç¨³å®š   | O(n)            | O(n log n)      |
| å †æ’åº Heap Sort        | åˆ©ç”¨å †ï¼Œæ¯æ¬¡å–å †é¡¶ï¼ˆæœ€å¤§/æœ€å°ï¼‰å…ƒç´ æ’åº                     | ä¸ç¨³å®š | O(1)            | O(n log n)      |
| STL sort                | å†…ç½®å¿«é€Ÿæ’åº/æ··åˆæ’åº                                       | ä¸ç¨³å®š | O(log n)        | O(n log n)      |
| STL stable_sort         | å†…ç½®å½’å¹¶æ’åº                                                | ç¨³å®š   | O(n)            | O(n log n)      |

## å­—ç¬¦ä¸²

### KMPï¼ˆç”¨äºå­—ç¬¦ä¸²åŒ¹é…ï¼‰

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// æ„å»ºNextæ•°ç»„ï¼ˆéƒ¨åˆ†åŒ¹é…è¡¨ï¼‰
vector<int> buildNext(const string& pattern) {
    int n = pattern.length();
    vector<int> next(n, 0);
    
    int j = 0;  // å‰ç¼€æœ«å°¾ä½ç½®
    for (int i = 1; i < n; i++) {  // iæ˜¯åç¼€æœ«å°¾ä½ç½®
        // å½“å­—ç¬¦ä¸åŒ¹é…æ—¶ï¼Œå›æº¯åˆ°å‰ä¸€ä¸ªå¯èƒ½åŒ¹é…çš„ä½ç½®
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        
        // å¦‚æœå­—ç¬¦åŒ¹é…ï¼Œå‰åç¼€é•¿åº¦å¢åŠ 
        if (pattern[i] == pattern[j]) {
            j++;
        }
        
        next[i] = j;
    }
    
    return next;
}
// KMPæœç´¢ç®—æ³•
int kmpSearch(const string& text, const string& pattern) {
    if (pattern.empty()) return 0;
    
    vector<int> next = buildNext(pattern);
    int j = 0;  // æ¨¡å¼ä¸²çš„æŒ‡é’ˆ
    
    for (int i = 0; i < text.length(); i++) {  // iæ˜¯æ–‡æœ¬ä¸²çš„æŒ‡é’ˆ
        // å½“ä¸åŒ¹é…æ—¶ï¼Œæ ¹æ®nextæ•°ç»„è°ƒæ•´æ¨¡å¼ä¸²ä½ç½®
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        
        // å¦‚æœå­—ç¬¦åŒ¹é…ï¼Œç»§ç»­æ¯”è¾ƒä¸‹ä¸€ä¸ª
        if (text[i] == pattern[j]) {
            j++;
        }
        
        // æ‰¾åˆ°å®Œæ•´åŒ¹é…
        if (j == pattern.length()) {
            return i - j + 1;  // è¿”å›åŒ¹é…çš„èµ·å§‹ä½ç½®
        }
    }
    
    return -1;  // æœªæ‰¾åˆ°
}
int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";
    
    cout << "æ–‡æœ¬: " << text << endl;
    cout << "æ¨¡å¼: " << pattern << endl;
    
    int pos = kmpSearch(text, pattern);
    
    if (pos != -1) {
        cout << "æ¨¡å¼åœ¨ä½ç½® " << pos << " å¤„æ‰¾åˆ°" << endl;
    } else {
        cout << "æœªæ‰¾åˆ°æ¨¡å¼" << endl;
    }
    
    return 0;
}
```

### std::stringåº“å‡½æ•°ä½¿ç”¨é€ŸæŸ¥

| å‡½æ•°                            | å‚æ•°                                               | è¿”å›ç±»å‹                      | åŠŸèƒ½                                            | æ—¶é—´å¤æ‚åº¦              |
| ------------------------------- | -------------------------------------------------- | ----------------------------- | ----------------------------------------------- | ----------------------- |
| `size()` / `length()`           | æ—                                                  | `size_t`                      | è¿”å›å­—ç¬¦ä¸²é•¿åº¦                                  | O(1)                    |
| `empty()`                       | æ—                                                  | `bool`                        | åˆ¤æ–­æ˜¯å¦ä¸ºç©º                                    | O(1)                    |
| `push_back(char c)`             | è¦æ·»åŠ çš„å­—ç¬¦ `c`                                   | void                          | åœ¨æœ«å°¾æ·»åŠ ä¸€ä¸ªå­—ç¬¦                              | O(1) å‡æ‘Š               |
| `pop_back()`                    | æ—                                                  | void                          | åˆ é™¤æœ«å°¾å­—ç¬¦                                    | O(1)                    |
| `append(const string& str)`     | å­—ç¬¦ä¸²æˆ–å­—ç¬¦æ•°ç»„                                   | string&                       | åœ¨æœ«å°¾è¿½åŠ å­—ç¬¦ä¸²                                | O(len(str))             |
| `substr(pos, len)`              | èµ·å§‹ä¸‹æ ‡ `pos`ï¼Œé•¿åº¦ `len`ï¼ˆå¯çœç•¥è¡¨ç¤ºåˆ°æœ«å°¾ï¼‰     | string                        | è¿”å›ä» `pos` å¼€å§‹é•¿åº¦ä¸º `len` çš„å­ä¸²            | O(len)                  |
| `find(const string& str, pos)`  | å­ä¸² `str`ï¼Œèµ·å§‹ä¸‹æ ‡ `pos`ï¼ˆå¯é€‰ï¼‰                 | size_t                        | è¿”å›å­ä¸²é¦–æ¬¡å‡ºç°ä½ç½®ï¼Œæ²¡æ‰¾åˆ°è¿”å› `string::npos` | O(n*len(str))           |
| `rfind(const string& str, pos)` | å­ä¸² `str`ï¼Œèµ·å§‹ä¸‹æ ‡ `pos`ï¼ˆå¯é€‰ï¼‰                 | size_t                        | ä»åå‘å‰æŸ¥æ‰¾å­ä¸²é¦–æ¬¡å‡ºç°                        | O(n*len(str))           |
| `replace(pos, len, str)`        | èµ·å§‹ä¸‹æ ‡ `pos`ï¼Œé•¿åº¦ `len`ï¼Œæ›¿æ¢å­—ç¬¦ä¸² `str`       | string&                       | æ›¿æ¢æŒ‡å®šèŒƒå›´                                    | O(len + str.length())   |
| `insert(pos, str)`              | æ’å…¥ä½ç½® `pos`ï¼Œæ’å…¥å­—ç¬¦ä¸² `str`                   | string&                       | åœ¨æŒ‡å®šä½ç½®æ’å…¥å­—ç¬¦ä¸²                            | O(n-pos + str.length()) |
| `erase(pos, len)`               | èµ·å§‹ä¸‹æ ‡ `pos`ï¼Œåˆ é™¤é•¿åº¦ `len`ï¼ˆå¯çœç•¥è¡¨ç¤ºåˆ°æœ«å°¾ï¼‰ | string&                       | åˆ é™¤æŒ‡å®šèŒƒå›´                                    | O(n-pos + len)          |
| `compare(const string& str)`    | æ¯”è¾ƒå­—ç¬¦ä¸² `str`                                   | int                           | æ¯”è¾ƒå¤§å°ï¼Œ0=ç›¸ç­‰ï¼Œ<0=å°äºï¼Œ>0=å¤§äº              | O(min(n, str.length())) |
| `c_str()`                       | æ—                                                  | `const char*`                 | è¿”å› C é£æ ¼å­—ç¬¦ä¸²                               | O(1)                    |
| `at(pos)`                       | ä¸‹æ ‡ `pos`                                         | `char&`                       | è¿”å›æŒ‡å®šä½ç½®å­—ç¬¦ï¼ˆå¸¦è¶Šç•Œæ£€æŸ¥ï¼‰                  | O(1)                    |
| `operator[]`                    | ä¸‹æ ‡ `pos`                                         | `char&`                       | è¿”å›æŒ‡å®šä½ç½®å­—ç¬¦ï¼ˆä¸æ£€æŸ¥è¶Šç•Œï¼‰                  | O(1)                    |
| `begin()` / `end()`             | æ—                                                  | `iterator` / `const_iterator` | è¿”å›è¿­ä»£å™¨ï¼Œç”¨äºéå†æˆ–ç®—æ³•                      | O(1)                    |
| `front()`                       | æ—                                                  | `char&`                       | è¿”å›ç¬¬ä¸€ä¸ªå­—ç¬¦                                  | O(1)                    |
| `back()`                        | æ—                                                  | `char&`                       | è¿”å›æœ€åä¸€ä¸ªå­—ç¬¦                                | O(1)                    |
| `resize(new_size, char c)`      | æ–°é•¿åº¦ `new_size`ï¼Œå¡«å……å­—ç¬¦ `c`ï¼ˆå¯é€‰ï¼‰            | void                          | æ”¹å˜å­—ç¬¦ä¸²é•¿åº¦                                  | O(new_size)             |
| `clear()`                       | æ—                                                  | void                          | æ¸…ç©ºå­—ç¬¦ä¸²                                      | O(n)                    |
| `swap(string& other)`           | å¦ä¸€ä¸ªå­—ç¬¦ä¸² `other`                               | void                          | äº¤æ¢ä¸¤ä¸ªå­—ç¬¦ä¸²                                  | O(1)ï¼ˆå†…éƒ¨æŒ‡é’ˆäº¤æ¢ï¼‰    |

------

âš¡ **ä½¿ç”¨å°è´´å£«**

1. **æœ«å°¾æ“ä½œ**ï¼š`push_back`ã€`pop_back` æ˜¯ O(1)ï¼Œé¢‘ç¹æœ«å°¾æ“ä½œéå¸¸å¿«ã€‚
2. **æ’å…¥/åˆ é™¤ä¸­é—´å­—ç¬¦**ï¼šå¤æ‚åº¦ O(n)ï¼Œå¤§é‡ä¸­é—´ä¿®æ”¹æ¨èç”¨ `deque<char>` æˆ– `list<char>`ã€‚
3. **æŸ¥æ‰¾/æ›¿æ¢**ï¼š`find`/`rfind`/`replace` éƒ½æ˜¯ O(n) çº§åˆ«ï¼Œå­ä¸²é•¿åº¦ä¹Ÿä¼šå½±å“ã€‚
4. **å®‰å…¨è®¿é—®**ï¼š`at(pos)` ä¼šæ£€æŸ¥è¶Šç•Œï¼Œ`operator[]` ä¸ä¼šã€‚
5. **éå†**ï¼š`begin()` / `end()` ç»“åˆç®—æ³•å‡½æ•°éå¸¸æ–¹ä¾¿ã€‚

### Manacherï¼ˆè¿™ä¸ªå¤ªéš¾äº†æ€•æ˜¯ä¸ä¼šè€ƒï¼‰

```cpp
const int N = 3e7 + 10;

char c[N],s[N];
int n,m,d[N];

signed main() {
    scanf("%s",c+1);
    m = strlen(c+1);
    s[0] = '#';
    for (int i = 1;i <= m;++i) {
        s[++n] = c[i];s[++n] = '#';
    }
    int l = 0,r = -1,ans = 0;
    for (int i = 0;i <= n;++i) {
        int k = (i > r) ? 1 : min(d[l + r - i],r - i + 1);
        while (k <= i && i + k <= n && s[i+k] == s[i-k]) ++k;
        d[i] = --k;
        ans = max(ans,d[i]);
        if (i + k > r) {
            l = i-k;r = i+k;
        }
    }
    printf("%d\n",ans);

	return 0;
}
```

### stringstreamé€ŸæŸ¥

------

**1ï¸âƒ£ æ„é€ ä¸åˆå§‹åŒ–**

| æ–¹æ³•                              | å‚æ•°             | è¿”å›ç±»å‹ | åŠŸèƒ½             | æ—¶é—´å¤æ‚åº¦ |
| --------------------------------- | ---------------- | -------- | ---------------- | ---------- |
| `stringstream()`                  | æ—                | â€”        | åˆ›å»ºç©ºæµ         | O(1)       |
| `stringstream(const string &str)` | åˆå§‹å­—ç¬¦ä¸² `str` | â€”        | ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–æµ | O(n)       |

------

**2ï¸âƒ£ åŸºæœ¬è¾“å…¥æ“ä½œ**

| æ–¹æ³•                      | å‚æ•°                                               | è¿”å›ç±»å‹        | åŠŸèƒ½                     | æ—¶é—´å¤æ‚åº¦        |
| ------------------------- | -------------------------------------------------- | --------------- | ------------------------ | ----------------- |
| `operator>>`              | å˜é‡ï¼ˆint, double, string ç­‰ï¼‰                     | `stringstream&` | ä»æµä¸­æŒ‰ç©ºæ ¼è¯»å–ä¸‹ä¸€ä¸ªå€¼ | O(len(value))     |
| `getline(ss, str, delim)` | ç›®æ ‡å­—ç¬¦ä¸² `str`ï¼Œåˆ†éš”ç¬¦ `delim`ï¼ˆå¯é€‰ï¼Œé»˜è®¤`\n`ï¼‰ | `stringstream&` | è¯»å–åˆ°åˆ†éš”ç¬¦ä¸ºæ­¢çš„å­ä¸²   | O(len(substring)) |

> **Tip**ï¼š`operator>>` é»˜è®¤æŒ‰ç©ºæ ¼åˆ†å‰²ï¼Œ`getline` å¯è‡ªå®šä¹‰åˆ†éš”ç¬¦ã€‚

------

**3ï¸âƒ£ è¾“å‡ºæ“ä½œï¼ˆå†™å…¥å­—ç¬¦ä¸²ï¼‰**

| æ–¹æ³•                   | å‚æ•°                           | è¿”å›ç±»å‹        | åŠŸèƒ½           | æ—¶é—´å¤æ‚åº¦    |
| ---------------------- | ------------------------------ | --------------- | -------------- | ------------- |
| `operator<<`           | å˜é‡ï¼ˆint, double, string ç­‰ï¼‰ | `stringstream&` | å‘æµå†™å…¥å€¼     | O(len(value)) |
| `str()`                | æ—                              | string          | è·å–æµå½“å‰å†…å®¹ | O(n)          |
| `str(const string &s)` | æ–°å­—ç¬¦ä¸² s                     | void            | é‡ç½®æµå†…å®¹     | O(n)          |

------

**4ï¸âƒ£ çŠ¶æ€ä¸æ§åˆ¶**

| æ–¹æ³•      | å‚æ•° | è¿”å›ç±»å‹ | åŠŸèƒ½                           | æ—¶é—´å¤æ‚åº¦ |
| --------- | ---- | -------- | ------------------------------ | ---------- |
| `clear()` | æ—    | void     | æ¸…ç©ºæµçŠ¶æ€æ ‡å¿—ï¼ˆeofã€fail ç­‰ï¼‰ | O(1)       |
| `eof()`   | æ—    | bool     | åˆ¤æ–­æ˜¯å¦åˆ°è¾¾æµæœ«å°¾             | O(1)       |
| `fail()`  | æ—    | bool     | åˆ¤æ–­è¾“å…¥æ˜¯å¦å¤±è´¥               | O(1)       |
| `good()`  | æ—    | bool     | åˆ¤æ–­æµæ˜¯å¦æ­£å¸¸                 | O(1)       |
| `peek()`  | æ—    | int      | æŸ¥çœ‹ä¸‹ä¸€ä¸ªå­—ç¬¦ä½†ä¸å–å‡º         | O(1)       |
| `get()`   | æ—    | int      | è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦                 | O(1)       |

------

**5ï¸âƒ£ é«˜çº§æ“ä½œ**

(1) **é‡ç”¨åŒä¸€æµ**

```cpp
stringstream ss;
ss.str("10 20 30");  // åˆå§‹åŒ–
int x;
ss >> x; // x = 10
ss.clear(); // æ¸…ç©ºçŠ¶æ€æ ‡å¿—ï¼Œå¯ä»¥ç»§ç»­é‡ç”¨
ss.str("40 50"); // é‡ç½®å†…å®¹
```

(2) **æŒ‰å­—ç¬¦è¯»å–**

```cpp
char c;
while (ss.get(c)) {
    cout << c;  // æ¯æ¬¡è¯»å–ä¸€ä¸ªå­—ç¬¦
}
```

(3) **å›é€€å­—ç¬¦**

```cpp
ss.putback('A'); // æŠŠå­—ç¬¦æ”¾å›æµä¸­ï¼Œä¸‹ä¸€æ¬¡è¯»å–ä¼šè¯»åˆ° 'A'
```

(4) **æ ¼å¼åŒ–æ•°å­—**

```cpp
double d = 3.14159;
stringstream ss;
ss << fixed << setprecision(2) << d; // ss å†…å®¹: "3.14"
```

(5) **è¯»å–æ•´è¡Œå¹¶æ‹†åˆ†**

```cpp
string line = "1,2,3";
stringstream ss(line);
string token;
while (getline(ss, token, ',')) {
    cout << token << "\n"; // è¾“å‡ºæ¯ä¸ªé€—å·åˆ†éš”çš„éƒ¨åˆ†
}
```

------

**6ï¸âƒ£ æ—¶é—´å¤æ‚åº¦æ€»ç»“**

| æ“ä½œ                                      | æ—¶é—´å¤æ‚åº¦        |
| ----------------------------------------- | ----------------- |
| `ss >> x`                                 | O(len(value))     |
| `ss << x`                                 | O(len(value))     |
| `getline(ss, str, delim)`                 | O(len(substring)) |
| `str()` / `str(s)`                        | O(n)              |
| `clear()` / `good()` / `fail()` / `eof()` | O(1)              |
| `peek()` / `get()` / `putback()`          | O(1)              |
| æ ¼å¼åŒ–å†™å…¥ï¼ˆ`<< fixed << setprecision`ï¼‰  | O(len(value))     |

------

**7ï¸âƒ£ å¸¸è§ç«èµ›ç”¨æ³•**

1. **å­—ç¬¦ä¸²è½¬æ•´æ•°/æµ®ç‚¹æ•°**

```cpp
int x;
stringstream("123") >> x;
```

1. **æ•´æ•°/æµ®ç‚¹æ•°è½¬å­—ç¬¦ä¸²**

```cpp
stringstream ss;
ss << 456;
string s = ss.str();
```

1. **æŒ‰ç©ºæ ¼æˆ–è‡ªå®šä¹‰åˆ†éš”ç¬¦æ‹†åˆ†å­—ç¬¦ä¸²**

```cpp
string line = "10,20,30";
stringstream ss(line);
string token;
while (getline(ss, token, ',')) { ... }
```

1. **å¿«é€Ÿè§£æä¸€è¡Œæ··åˆç±»å‹è¾“å…¥**

```cpp
string line = "123 45.6 hello";
stringstream ss(line);
int a; double b; string c;
ss >> a >> b >> c;
```

------

âœ… **æ€»ç»“**

- `stringstream` æ˜¯ **ä¸‡èƒ½çš„å­—ç¬¦ä¸²æµæ“ä½œå·¥å…·**ï¼Œå¯ä»¥åšï¼š
  - å­—ç¬¦ä¸² â†” æ•°å­—è½¬æ¢
  - å­—ç¬¦ä¸²æ‹†åˆ† / åˆå¹¶
  - æŒ‰å­—ç¬¦æˆ–æŒ‰åˆ†éš”ç¬¦è¯»å–
- æ³¨æ„ï¼š
  - å¤§é‡å­—ç¬¦æ“ä½œå¤æ‚åº¦ä¸º O(n)
  - ä½¿ç”¨ `clear()` + `str("")` å¯ä»¥é‡å¤ä½¿ç”¨åŒä¸€ä¸ªæµ

### åˆ¤æ–­æ˜¯å¦å¯ä»¥è½¬åŒ–ä¸ºæ•°å­—

```cpp
//åˆ¤æ–­æ•´æ•°
#include <bits/stdc++.h>
using namespace std;

bool isInteger(const string &s) {
    if (s.empty()) return false;

    int start = 0;
    if (s[0] == '+' || s[0] == '-') start = 1; // å¯ä»¥æœ‰ç¬¦å·ä½

    if (start == s.size()) return false; // åªæœ‰ '+' æˆ– '-' ä¸è¡Œ

    for (int i = start; i < s.size(); i++) {
        if (!isdigit(s[i])) return false;
    }

    return true;
}

int main() {
    vector<string> test = {"123", "-456", "+0", "12a", "--5", ""};
    for (auto s : test) {
        cout << s << " -> " << (isInteger(s) ? "YES" : "NO") << "\n";
    }
}

//åˆ¤æ–­æµ®ç‚¹æ•°
bool isNumber(const string &s) {
    if (s.empty()) return false;

    int start = 0;
    if (s[0] == '+' || s[0] == '-') start = 1; // ç¬¦å·

    if (start == s.size()) return false; // åªæœ‰ '+'/'-' ä¸è¡Œ

    bool dotSeen = false;   // æ˜¯å¦å‡ºç°è¿‡å°æ•°ç‚¹
    bool digitSeen = false; // æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ•°å­—

    for (int i = start; i < s.size(); i++) {
        if (isdigit(s[i])) {
            digitSeen = true;
        } else if (s[i] == '.') {
            if (dotSeen) return false; // å¤šä¸ªå°æ•°ç‚¹ä¸è¡Œ
            dotSeen = true;
        } else {
            return false; // éæ•°å­—éå°æ•°ç‚¹
        }
    }

    return digitSeen; // è‡³å°‘æœ‰ä¸€ä¸ªæ•°å­—
}

int main() {
    vector<string> test = {"123", "-456", "+0", "12.34", "-0.5", ".", "12..3", "12a"};
    for (auto s : test) {
        cout << s << " -> " << (isNumber(s) ? "YES" : "NO") << "\n";
    }
}

//try catchå†™æ³•
bool isnum(string a){
    try{
        size_t idx;
        stod(a,&idx);
        if(idx!=a.size()) return false;
    }catch(...){ return false;}
    int dot=0;
    for(char c:a) if(c=='.') dot++;
    if(dot>1) return false;
    size_t pos=a.find('.');
    if(pos!=string::npos && a.size()-pos-1>2) return false;
    double val=stod(a);
    return !(val<-1000||val>1000);
}//è¿™ä¸ªå‡½æ•°çš„çº¦æŸæ¡ä»¶æ˜¯ï¼Œæ•°å­—æœ€å¤šåªæœ‰ä¸¤ä½å°æ•°ï¼Œå¹¶ä¸”å€¼åœ¨[-1000,1000]ä¹‹é—´
```

### å„ç§å•å­—ç¬¦åˆ¤æ–­

------

**å•å­—ç¬¦åˆ¤æ–­å‡½æ•°ï¼ˆï¼‰**

| å‡½æ•°              | å‚æ•°       | è¿”å›ç±»å‹ | åŠŸèƒ½                                      | æ—¶é—´å¤æ‚åº¦ |
| ----------------- | ---------- | -------- | ----------------------------------------- | ---------- |
| `isdigit(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯æ•°å­— `'0'-'9'`                  | O(1)       |
| `isalpha(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯ `'a'-'z'` æˆ– `'A'-'Z'`     | O(1)       |
| `isalnum(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯æˆ–æ•°å­—                      | O(1)       |
| `islower(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯å°å†™å­—æ¯                        | O(1)       |
| `isupper(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯å¤§å†™å­—æ¯                        | O(1)       |
| `isspace(char c)` | å•å­—ç¬¦ `c` | `bool`   | åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºç™½å­—ç¬¦ï¼ˆç©ºæ ¼ã€`\t`ã€`\n` ç­‰ï¼‰ | O(1)       |

------

**å•å­—ç¬¦å¤§å°å†™è½¬æ¢å‡½æ•°**

| å‡½æ•°              | å‚æ•°       | è¿”å›ç±»å‹ | åŠŸèƒ½                                 | æ—¶é—´å¤æ‚åº¦ |
| ----------------- | ---------- | -------- | ------------------------------------ | ---------- |
| `tolower(char c)` | å•å­—ç¬¦ `c` | `char`   | è½¬æˆå°å†™ï¼Œå¦‚æœä¸æ˜¯å¤§å†™å­—æ¯è¿”å›åŸå­—ç¬¦ | O(1)       |
| `toupper(char c)` | å•å­—ç¬¦ `c` | `char`   | è½¬æˆå¤§å†™ï¼Œå¦‚æœä¸æ˜¯å°å†™å­—æ¯è¿”å›åŸå­—ç¬¦ | O(1)       |

------

**ç¤ºä¾‹ç”¨æ³•**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    char c = 'A';
    
    if(isdigit(c)) cout << c << " æ˜¯æ•°å­—\n";
    if(isalpha(c)) cout << c << " æ˜¯å­—æ¯\n";
    
    cout << "å°å†™: " << (char)tolower(c) << "\n"; // è¾“å‡º a
    cout << "å¤§å†™: " << (char)toupper('b') << "\n"; // è¾“å‡º B
    
    return 0;
}
```

------

âš¡ **æ€»ç»“**ï¼š

- æ‰€æœ‰å‡½æ•°éƒ½æ˜¯ O(1)ï¼Œé€‚åˆå¾ªç¯ä¸­é¢‘ç¹è°ƒç”¨
- `isalnum` = `isalpha || isdigit`
- `tolower` / `toupper` åªå¯¹å­—æ¯æœ‰æ•ˆï¼Œå…¶ä»–å­—ç¬¦ä¿æŒä¸å˜
- åœ¨å¤„ç†å­—ç¬¦ä¸²æ—¶ï¼Œå¯ä»¥ç»“åˆå¾ªç¯å¿«é€Ÿåˆ¤æ–­æ¯ä¸ªå­—ç¬¦ç±»å‹æˆ–ç»Ÿä¸€å¤§å°å†™

### æœ€ç»ˆç‰ˆè¶…çº§æ¿å­

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace str_utils {

// =====================
// åŸºæœ¬æ“ä½œ
// =====================
inline bool isEmpty(const string &s) { return s.empty(); }
inline size_t length(const string &s) { return s.size(); }
inline void clearString(string &s) { s.clear(); }
inline void appendString(string &s, const string &t) { s += t; }
inline char charAt(const string &s, size_t pos) { return s.at(pos); }
inline char charAtUnsafe(const string &s, size_t pos) { return s[pos]; }
inline void setChar(string &s, size_t pos, char c) { s[pos] = c; }
inline void popBack(string &s) { s.pop_back(); }
inline void pushBack(string &s, char c) { s.push_back(c); }

// =====================
// æŸ¥æ‰¾ä¸æ¯”è¾ƒ
// =====================
inline size_t findSubstr(const string &s, const string &sub, size_t pos=0) { return s.find(sub,pos); }
inline size_t rfindSubstr(const string &s, const string &sub) { return s.rfind(sub); }
inline size_t findChar(const string &s, char c, size_t pos=0) { return s.find(c,pos); }
inline int compareString(const string &a, const string &b) { return a.compare(b); }
inline bool equals(const string &a, const string &b) { return a == b; }

// =====================
// å­ä¸²ä¸åˆ‡åˆ†
// =====================
inline string subString(const string &s, size_t pos, size_t len) { return s.substr(pos,len); }

// æŒ‰åˆ†éš”ç¬¦æ‹†åˆ†
inline vector<string> splitString(const string &s, char delim=' ') {
    vector<string> res;
    stringstream ss(s);
    string token;
    while(getline(ss, token, delim)) res.push_back(token);
    return res;
}

// åˆ é™¤å­—ç¬¦/å­ä¸²
inline void removeChar(string &s, char target){
    size_t pos=0;
    while((pos = s.find(target,pos)) != string::npos) s.erase(pos,1);
}

inline void removeSubstring(string &s, const string &sub){
    if(sub.empty()) return;
    size_t pos=0;
    while((pos = s.find(sub,pos)) != string::npos) s.erase(pos, sub.size());
}

// =====================
// æ•°å­—åˆ¤æ–­ä¸è½¬æ¢
// =====================
inline bool isInteger(const string &s){
    if(s.empty()) return false;
    int start=0; if(s[0]=='+'||s[0]=='-') start=1;
    if(start==s.size()) return false;
    for(int i=start;i<s.size();i++) if(!isdigit(s[i])) return false;
    return true;
}

inline bool isNumber(const string &s){
    if(s.empty()) return false;
    int start=0; if(s[0]=='+'||s[0]=='-') start=1;
    if(start==s.size()) return false;
    bool dot=false,digit=false;
    for(int i=start;i<s.size();i++){
        if(isdigit(s[i])) digit=true;
        else if(s[i]=='.'){ if(dot) return false; dot=true; }
        else return false;
    }
    return digit;
}

inline bool str2int(const string &s, int &res){
    try{ res = stoi(s); return true; } catch(...){ return false; }
}
inline bool str2ll(const string &s, long long &res){
    try{ res = stoll(s); return true; } catch(...){ return false; }
}
inline bool str2double(const string &s, double &res){
    try{ res = stod(s); return true; } catch(...){ return false; }
}

inline string int2str(int x){ return to_string(x); }
inline string ll2str(long long x){ return to_string(x); }
inline string double2str(double x, int precision=6){
    stringstream ss;
    ss << fixed << setprecision(precision) << x;
    return ss.str();
}

// =====================
// å•å­—ç¬¦åˆ¤æ–­
// =====================
inline bool isDigit(char c){ return isdigit(c); }
inline bool isAlpha(char c){ return isalpha(c); }
inline bool isAlnum(char c){ return isalnum(c); }
inline bool isLower(char c){ return islower(c); }
inline bool isUpper(char c){ return isupper(c); }
inline bool isSpace(char c){ return isspace(c); }

// =====================
// å•å­—ç¬¦å¤§å°å†™è½¬æ¢
// =====================
inline char toLowerChar(char c){ return tolower(c); }
inline char toUpperChar(char c){ return toupper(c); }

// =====================
// å­—ç¬¦ä¸²å¤§å°å†™è½¬æ¢
// =====================
inline void toLower(string &s){ transform(s.begin(), s.end(), s.begin(), ::tolower); }
inline void toUpper(string &s){ transform(s.begin(), s.end(), s.begin(), ::toupper); }

// =====================
// stringstream å¿«é€Ÿè§£æ
// =====================
inline stringstream strToStream(const string &s){ return stringstream(s); }
inline string streamToStr(stringstream &ss){ return ss.str(); }
inline void clearStream(stringstream &ss){ ss.clear(); ss.str(""); }

} // namespace str_utils
```

## çº¿æ€§æ•°æ®ç»“æ„

### list

**C++ std::list é«˜çº§æ“ä½œå¤§å…¨**

```
#include <list>
#include <list>
using namespace std;
```

------

**1ï¸âƒ£ æ„é€ ä¸èµ‹å€¼**

| æ–¹æ³•                    | å‚æ•°                       | è¿”å›ç±»å‹ | åŠŸèƒ½          | æ—¶é—´å¤æ‚åº¦ |
| ----------------------- | -------------------------- | -------- | ------------- | ---------- |
| `list<T>()`             | â€”                          | â€”        | ç©º list       | O(1)       |
| `list<T>(n, val)`       | å…ƒç´ ä¸ªæ•° `n`ï¼Œåˆå§‹å€¼ `val` | â€”        | æ„é€  n ä¸ªå…ƒç´  | O(n)       |
| `list<T>(iter1, iter2)` | åŒºé—´ `[iter1, iter2)`      | â€”        | æ„é€  list     | O(n)       |
| `assign(n, val)`        | n, val                     | void     | æ›¿æ¢æ‰€æœ‰å…ƒç´   | O(n)       |
| `assign(iter1, iter2)`  | åŒºé—´ `[iter1, iter2)`      | void     | æ›¿æ¢æ‰€æœ‰å…ƒç´   | O(n)       |

------

**2ï¸âƒ£ å®¹é‡**

| æ–¹æ³•         | è¿”å›ç±»å‹ | åŠŸèƒ½         | æ—¶é—´å¤æ‚åº¦ |
| ------------ | -------- | ------------ | ---------- |
| `empty()`    | bool     | åˆ¤æ–­æ˜¯å¦ä¸ºç©º | O(1)       |
| `size()`     | size_t   | å…ƒç´ ä¸ªæ•°     | O(1)       |
| `max_size()` | size_t   | ç†è®ºæœ€å¤§å…ƒç´  | O(1)       |

------

**3ï¸âƒ£ å…ƒç´ è®¿é—®**

| æ–¹æ³•      | è¿”å›ç±»å‹ | åŠŸèƒ½       | æ—¶é—´å¤æ‚åº¦ |
| --------- | -------- | ---------- | ---------- |
| `front()` | T&       | ç¬¬ä¸€ä¸ªå…ƒç´  | O(1)       |
| `back()`  | T&       | æœ€åå…ƒç´    | O(1)       |

------

**4ï¸âƒ£ æ’å…¥**

| æ–¹æ³•                        | å‚æ•°            | è¿”å›ç±»å‹ | åŠŸèƒ½           | æ—¶é—´å¤æ‚åº¦ |
| --------------------------- | --------------- | -------- | -------------- | ---------- |
| `push_back(val)`            | val             | void     | å°¾éƒ¨æ’å…¥       | O(1)       |
| `push_front(val)`           | val             | void     | å¤´éƒ¨æ’å…¥       | O(1)       |
| `insert(pos, val)`          | è¿­ä»£å™¨ pos, val | iterator | pos å‰æ’å…¥å…ƒç´  | O(1)       |
| `insert(pos, n, val)`       | pos, n, val     | iterator | æ’å…¥ n ä¸ªå…ƒç´   | O(n)       |
| `insert(pos, iter1, iter2)` | pos, åŒºé—´       | iterator | æ’å…¥åŒºé—´å…ƒç´    | O(n)       |

------

**5ï¸âƒ£ åˆ é™¤**

| æ–¹æ³•                | å‚æ•°      | è¿”å›ç±»å‹ | åŠŸèƒ½             | æ—¶é—´å¤æ‚åº¦ |
| ------------------- | --------- | -------- | ---------------- | ---------- |
| `pop_back()`        | â€”         | void     | åˆ é™¤å°¾           | O(1)       |
| `pop_front()`       | â€”         | void     | åˆ é™¤å¤´           | O(1)       |
| `erase(pos)`        | pos       | iterator | åˆ é™¤ pos å…ƒç´     | O(1)       |
| `erase(first,last)` | åŒºé—´      | iterator | åˆ é™¤åŒºé—´å…ƒç´      | O(n)       |
| `remove(val)`       | val       | void     | åˆ é™¤æ‰€æœ‰ val     | O(n)       |
| `remove_if(pred)`   | å‡½æ•°/è°“è¯ | void     | åˆ é™¤æ»¡è¶³æ¡ä»¶å…ƒç´  | O(n)       |
| `clear()`           | â€”         | void     | æ¸…ç©º list        | O(n)       |

------

**6ï¸âƒ£ é«˜çº§æ“ä½œ**

| æ–¹æ³•                              | å‚æ•°             | è¿”å›ç±»å‹ | åŠŸèƒ½                     | æ—¶é—´å¤æ‚åº¦ |
| --------------------------------- | ---------------- | -------- | ------------------------ | ---------- |
| `resize(n)`                       | n                | void     | æ”¹å˜å¤§å°ï¼Œå¤šå‡ºé»˜è®¤åˆå§‹åŒ– | O(n)       |
| `resize(n,val)`                   | n, val           | void     | æ”¹å˜å¤§å°ï¼Œå¤šå‡ºç”¨ val     | O(n)       |
| `swap(list &other)`               | other            | void     | äº¤æ¢å†…å®¹                 | O(1)       |
| `merge(list &other)`              | other            | void     | å·²æ’åº list åˆå¹¶         | O(n+m)     |
| `splice(pos, other)`              | pos, other       | void     | ç§»åŠ¨ entire other åˆ° pos | O(1)       |
| `splice(pos, other, it)`          | pos, other, it   | void     | ç§»åŠ¨å•å…ƒç´                | O(1)       |
| `splice(pos, other, first, last)` | pos, other, åŒºé—´ | void     | ç§»åŠ¨åŒºé—´                 | O(n)       |
| `sort()`                          | â€”                | void     | æ’åº                     | O(n log n) |
| `reverse()`                       | â€”                | void     | åè½¬                     | O(n)       |
| `unique()`                        | â€”                | void     | åˆ é™¤è¿ç»­é‡å¤             | O(n)       |
| `remove_if(pred)`                 | å‡½æ•°/è°“è¯        | void     | åˆ é™¤æ»¡è¶³æ¡ä»¶             | O(n)       |

------

**7ï¸âƒ£ è¿­ä»£å™¨ç›¸å…³**

| æ–¹æ³•       | è¿”å›ç±»å‹         | åŠŸèƒ½       | å¤‡æ³¨       |
| ---------- | ---------------- | ---------- | ---------- |
| `begin()`  | iterator         | æŒ‡å‘é¦–å…ƒç´  | åŒå‘è¿­ä»£å™¨ |
| `end()`    | iterator         | æŒ‡å‘å°¾å   | â€”          |
| `rbegin()` | reverse_iterator | åå‘è¿­ä»£å™¨ | æŒ‡å‘å°¾å…ƒç´  |
| `rend()`   | reverse_iterator | æŒ‡å‘å¤´å‰   | â€”          |

------

**8ï¸âƒ£ å¸¸ç”¨ç»„åˆæ“ä½œæ¨¡æ¿**

```cpp
list<int> l = {1,2,3,2,4,2};

// åˆ é™¤æ‰€æœ‰2
l.remove(2);

// åˆ é™¤å¤§äº3çš„
l.remove_if([](int x){ return x>3; });

// åœ¨å¼€å¤´æ’å…¥å…ƒç´ 
l.push_front(0);

// åœ¨å°¾éƒ¨æ’å…¥å…ƒç´ 
l.push_back(5);

// æ’åºã€å»é‡
l.sort();
l.unique();

// åè½¬
l.reverse();

// åˆå¹¶ä¸¤ä¸ªå·²æ’åº list
list<int> l2 = {0,2,6};
l.merge(l2); // l2 ä¼šå˜ä¸ºç©º
```

------

æ˜ç™½ï¼Œæˆ‘æ¥å¸®ä½ æ•´ç†ä¸€ä»½ **å®Œæ•´ã€èåˆäº†å‰é¢è®¨è®ºçš„æ‰€æœ‰ list æ“ä½œçš„é€ŸæŸ¥è¡¨å’Œæ¨¡æ¿**ï¼Œ
 ç‰¹åˆ«é’ˆå¯¹ **æ¨¡æ‹Ÿæ–‡æœ¬ç¼–è¾‘å™¨ / å…‰æ ‡æ“ä½œ** çš„åœºæ™¯ï¼ŒåŒ…å«æ’å…¥ã€åˆ é™¤ã€å·¦å³ç§»åŠ¨ã€Home/Endã€Insert/Replace ç­‰åŠŸèƒ½ï¼Œç›´æ¥é€‚åˆç«èµ›æˆ–é¢˜ç›®ä½¿ç”¨ã€‚

------

**C++ `std::list` æ–‡æœ¬ç¼–è¾‘å™¨æ“ä½œé€ŸæŸ¥è¡¨**

```cpp
#include <bits/stdc++.h>
using namespace std;

// -------------------
// 1. list æ„é€ ä¸è¿­ä»£å™¨
// -------------------
list<char> text;         // å­˜å‚¨æ–‡æœ¬å†…å®¹
auto it = text.begin();  // å…‰æ ‡ä½ç½®åˆå§‹åŒ–ï¼ˆè¿­ä»£å™¨ï¼‰

// -------------------
// 2. æ’å…¥
// -------------------
it = text.insert(it, c); // åœ¨å…‰æ ‡å‰æ’å…¥å­—ç¬¦ cï¼Œè¿”å›æ’å…¥ä½ç½®è¿­ä»£å™¨
*it = c;                 // Insertæ¨¡å¼è¦†ç›–å½“å‰å…‰æ ‡å­—ç¬¦

// -------------------
// 3. åˆ é™¤
// -------------------
if(it != text.begin()){
    auto tmp = it;
    --tmp;
    text.erase(tmp);     // åˆ é™¤å…‰æ ‡å‰çš„å­—ç¬¦
}
it = text.erase(it);     // åˆ é™¤å…‰æ ‡æ‰€åœ¨å­—ç¬¦ï¼Œè¿”å›ä¸‹ä¸€ä½ç½®è¿­ä»£å™¨

// -------------------
// 4. å…‰æ ‡ç§»åŠ¨
// -------------------
if(it != text.begin()) --it; // â† å·¦ç§»
if(it != text.end()) ++it;   // â†’ å³ç§»
it = text.begin();           // Home
it = text.end();             // End

// -------------------
// 5. éå†è¾“å‡º
// -------------------
for(char c : text) cout << c;  // è¾“å‡ºæœ€ç»ˆæ–‡æœ¬

// -------------------
// 6. é«˜çº§æ“ä½œï¼ˆå¯é€‰ï¼‰
// -------------------
text.clear();                  // æ¸…ç©ºæ–‡æœ¬
text.pop_back();               // åˆ é™¤å°¾éƒ¨
text.pop_front();              // åˆ é™¤å¤´éƒ¨
text.push_back(c);             // å°¾éƒ¨æ’å…¥
text.push_front(c);            // å¤´éƒ¨æ’å…¥
text.sort();                   // æ’åºï¼ˆé“¾è¡¨ç”¨ä¸åˆ°æ–‡æœ¬æ¨¡æ‹Ÿï¼Œä½†é€šç”¨ï¼‰
text.reverse();                // åè½¬
text.unique();                 // åˆ é™¤è¿ç»­é‡å¤å…ƒç´ 
```

------

**å…‰æ ‡æ“ä½œæ€»ç»“**

| æ“ä½œ         | list ç”¨æ³•          | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜                    |
| ------------ | ------------------ | ---------- | ----------------------- |
| æ’å…¥å­—ç¬¦     | `insert(it, c)`    | O(1)       | å…‰æ ‡å‰æ’å…¥              |
| è¦†ç›–å­—ç¬¦     | `*it = c`          | O(1)       | Insert æ¨¡å¼æ›¿æ¢å½“å‰å­—ç¬¦ |
| åˆ é™¤å‰ä¸€å­—ç¬¦ | `erase(--it)`      | O(1)       | Backspace               |
| åˆ é™¤å…‰æ ‡å­—ç¬¦ | `erase(it)`        | O(1)       | Delete                  |
| å…‰æ ‡å·¦ç§»     | `--it`             | O(1)       | ä¸å¯è¶Šè¿‡ begin()        |
| å…‰æ ‡å³ç§»     | `++it`             | O(1)       | ä¸å¯è¶Šè¿‡ end()          |
| å…‰æ ‡ç§»åˆ°å¼€å¤´ | `it = begin()`     | O(1)       | Home                    |
| å…‰æ ‡ç§»åˆ°æœ«å°¾ | `it = end()`       | O(1)       | End                     |
| è¾“å‡ºæ–‡æœ¬     | `for(char c:text)` | O(n)       | éå†è¾“å‡º                |

------

**ç¤ºä¾‹ï¼šå°æ˜æ‰“å­—æ¨¡æ‹Ÿæ¨¡æ¿**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string input;
    getline(cin, input);

    list<char> text;
    auto it = text.begin();
    bool insertMode = true; // true=æ’å…¥ï¼Œfalse=æ›¿æ¢

    for(char key : input) {
        switch(key) {
            case '[': it = text.begin(); break;      // Home
            case ']': it = text.end(); break;        // End
            case '{': if(it != text.begin()) --it; break; // â†
            case '}': if(it != text.end()) ++it; break;   // â†’
            case '-': insertMode = !insertMode; break;   // Insert
            case '=':                                // Backspace
                if(it != text.begin()){
                    auto tmp = it;
                    --tmp;
                    text.erase(tmp);
                }
                break;
            default: // æ™®é€šå­—ç¬¦æˆ–ç©ºæ ¼
                if(insertMode) it = text.insert(it, key), ++it;
                else {
                    if(it != text.end()) *it = key, ++it;
                    else it = text.insert(it, key), ++it;
                }
        }
    }

    for(char c : text) cout << c;
}
```

------

âœ… ç‰¹ç‚¹

1. **åŒå‘è¿­ä»£å™¨ + list** æ”¯æŒå…‰æ ‡ä»»æ„ä½ç½®æ’å…¥ã€åˆ é™¤ O(1)
2. **Insert/Replace åˆ‡æ¢** æ”¯æŒ `-` é”®æ“ä½œ
3. **å…‰æ ‡ç§»åŠ¨**ï¼šâ†ã€â†’ã€Homeã€End å…¨è¦†ç›–
4. **åˆ é™¤**ï¼šBackspace åˆ é™¤å…‰æ ‡å‰å­—ç¬¦
5. **éå†è¾“å‡º**ï¼šæœ€åè¾“å‡ºæ–‡æœ¬

### vector

------

**ğŸ“Œ 1. åŸºç¡€ä¿¡æ¯**

| å‡½æ•°         | ä½œç”¨         | å‚æ•°       | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| ------------ | ------------ | ---------- | -------- | ---------- |
| `size()`     | è¿”å›å…ƒç´ æ•°é‡ | æ—          | `size_t` | O(1)       |
| `empty()`    | åˆ¤æ–­æ˜¯å¦ä¸ºç©º | æ—          | `bool`   | O(1)       |
| `clear()`    | æ¸…ç©ºæ‰€æœ‰å…ƒç´  | æ—          | `void`   | O(n)       |
| `capacity()` | æŸ¥çœ‹å½“å‰å®¹é‡ | æ—          | `size_t` | O(1)       |
| `reserve(n)` | é¢„åˆ†é…å®¹é‡   | `size_t n` | `void`   | O(n)       |

------

**ğŸ“Œ 2. è®¿é—®å…ƒç´ **

| å‡½æ•°            | ä½œç”¨                   | å‚æ•°       | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| --------------- | ---------------------- | ---------- | -------- | ---------- |
| `operator[](i)` | ä¸‹æ ‡è®¿é—®ï¼ˆä¸æ£€æŸ¥è¶Šç•Œï¼‰ | `size_t i` | `T&`     | O(1)       |
| `at(i)`         | ä¸‹æ ‡è®¿é—®ï¼ˆæ£€æŸ¥è¶Šç•Œï¼‰   | `size_t i` | `T&`     | O(1)       |
| `front()`       | è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´          | æ—          | `T&`     | O(1)       |
| `back()`        | è¿”å›æœ€åä¸€ä¸ªå…ƒç´        | æ—          | `T&`     | O(1)       |

------

**ğŸ“Œ 3. å°¾éƒ¨æ’å…¥ / åˆ é™¤**

| å‡½æ•°                    | ä½œç”¨         | å‚æ•°         | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| ----------------------- | ------------ | ------------ | -------- | ---------- |
| `push_back(x)`          | å°¾éƒ¨æ’å…¥     | `const T& x` | `void`   | å‡æ‘Š O(1)  |
| `emplace_back(args...)` | å°¾éƒ¨åŸåœ°æ„é€  | æ„é€ å‚æ•°     | `void`   | å‡æ‘Š O(1)  |
| `pop_back()`            | åˆ é™¤æœ€åä¸€ä¸ª | æ—            | `void`   | O(1)       |

------

**ğŸ“Œ 4. ä»»æ„ä½ç½®æ’å…¥ / åˆ é™¤ï¼ˆæ¶‰åŠç§»åŠ¨å…ƒç´ ï¼‰**

| å‡½æ•°             | ä½œç”¨              | å‚æ•°                       | è¿”å›ç±»å‹   | æ—¶é—´å¤æ‚åº¦ |
| ---------------- | ----------------- | -------------------------- | ---------- | ---------- |
| `insert(pos, x)` | åœ¨ pos å‰æ’å…¥ x   | `iterator pos, const T& x` | `iterator` | O(n)       |
| `erase(pos)`     | åˆ é™¤ pos ä½ç½®å…ƒç´  | `iterator pos`             | `iterator` | O(n)       |
| `erase(l, r)`    | åˆ é™¤åŒºé—´ [l, r)   | `iterator l, iterator r`   | `iterator` | O(n)       |

------

**ğŸ“Œ 5. ä¿®æ”¹å¤§å°**

| å‡½æ•°           | ä½œç”¨                | å‚æ•°                   | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| -------------- | ------------------- | ---------------------- | -------- | ---------- |
| `resize(n)`    | è°ƒæ•´å¤§å°ä¸º n        | `size_t n`             | `void`   | O(n)       |
| `resize(n, x)` | è°ƒæ•´å¤§å°å¹¶ç”¨ x å¡«å…… | `size_t n, const T& x` | `void`   | O(n)       |
| `assign(n, x)` | å˜æˆ n ä¸ª x         | `size_t n, const T& x` | `void`   | O(n)       |

------

**ğŸ“Œ 6. è¿­ä»£å™¨**

| å‡½æ•°       | ä½œç”¨           | å‚æ•° | è¿”å›ç±»å‹           | æ—¶é—´å¤æ‚åº¦ |
| ---------- | -------------- | ---- | ------------------ | ---------- |
| `begin()`  | è¿”å›èµ·å§‹è¿­ä»£å™¨ | æ—    | `iterator`         | O(1)       |
| `end()`    | è¿”å›å°¾åè¿­ä»£å™¨ | æ—    | `iterator`         | O(1)       |
| `rbegin()` | åå‘èµ·å§‹è¿­ä»£å™¨ | æ—    | `reverse_iterator` | O(1)       |
| `rend()`   | åå‘å°¾åè¿­ä»£å™¨ | æ—    | `reverse_iterator` | O(1)       |

------

**ğŸ“Œ 7. è¾…åŠ©ç®—æ³•ï¼ˆæ¥è‡ª `<algorithm>`ï¼‰**

è™½ç„¶ä¸å±äº vector æˆå‘˜å‡½æ•°ï¼Œä½†å‡ ä¹æ€»æ˜¯é…å¥—ä½¿ç”¨ï¼š

| å‡½æ•°                         | ä½œç”¨           | å‚æ•°        | è¿”å›ç±»å‹   | æ—¶é—´å¤æ‚åº¦ |
| ---------------------------- | -------------- | ----------- | ---------- | ---------- |
| `sort(begin, end)`           | æ’åº           | ä¸¤ä¸ªè¿­ä»£å™¨  | æ—          | O(n log n) |
| `unique(begin, end)`         | å»é‡ï¼ˆéœ€æ’åºï¼‰ | ä¸¤ä¸ªè¿­ä»£å™¨  | `iterator` | O(n)       |
| `lower_bound(begin, end, x)` | ç¬¬ä¸€ä¸ª â‰¥ x     | è¿­ä»£å™¨ + å€¼ | `iterator` | O(log n)   |
| `upper_bound(begin, end, x)` | ç¬¬ä¸€ä¸ª > x     | è¿­ä»£å™¨ + å€¼ | `iterator` | O(log n)   |

### stack

| å‡½æ•°               | ä½œç”¨                     | å‚æ•°                   | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| ------------------ | ------------------------ | ---------------------- | -------- | ---------- |
| `push(x)`          | å°†å…ƒç´ å‹å…¥æ ˆé¡¶           | `const T& x`ï¼ˆæˆ–å³å€¼ï¼‰ | `void`   | O(1)       |
| `pop()`            | åˆ é™¤æ ˆé¡¶å…ƒç´              | æ—                      | `void`   | O(1)       |
| `top()`            | è·å–æ ˆé¡¶å…ƒç´ ï¼ˆä¸åˆ é™¤ï¼‰   | æ—                      | `T&`     | O(1)       |
| `empty()`          | åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º           | æ—                      | `bool`   | O(1)       |
| `size()`           | è¿”å›å…ƒç´ æ•°é‡             | æ—                      | `size_t` | O(1)       |
| `emplace(args...)` | åŸåœ°æ„é€ ä¸€ä¸ªæ–°å…ƒç´ åˆ°æ ˆé¡¶ | æ„é€ å‚æ•°               | `void`   | O(1)       |

### queue

| å‡½æ•°               | ä½œç”¨                 | å‚æ•°         | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| ------------------ | -------------------- | ------------ | -------- | ---------- |
| `push(x)`          | å…¥é˜Ÿï¼ˆå°¾éƒ¨åŠ å…¥ï¼‰     | `const T& x` | `void`   | O(1)       |
| `pop()`            | å‡ºé˜Ÿï¼ˆä»å¤´éƒ¨åˆ é™¤ï¼‰   | æ—            | `void`   | O(1)       |
| `front()`          | è®¿é—®é˜Ÿå¤´å…ƒç´          | æ—            | `T&`     | O(1)       |
| `back()`           | è®¿é—®é˜Ÿå°¾å…ƒç´          | æ—            | `T&`     | O(1)       |
| `empty()`          | åˆ¤æ–­æ˜¯å¦ä¸ºç©º         | æ—            | `bool`   | O(1)       |
| `size()`           | å…ƒç´ æ•°é‡             | æ—            | `size_t` | O(1)       |
| `emplace(args...)` | åŸåœ°æ„é€ æ–°å…ƒç´ åˆ°é˜Ÿå°¾ | æ„é€ å‚æ•°     | `void`   | O(1)       |

------

### deque

| å‡½æ•°             | ä½œç”¨                 | å‚æ•°                       | è¿”å›ç±»å‹   | æ—¶é—´å¤æ‚åº¦ |
| ---------------- | -------------------- | -------------------------- | ---------- | ---------- |
| `push_back(x)`   | å°¾éƒ¨åŠ å…¥å…ƒç´          | `const T& x`               | `void`     | O(1)       |
| `push_front(x)`  | å¤´éƒ¨åŠ å…¥å…ƒç´          | `const T& x`               | `void`     | O(1)       |
| `pop_back()`     | åˆ é™¤å°¾éƒ¨å…ƒç´          | æ—                          | `void`     | O(1)       |
| `pop_front()`    | åˆ é™¤å¤´éƒ¨å…ƒç´          | æ—                          | `void`     | O(1)       |
| `front()`        | è®¿é—®å¤´å…ƒç´            | æ—                          | `T&`       | O(1)       |
| `back()`         | è®¿é—®å°¾å…ƒç´            | æ—                          | `T&`       | O(1)       |
| `operator[](i)`  | ä¸‹æ ‡è®¿é—®             | `size_t i`                 | `T&`       | O(1)       |
| `at(i)`          | ä¸‹æ ‡è®¿é—®ï¼ˆæ£€æŸ¥è¶Šç•Œï¼‰ | `size_t i`                 | `T&`       | O(1)       |
| `empty()`        | æ˜¯å¦ä¸ºç©º             | æ—                          | `bool`     | O(1)       |
| `size()`         | å…ƒç´ æ•°é‡             | æ—                          | `size_t`   | O(1)       |
| `clear()`        | æ¸…ç©º                 | æ—                          | `void`     | O(n)       |
| `insert(pos, x)` | åœ¨ pos å‰æ’å…¥        | `iterator pos, const T& x` | `iterator` | O(n)       |
| `erase(pos)`     | åˆ é™¤ pos å…ƒç´         | `iterator pos`             | `iterator` | O(n)       |

------

### priority_queue

é»˜è®¤æ˜¯ **å¤§æ ¹å †**ï¼ˆæœ€å¤§å€¼ä¼˜å…ˆï¼‰ã€‚

| å‡½æ•°               | ä½œç”¨                   | å‚æ•°         | è¿”å›ç±»å‹   | æ—¶é—´å¤æ‚åº¦ |
| ------------------ | ---------------------- | ------------ | ---------- | ---------- |
| `push(x)`          | æ’å…¥å…ƒç´                | `const T& x` | `void`     | O(log n)   |
| `pop()`            | åˆ é™¤å †é¡¶å…ƒç´            | æ—            | `void`     | O(log n)   |
| `top()`            | è®¿é—®å †é¡¶å…ƒç´ ï¼ˆæœ€å¤§å€¼ï¼‰ | æ—            | `const T&` | O(1)       |
| `empty()`          | åˆ¤æ–­æ˜¯å¦ä¸ºç©º           | æ—            | `bool`     | O(1)       |
| `size()`           | å…ƒç´ æ•°é‡               | æ—            | `size_t`   | O(1)       |
| `emplace(args...)` | åŸåœ°æ„é€ æ–°å…ƒç´          | æ„é€ å‚æ•°     | `void`     | O(log n)   |

```cpp
//è‡ªå®šä¹‰æ¯”è¾ƒå™¨
struct Node {
    int x, y;
};
struct cmp {
    bool operator()(const Node& a, const Node& b) const {
        return a.x > b.x; // å°çš„ä¼˜å…ˆ
    }
};
priority_queue<Node, vector<Node>, cmp> pq;
//å°æ ¹å †
priority_queue<int, vector<int>, greater<int>> pq;
```

ä¼˜å…ˆé˜Ÿåˆ—æ˜¯æ¯æ¬¡æ‹¿å¼€å¤´çš„å…ƒç´ ï¼Œæ‰€ä»¥å¤§å°æ ¹å †æ˜¯åè¿‡æ¥çš„ã€‚

ä¼˜å…ˆé˜Ÿåˆ—æ²¡æœ‰clearçš„æ–¹æ³•æœ›å‘¨çŸ¥

ä¸‹é¢ç»™ä½  **`map` / `unordered_map` / `multimap`** çš„æ“ä½œå‡½æ•°è¡¨æ ¼ + å®ƒä»¬ä¹‹é—´çš„åŒºåˆ«æ€»ç»“ã€‚
 å†…å®¹éå¸¸å®Œæ•´ï¼Œæ ¼å¼æ¸…æ™°ï¼Œå¯ä»¥ç›´æ¥ä½œä¸ºä½ çš„è€ƒè¯•æ¿å­ä½¿ç”¨ã€‚

### map

| å‡½æ•°               | ä½œç”¨                  | å‚æ•°       | è¿”å›ç±»å‹              | æ—¶é—´å¤æ‚åº¦ |
| ------------------ | --------------------- | ---------- | --------------------- | ---------- |
| `m[key]`           | è®¿é—®/æ’å…¥é”®           | `key`      | `T&`                  | O(log n)   |
| `at(key)`          | è®¿é—®é”®ï¼ˆä¸å­˜åœ¨æŠ¥é”™ï¼‰  | `key`      | `T&`                  | O(log n)   |
| `insert({k,v})`    | æ’å…¥é”®å€¼å¯¹            | `pair`     | `pair<iterator,bool>` | O(log n)   |
| `erase(key)`       | æŒ‰é”®åˆ é™¤              | `key`      | `size_t`              | O(log n)   |
| `erase(it)`        | åˆ é™¤è¿­ä»£å™¨ä½ç½®        | `iterator` | `iterator`            | O(log n)   |
| `find(key)`        | æŸ¥æ‰¾é”®                | `key`      | `iterator`            | O(log n)   |
| `count(key)`       | åˆ¤æ–­é”®å‡ºç°æ¬¡æ•°        | `key`      | `size_t` (0æˆ–1)       | O(log n)   |
| `lower_bound(key)` | ç¬¬ä¸€ä¸ª â‰¥ key          | `key`      | `iterator`            | O(log n)   |
| `upper_bound(key)` | ç¬¬ä¸€ä¸ª > key          | `key`      | `iterator`            | O(log n)   |
| `begin()`          | å·¦ç«¯è¿­ä»£å™¨ï¼ˆæœ€å°keyï¼‰ | æ—          | `iterator`            | O(1)       |
| `end()`            | å°¾åè¿­ä»£å™¨            | æ—          | `iterator`            | O(1)       |
| `empty()`          | æ˜¯å¦ä¸ºç©º              | æ—          | `bool`                | O(1)       |
| `size()`           | é”®å€¼å¯¹æ•°              | æ—          | `size_t`              | O(1)       |
| `clear()`          | æ¸…ç©º                  | æ—          | `void`                | O(n)       |
| `emplace(k,v)`     | åŸåœ°æ„é€ æ’å…¥          | æ„é€ å‚æ•°   | `pair<iterator,bool>` | O(log n)   |

------

### unordered_map

| å‡½æ•°             | ä½œç”¨           | å‚æ•°     | è¿”å›ç±»å‹              | æ—¶é—´å¤æ‚åº¦ |
| ---------------- | -------------- | -------- | --------------------- | ---------- |
| `m[key]`         | è®¿é—®/æ’å…¥é”®    | `key`    | `T&`                  | O(1) å¹³å‡  |
| `insert({k,v})`  | æ’å…¥é”®å€¼å¯¹     | `pair`   | `pair<iterator,bool>` | O(1) å¹³å‡  |
| `erase(key)`     | åˆ é™¤é”®         | `key`    | `size_t`              | O(1) å¹³å‡  |
| `find(key)`      | æŸ¥æ‰¾é”®         | `key`    | `iterator`            | O(1) å¹³å‡  |
| `count(key)`     | åˆ¤æ–­é”®æ˜¯å¦å­˜åœ¨ | `key`    | `size_t`              | O(1) å¹³å‡  |
| `begin()`        | è¿”å›è¿­ä»£å™¨     | æ—        | `iterator`            | O(1)       |
| `end()`          | å°¾åè¿­ä»£å™¨     | æ—        | `iterator`            | O(1)       |
| `bucket_count()` | å“ˆå¸Œæ¡¶æ•°é‡     | æ—        | `size_t`              | O(1)       |
| `rehash(n)`      | è°ƒæ•´æ¡¶æ•°é‡     | `size_t` | `void`                | O(n)       |
| `load_factor()`  | è£…è½½å› å­       | æ—        | `float`               | O(1)       |

**æ³¨æ„ï¼šunordered_map æ— åº â†’ ä¸èƒ½ç”¨ lower_bound / upper_bound**

### multimap

| å‡½æ•°               | ä½œç”¨                     | å‚æ•°   | è¿”å›ç±»å‹      | æ—¶é—´å¤æ‚åº¦     |
| ------------------ | ------------------------ | ------ | ------------- | -------------- |
| `insert({k,v})`    | æ’å…¥å…ƒç´ ï¼ˆå…è®¸é‡å¤ keyï¼‰ | `pair` | `iterator`    | O(log n)       |
| `erase(key)`       | åˆ é™¤æ‰€æœ‰è¯¥ key çš„å…ƒç´     | `key`  | `size_t`      | O(log n + cnt) |
| `find(key)`        | è¿”å›æŸä¸ª key çš„ä¸€ä¸ªä½ç½®  | `key`  | `iterator`    | O(log n)       |
| `count(key)`       | key å‡ºç°æ¬¡æ•°             | `key`  | `size_t`      | O(log n + cnt) |
| `lower_bound(key)` | ç¬¬ä¸€ä¸ª â‰¥ key             | `key`  | `iterator`    | O(log n)       |
| `upper_bound(key)` | ç¬¬ä¸€ä¸ª > key             | `key`  | `iterator`    | O(log n)       |
| `equal_range(key)` | è¿”å› [lower, upper) èŒƒå›´ | `key`  | `pair<it,it>` | O(log n)       |

multimap ä¸ map å‡ ä¹ä¸€æ ·ï¼Œåªä¸è¿‡ map æ˜¯å”¯ä¸€é”®ï¼Œmultimap èƒ½å­˜é‡å¤é”®ã€‚

------

 **å››ã€ä¸‰ä¸ª map ä¹‹é—´çš„åŒºåˆ«ï¼ˆè¶…æ¸…æ™°æ€»ç»“ï¼‰**

| å®¹å™¨            | æ˜¯å¦æœ‰åº            | æ˜¯å¦å…è®¸é‡å¤ key | åº•å±‚ç»“æ„ | æŸ¥æ‰¾å¤æ‚åº¦ | æ’å…¥å¤æ‚åº¦ |
| --------------- | ------------------- | ---------------- | -------- | ---------- | ---------- |
| `map`           | æœ‰åºï¼ˆæŒ‰ key æ’åºï¼‰ | âŒ ä¸å…è®¸         | çº¢é»‘æ ‘   | O(log n)   | O(log n)   |
| `unordered_map` | æ— åº                | âŒ ä¸å…è®¸         | å“ˆå¸Œè¡¨   | O(1) å¹³å‡  | O(1) å¹³å‡  |
| `multimap`      | æœ‰åº                | âœ” å…è®¸           | çº¢é»‘æ ‘   | O(log n)   | O(log n)   |

------

**ä½¿ç”¨åœºæ™¯æ€»ç»“**

| åœºæ™¯                             | ç”¨ä»€ä¹ˆ              | åŸå›              |
| -------------------------------- | ------------------- | ---------------- |
| æŸ¥æ‰¾é¢‘ç¹ã€å¯¹é¡ºåºæ— è¦æ±‚           | `unordered_map`     | O(1) å¹³å‡        |
| éœ€è¦é”®æœ‰åºï¼ˆå¦‚å­—å…¸åºã€åŒºé—´æŸ¥è¯¢ï¼‰ | `map`               | æ”¯æŒ lower_bound |
| éœ€è¦å­˜å‚¨é‡å¤ key                 | `multimap`          | map ä¸å…è®¸       |
| éœ€è¦ lower_bound/upper_bound     | `map` æˆ– `multimap` | å“ˆå¸Œè¡¨ä¸æ”¯æŒ     |

### set

ğŸ“Œ `std::set`ï¼ˆçº¢é»‘æ ‘ã€æœ‰åºã€å”¯ä¸€å…ƒç´ ï¼‰

ğŸ“Œ `std::multiset`ï¼ˆçº¢é»‘æ ‘ã€æœ‰åºã€å¯é‡å¤å…ƒç´ ï¼‰

ğŸ“Œ `std::unordered_set`ï¼ˆå“ˆå¸Œè¡¨ã€æ— åºã€å”¯ä¸€å…ƒç´ ï¼‰

------

**1. æ„é€ ã€åŸºæœ¬ä¿¡æ¯**

`set` / `multiset`

| å‡½æ•°      | åŠŸèƒ½         | å‚æ•° | è¿”å›ç±»å‹ | æ—¶é—´å¤æ‚åº¦ |
| --------- | ------------ | ---- | -------- | ---------- |
| `set()`   | æ„é€ ç©º set   | æ—    | -        | O(1)       |
| `size()`  | è¿”å›å…ƒç´ æ•°é‡ | æ—    | `size_t` | O(1)       |
| `empty()` | åˆ¤æ–­æ˜¯å¦ä¸ºç©º | æ—    | `bool`   | O(1)       |
| `clear()` | æ¸…ç©ºæ‰€æœ‰å…ƒç´  | æ—    | `void`   | O(n)       |

`unordered_set`

åŒä¸Šï¼Œä½† `clear()` å¹³å‡ O(n)ï¼Œæœ€å O(n)ã€‚

------

**2. æ’å…¥ç›¸å…³**

`set` / `multiset`

| å‡½æ•°               | åŠŸèƒ½         | å‚æ•°     | è¿”å›ç±»å‹                                              | æ—¶é—´å¤æ‚åº¦ |
| ------------------ | ------------ | -------- | ----------------------------------------------------- | ---------- |
| `insert(x)`        | æ’å…¥å…ƒç´      | å…ƒç´ å€¼   | `pair<iterator,bool>`ï¼ˆsetï¼‰ / `iterator`ï¼ˆmultisetï¼‰ | O(log n)   |
| `emplace(args...)` | åŸåœ°æ„é€ å…ƒç´  | æ„é€ å‚æ•° | åŒ insert                                             | O(log n)   |

`unordered_set`

| å‡½æ•°                      | å¹³å‡å¤æ‚åº¦ | æœ€åå¤æ‚åº¦ |
| ------------------------- | ---------- | ---------- |
| `insert(x)` / `emplace()` | O(1)       | O(n)       |

------

**3. åˆ é™¤ç›¸å…³**

`set` / `multiset`

| å‡½æ•°          | åŠŸèƒ½                 | å‚æ•°       | è¿”å›ç±»å‹                 | æ—¶é—´å¤æ‚åº¦          |
| ------------- | -------------------- | ---------- | ------------------------ | ------------------- |
| `erase(x)`    | åˆ é™¤å€¼ä¸º x çš„å…ƒç´     | å€¼ x       | `size_t`ï¼ˆåˆ é™¤çš„æ•°é‡ï¼‰   | O(log n)            |
| `erase(it)`   | åˆ é™¤è¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´  | è¿­ä»£å™¨     | `iterator`ï¼ˆä¸‹ä¸€ä¸ªä½ç½®ï¼‰ | O(log n)            |
| `erase(l, r)` | åˆ é™¤åŒºé—´             | è¿­ä»£å™¨åŒºé—´ | `iterator`               | O(distance Ã— log n) |

`unordered_set`

åŒåå‡½æ•°ï¼Œä½†å¹³å‡ O(1)ï¼Œæœ€å O(n)ã€‚

------

**4. æŸ¥æ‰¾ä¸è®¿é—®**

`set` / `multiset`

| å‡½æ•°             | åŠŸèƒ½                             | å‚æ•° | è¿”å›ç±»å‹                  | æ—¶é—´å¤æ‚åº¦ |
| ---------------- | -------------------------------- | ---- | ------------------------- | ---------- |
| `find(x)`        | æŸ¥æ‰¾å€¼ä¸º x çš„è¿­ä»£å™¨              | å€¼ x | `iterator`                | O(log n)   |
| `count(x)`       | è¿”å› x å‡ºç°æ¬¡æ•°ï¼ˆmultiset å¯>1ï¼‰ | å€¼ x | `size_t`                  | O(log n)   |
| `lower_bound(x)` | ç¬¬ä¸€ä¸ª >= x çš„è¿­ä»£å™¨             | x    | `iterator`                | O(log n)   |
| `upper_bound(x)` | ç¬¬ä¸€ä¸ª > x çš„è¿­ä»£å™¨              | x    | `iterator`                | O(log n)   |
| `equal_range(x)` | è¿”å› [lower, upper]              | x    | `pair<iterator,iterator>` | O(log n)   |

`unordered_set`

| å‡½æ•°             | åŠŸèƒ½               | å¹³å‡å¤æ‚åº¦ | æœ€åå¤æ‚åº¦ |
| ---------------- | ------------------ | ---------- | ---------- |
| `find(x)`        | æŸ¥æ‰¾å…ƒç´            | O(1)       | O(n)       |
| `count(x)`       | ç­‰ä»·äºæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ | O(1)       | O(n)       |
| `equal_range(x)` | é€šå¸¸å¯ä¸ç”¨         | O(1)       | O(n)       |

------

**5. è¿­ä»£å™¨æ“ä½œ**

`set` / `multiset`

| å‡½æ•°       | åŠŸèƒ½           | è¿”å›ç±»å‹         | æ—¶é—´å¤æ‚åº¦ |
| ---------- | -------------- | ---------------- | ---------- |
| `begin()`  | æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´  | iterator         | O(1)       |
| `end()`    | å°¾å           | iterator         | O(1)       |
| `rbegin()` | åå‘ç¬¬ä¸€ä¸ª     | reverse_iterator | O(1)       |
| `rend()`   | åå‘å°¾å       | reverse_iterator | O(1)       |

`unordered_set`

è¿­ä»£å™¨æ— åºï¼Œä¸æ”¯æŒ rbegin/rendã€‚

------

**6. å…¶å®ƒå‡½æ•°**

`unordered_set` ç‰¹æœ‰

| å‡½æ•°             | åŠŸèƒ½       | æ—¶é—´å¤æ‚åº¦ |
| ---------------- | ---------- | ---------- |
| `bucket_count()` | å½“å‰æ¡¶æ•°é‡ | O(1)       |
| `load_factor()`  | è£…è½½å› å­   | O(1)       |
| `rehash(n)`      | è°ƒæ•´æ¡¶æ•°   | O(n)       |

------

å„ä¸ª set çš„åŒºåˆ«æ€»ç»“

| å®¹å™¨            | åº•å±‚ç»“æ„ | æ˜¯å¦æœ‰åº | æ˜¯å¦å…è®¸é‡å¤ | æ’å…¥/æŸ¥æ‰¾ | é€‚ç”¨åœºæ™¯         |
| --------------- | -------- | -------- | ------------ | --------- | ---------------- |
| `set`           | çº¢é»‘æ ‘   | âœ” æœ‰åº   | âœ˜ ä¸å…è®¸     | O(log n)  | æœ‰åºã€ä¸é‡å¤     |
| `multiset`      | çº¢é»‘æ ‘   | âœ” æœ‰åº   | âœ” å…è®¸       | O(log n)  | æœ‰åºã€å…è®¸é‡å¤   |
| `unordered_set` | å“ˆå¸Œè¡¨   | âœ˜ æ— åº   | âœ˜ ä¸å…è®¸     | å¹³å‡ O(1) | æ— åºã€é«˜æ€§èƒ½æŸ¥æ‰¾ |

### é“¾è¡¨é¢˜æ¨¡æ¿

```cpp
class node{
    public:
    int add,data,next;
};//èŠ‚ç‚¹å®šä¹‰
unordered_map<int,node> a;
int beginn,n;//è¾“å…¥çš„å¼€å§‹èŠ‚ç‚¹ï¼Œæ€»å…±èŠ‚ç‚¹
node r;
int main(){
    cin>>beginn>>n;
    while (n--){
       cin>>r.add>>r.data>>r.next;
       a[r.add]=r;
    }//è¾“å…¥æ•°æ®ï¼Œç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ˜ å°„
    while(beginn!=-1){
       d.push_back(a[beginn]);
       beginn=a[beginn].next;
    }//dæ˜¯ä½ é€‰æ‹©çš„é€‚åˆé¢˜ç›®çš„å®¹å™¨ï¼ŒæŠŠéè¿ç»­å†…å­˜å¹²æˆè¿ç»­çš„
    //...//å…·ä½“æ“ä½œè¿‡ç¨‹ï¼Œå› é¢˜è€Œå¼‚
    vector<node> ans;
    for (int i=0;i<(int)ans.size();i++){
        if (i!=ans.size()-1){
            ans[i].next=ans[i+1].add;
        }else{
            ans[i].next=-1;
        }
    }//ä¿®æ”¹èŠ‚ç‚¹åœ°å€ï¼Œä¸æ”¹ä¼šå…¨éƒ¨WA
    for (auto &it:ans){
        printf("%05d %d ",it.add,it.data);
        if (it.next != -1)
            printf("%05d\n",it.next);
        else
            printf("-1\n");
    }//PATæ ‡å‡†è¾“å‡º
}
```

## äºŒå‰æ ‘

### 1. äºŒå‰æ ‘åŸºæœ¬æ¦‚å¿µ

**äºŒå‰æ ‘**æ˜¯æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æ ‘ç»“æ„ï¼š

- å·¦å­èŠ‚ç‚¹ï¼ˆleft childï¼‰
- å³å­èŠ‚ç‚¹ï¼ˆright childï¼‰

**ç‰¹æ®Šç±»å‹**ï¼š

- æ»¡äºŒå‰æ ‘ï¼šæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰0æˆ–2ä¸ªå­èŠ‚ç‚¹
- å®Œå…¨äºŒå‰æ ‘ï¼šé™¤æœ€åä¸€å±‚å¤–ï¼Œå…¶ä»–å±‚éƒ½æ˜¯æ»¡çš„ï¼Œä¸”æœ€åä¸€å±‚èŠ‚ç‚¹é å·¦æ’åˆ—
- äºŒå‰æœç´¢æ ‘ï¼šå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å€¼ < æ ¹èŠ‚ç‚¹å€¼ < å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å€¼

### 2. äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰c
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### 3. äºŒå‰æ ‘çš„å»ºç«‹

#### 3.1 é€’å½’å»ºç«‹äºŒå‰æ ‘

```cpp
// æ ¹æ®æ•°ç»„é€’å½’å»ºç«‹äºŒå‰æ ‘ï¼ˆ-1è¡¨ç¤ºç©ºèŠ‚ç‚¹ï¼‰
TreeNode* createTree(const vector<int>& nodes, int& index) {
    if (index >= nodes.size() || nodes[index] == -1) {
        index++;
        return nullptr;
    }
    
    TreeNode* root = new TreeNode(nodes[index++]);
    root->left = createTree(nodes, index);
    root->right = createTree(nodes, index);
    
    return root;
}

// ä½¿ç”¨ç¤ºä¾‹
void demoCreateTree() {
    vector<int> nodes = {1, 2, 4, -1, -1, 5, -1, -1, 3, -1, 6, -1, -1};
    int index = 0;
    TreeNode* root = createTree(nodes, index);
    cout << "äºŒå‰æ ‘åˆ›å»ºå®Œæˆ" << endl;
}
```

#### 3.2 å±‚æ¬¡éå†å»ºç«‹äºŒå‰æ ‘

```cpp
// æ ¹æ®å±‚æ¬¡éå†åºåˆ—å»ºç«‹äºŒå‰æ ‘
TreeNode* createTreeLevelOrder(const vector<int>& nodes) {
    if (nodes.empty() || nodes[0] == -1) return nullptr;
    
    TreeNode* root = new TreeNode(nodes[0]);
    queue<TreeNode*> q;
    q.push(root);
    
    int i = 1;
    while (!q.empty() && i < nodes.size()) {
        TreeNode* current = q.front();
        q.pop();
        
        // å·¦å­èŠ‚ç‚¹
        if (i < nodes.size() && nodes[i] != -1) {
            current->left = new TreeNode(nodes[i]);
            q.push(current->left);
        }
        i++;
        
        // å³å­èŠ‚ç‚¹
        if (i < nodes.size() && nodes[i] != -1) {
            current->right = new TreeNode(nodes[i]);
            q.push(current->right);
        }
        i++;
    }
    
    return root;
}
```

### 4. äºŒå‰æ ‘çš„éå†

#### 4.1 æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰

```cpp
// å‰åºéå†ï¼šæ ¹->å·¦->å³
void preorderTraversal(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// ä¸­åºéå†ï¼šå·¦->æ ¹->å³
void inorderTraversal(TreeNode* root) {
    if (!root) return;
    inorderTraversal(root->left);
    cout << root->val << " ";
    inorderTraversal(root->right);
}

// ååºéå†ï¼šå·¦->å³->æ ¹
void postorderTraversal(TreeNode* root) {
    if (!root) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->val << " ";
}
```

#### 4.2 å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰

```cpp
// å±‚æ¬¡éå†
void levelOrderTraversal(TreeNode* root) {
    if (!root) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* current = q.front();
        q.pop();
        cout << current->val << " ";
        
        if (current->left) q.push(current->left);
        if (current->right) q.push(current->right);
    }
}
```

#### 4.3 è¿­ä»£å®ç°éå†

```cpp
// è¿­ä»£å‰åºéå†
void preorderIterative(TreeNode* root) {
    if (!root) return;
    
    stack<TreeNode*> st;
    st.push(root);
    
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        cout << node->val << " ";
        
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
}

// è¿­ä»£ä¸­åºéå†
void inorderIterative(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* curr = root;
    
    while (curr || !st.empty()) {
        while (curr) {
            st.push(curr);
            curr = curr->left;
        }
        
        curr = st.top();
        st.pop();
        cout << curr->val << " ";
        curr = curr->right;
    }
}
```

### 5. äºŒå‰æ ‘åŸºæœ¬æ“ä½œ

```cpp
// è®¡ç®—èŠ‚ç‚¹ä¸ªæ•°
int countNodes(TreeNode* root) {
    if (!root) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// è®¡ç®—æ ‘çš„é«˜åº¦
int getHeight(TreeNode* root) {
    if (!root) return 0;
    return 1 + max(getHeight(root->left), getHeight(root->right));
}

// æŸ¥æ‰¾èŠ‚ç‚¹
bool findNode(TreeNode* root, int target) {
    if (!root) return false;
    if (root->val == target) return true;
    return findNode(root->left, target) || findNode(root->right, target);
}

// é•œåƒç¿»è½¬äºŒå‰æ ‘
TreeNode* mirrorTree(TreeNode* root) {
    if (!root) return nullptr;
    
    TreeNode* temp = root->left;
    root->left = mirrorTree(root->right);
    root->right = mirrorTree(temp);
    
    return root;
}
```

### 6. å®Œæ•´ç¤ºä¾‹

```cpp
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BinaryTree {
private:
    TreeNode* root;
    
public:
    BinaryTree() : root(nullptr) {}
    
    // æ ¹æ®æ•°ç»„å»ºç«‹äºŒå‰æ ‘
    void buildTree(const vector<int>& nodes) {
        int index = 0;
        root = createTree(nodes, index);
    }
    
    // é€’å½’å»ºç«‹äºŒå‰æ ‘
    TreeNode* createTree(const vector<int>& nodes, int& index) {
        if (index >= nodes.size() || nodes[index] == -1) {
            index++;
            return nullptr;
        }
        
        TreeNode* node = new TreeNode(nodes[index++]);
        node->left = createTree(nodes, index);
        node->right = createTree(nodes, index);
        
        return node;
    }
    
    // éå†æ–¹æ³•
    void preorder() {
        cout << "å‰åºéå†: ";
        preorderTraversal(root);
        cout << endl;
    }
    
    void inorder() {
        cout << "ä¸­åºéå†: ";
        inorderTraversal(root);
        cout << endl;
    }
    
    void postorder() {
        cout << "ååºéå†: ";
        postorderTraversal(root);
        cout << endl;
    }
    
    void levelOrder() {
        cout << "å±‚æ¬¡éå†: ";
        levelOrderTraversal(root);
        cout << endl;
    }
    
    // å·¥å…·æ–¹æ³•
    int getNodeCount() {
        return countNodes(root);
    }
    
    int getHeight() {
        return getHeight(root);
    }
    
    bool contains(int target) {
        return findNode(root, target);
    }
    
private:
    // é€’å½’éå†å®ç°
    void preorderTraversal(TreeNode* node) {
        if (!node) return;
        cout << node->val << " ";
        preorderTraversal(node->left);
        preorderTraversal(node->right);
    }
    
    void inorderTraversal(TreeNode* node) {
        if (!node) return;
        inorderTraversal(node->left);
        cout << node->val << " ";
        inorderTraversal(node->right);
    }
    
    void postorderTraversal(TreeNode* node) {
        if (!node) return;
        postorderTraversal(node->left);
        postorderTraversal(node->right);
        cout << node->val << " ";
    }
    
    void levelOrderTraversal(TreeNode* node) {
        if (!node) return;
        
        queue<TreeNode*> q;
        q.push(node);
        
        while (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();
            cout << current->val << " ";
            
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
    }
    
    int countNodes(TreeNode* node) {
        if (!node) return 0;
        return 1 + countNodes(node->left) + countNodes(node->right);
    }
    
    int getHeight(TreeNode* node) {
        if (!node) return 0;
        return 1 + max(getHeight(node->left), getHeight(node->right));
    }
    
    bool findNode(TreeNode* node, int target) {
        if (!node) return false;
        if (node->val == target) return true;
        return findNode(node->left, target) || findNode(node->right, target);
    }
};

int main() {
    BinaryTree tree;
    
    // å»ºç«‹äºŒå‰æ ‘ï¼šä½¿ç”¨-1è¡¨ç¤ºç©ºèŠ‚ç‚¹
    // äºŒå‰æ ‘ç»“æ„ï¼š
    //       1
    //      / \
    //     2   3
    //    / \   \
    //   4   5   6
    vector<int> nodes = {1, 2, 4, -1, -1, 5, -1, -1, 3, -1, 6, -1, -1};
    tree.buildTree(nodes);
    
    // éå†æµ‹è¯•
    tree.preorder();
    tree.inorder();
    tree.postorder();
    tree.levelOrder();
    
    // åŸºæœ¬æ“ä½œæµ‹è¯•
    cout << "èŠ‚ç‚¹ä¸ªæ•°: " << tree.getNodeCount() << endl;
    cout << "æ ‘çš„é«˜åº¦: " << tree.getHeight() << endl;
    cout << "æ˜¯å¦åŒ…å«5: " << (tree.contains(5) ? "æ˜¯" : "å¦") << endl;
    cout << "æ˜¯å¦åŒ…å«7: " << (tree.contains(7) ? "æ˜¯" : "å¦") << endl;
    
    return 0;
}
```

### 7. è¾“å‡ºç»“æœ

```cpp
å‰åºéå†: 1 2 4 5 3 6 
ä¸­åºéå†: 4 2 5 1 3 6 
ååºéå†: 4 5 2 6 3 1 
å±‚æ¬¡éå†: 1 2 3 4 5 6 
èŠ‚ç‚¹ä¸ªæ•°: 6
æ ‘çš„é«˜åº¦: 3
æ˜¯å¦åŒ…å«5: æ˜¯
æ˜¯å¦åŒ…å«7: å¦
```

### 8. å…³é”®è¦ç‚¹æ€»ç»“

1. **äºŒå‰æ ‘å®šä¹‰**ï¼šæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
2. **éå†æ–¹å¼**ï¼š æ·±åº¦ä¼˜å…ˆï¼šå‰åºã€ä¸­åºã€ååº å¹¿åº¦ä¼˜å…ˆï¼šå±‚æ¬¡éå†
3. **å»ºç«‹æ–¹æ³•**ï¼šé€’å½’å»ºç«‹ã€å±‚æ¬¡éå†å»ºç«‹
4. **æ—¶é—´å¤æ‚åº¦**ï¼šå¤§å¤šæ•°æ“ä½œO(n)ï¼Œnä¸ºèŠ‚ç‚¹æ•°
5. **ç©ºé—´å¤æ‚åº¦**ï¼šé€’å½’O(h)ï¼Œhä¸ºæ ‘é«˜ï¼›è¿­ä»£O(n)

## æœ€çŸ­è·¯

### Dijistraï¼ˆæœ¬è´¨è´ªå¿ƒï¼‰

```cpp
//æœªä¼˜åŒ–ç‰ˆ
#include <bits/stdc++.h>
using namespace std;
int n,m;
int v1,v2,val;
int main(){
    cin>>n>>m;
    vector<vector<int>> grid(n+1,vector<int>(n+1,INT_MAX));
    vector<int> mindist(n+1,INT_MAX);
    vector<bool> vis(n+1,false);
    for (int i=0;i<m;i++){
        cin>>v1>>v2>>val;
        grid[v1][v2]=val;
    }
    mindist[1]=0;
    for (int i=1;i<n;i++){
        int cur=-1;
        int minn=INT_MAX;
        for (int j=1;j<=n;j++){
            if (!vis[j]&&mindist[j]<minn){
                cur=j;
                minn=mindist[j];
            }
        }
        vis[cur]=true;
        for (int j=1;j<=n;j++){
            if (!vis[j]&&grid[cur][j]!=INT_MAX&&mindist[cur]+grid[cur][j]<mindist[j]){
                mindist[j]=grid[cur][j]+mindist[cur];
            }
        }
    }
    if (mindist[n]==INT_MAX){
        cout<<"-1"<<endl;
    }else{
        cout<<mindist[n]<<endl;
    }
    return 0;
}

//å †ä¼˜åŒ–ç‰ˆ
#include <bits/stdc++.h>
using namespace std;
class cmp{
    public:
    bool operator()(const pair<int,int> &a,const pair<int,int> &b){
        return a.second>b.second;
    }
};
class node{
    public:
    int to;
    int v;
};
int n,m;
int v1,v2,val;
int main(){
    cin>>n>>m;
    vector<list<node>> grid(n+1);
    for (int i=0;i<m;i++){
        cin>>v1>>v2>>val;
        grid[v1].push_back((node){v2,val});
    }
    int start=1;
    int end=n;
    vector<int> mindist(n+1,INT_MAX);
    vector<bool> vis(n+1,false);
    priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> q;
    q.push(pair<int,int>(start,0));
    mindist[start]=0;
    while (!q.empty()){
        pair<int,int> cur=q.top();
        q.pop();
        if (vis[cur.first]) continue;
        vis[cur.first]=1;
        for (auto it:grid[cur.first]){
            if (!vis[it.to]&&mindist[cur.first]+it.v<mindist[it.to]){
                mindist[it.to]=mindist[cur.first]+it.v;
                q.push(pair<int,int>(it.to,mindist[it.to]));
            }
        }
    }
    if (mindist[end]==INT_MAX){
        cout<<"-1"<<endl;
    }else{
        cout<<mindist[end]<<endl;
    }
    return 0;
}
```

å…³äºå»ºå›¾æ–¹å‘çš„é—®é¢˜

> å®Œå…¨å¯¹ âœ…ï¼Œä½ ç†è§£å¾—å¾ˆå¯¹ï¼Œæˆ‘æ¥å¸®ä½ æ•´ç†ä¸€ä¸‹æ€è·¯ï¼Œè®©è¿™ä¸ªæ¦‚å¿µå½»åº•æ¸…æ¥šï¼š
>
> ---
>
> ## 1ï¸âƒ£ èµ·ç‚¹ä¸å˜ï¼Œå»ºå›¾åªæ˜¯æ”¹å˜è¾¹çš„æ–¹å‘
>
> * **èµ·ç‚¹**ï¼šæ€»æ˜¯ä½ æƒ³ä»å“ªä¸ªèŠ‚ç‚¹å¼€å§‹è®¡ç®—â€œç´¯ç§¯è´¹ç”¨â€ï¼Œæ¯”å¦‚ï¼š
>
>   * P1342 è¯·æŸ¬ï¼šèµ·ç‚¹æ˜¯æ€»éƒ¨ 1 â†’ è®¡ç®—æ¯ä¸ªç«™ç‚¹å¾€è¿”çš„æœ€çŸ­è·¯
>   * P1576 æ‰‹ç»­è´¹ï¼šèµ·ç‚¹æ˜¯æœ€ç»ˆåˆ°è´¦çš„äºº B â†’ è®¡ç®—æ¯ä¸ªå‰é©±æœ€å°‘éœ€è¦æ”¯ä»˜çš„é’±
>
> * **å»ºå›¾æ–¹å‘**ï¼š
>
>   * æ­£å‘å›¾ï¼šè¾¹æ–¹å‘å’Œé¢˜ç›®æè¿°ä¸€è‡´
>   * åå‘å›¾ï¼šè¾¹æ–¹å‘é¢ å€’ï¼Œç”¨äºæ–¹ä¾¿è®¡ç®—æŸç§â€œé€†å‘ç´¯ç§¯â€
>
> > èµ·ç‚¹ä¸ä¼šå› ä¸ºä½ å»ºå›¾åå‘è€Œæ”¹å˜ï¼Œåªæ˜¯**åå‘å›¾è®©ä½ æ²¿è¾¹ç´¯ç§¯çš„é€»è¾‘å˜å¾—è‡ªç„¶**ã€‚
>
> ---
>
> ## 2ï¸âƒ£ å¾—åˆ°çš„å€¼ä¼šä¸åŒ
>
> * æ­£å‘å›¾ + èµ·ç‚¹ = X
>
> * åå‘å›¾ + åŒä¸€ä¸ªèµ·ç‚¹ = Y
>
> * ä¸ºä»€ä¹ˆä¸åŒï¼Ÿå› ä¸ºç´¯ç§¯é€»è¾‘ä¸åŒï¼š
>
>   * **åŠ æ³•ç´¯ç§¯**ï¼ˆP1342ï¼‰ï¼š
>
>     * æ­£å‘ï¼šdist[u] = 1 â†’ u çš„æœ€çŸ­è·¯
>     * åå‘ï¼šdist[u] = u â†’ 1 çš„æœ€çŸ­è·¯
>     * æœ€ç»ˆè¦æŠŠä¸¤è€…åŠ èµ·æ¥ â†’ å¾€è¿”è´¹ç”¨
>   * **é™¤æ³•/ä¹˜æ³•ç´¯ç§¯**ï¼ˆP1576ï¼‰ï¼š
>
>     * æ­£å‘ï¼šä» A å‡ºå‘ç´¯ç§¯æ‰‹ç»­è´¹ â†’ ä¸çŸ¥é“ B åˆ°è´¦ 100 éœ€è¦å¤šå°‘é’±
>     * åå‘ï¼šä» B å‡ºå‘ â†’ æ¯æ¡è¾¹è®¡ç®—å‰é©±æ”¯ä»˜é‡‘é¢ â†’ dist[A] å°±æ˜¯ç­”æ¡ˆ
>
> > æ‰€ä»¥ **å»ºå›¾æ–¹å‘æ”¹å˜çš„æ˜¯â€œç´¯ç§¯çš„æ–¹å‘â€**ï¼Œèµ·ç‚¹ä¸å˜ï¼Œå¾—åˆ°çš„ç»“æœæ ¹æ®ç´¯ç§¯é€»è¾‘ä¸åŒè€Œä¸åŒã€‚
>
> ---
>
> ## 3ï¸âƒ£ ç›´è§‚ç†è§£
>
> * å»ºå›¾æ–¹å‘ = â€œä½ æ²¿å“ªæ¡è¾¹å¾€å‰èµ°ç´¯ç§¯å€¼â€
> * èµ·ç‚¹ = â€œä½ ä»å“ªä¸ªèŠ‚ç‚¹å¼€å§‹ç´¯ç§¯â€
> * æœ€ç»ˆå€¼ = â€œç´¯ç§¯å®Œåˆ°è¾¾æŸä¸ªç›®æ ‡èŠ‚ç‚¹éœ€è¦å¤šå°‘å€¼â€
>
> ä¸¾ä¾‹ï¼š
>
> * P1342 æ­£å‘å›¾ï¼šèµ·ç‚¹ 1 â†’ dist[u] = å» u çš„æœ€çŸ­è·¯
>
> * P1342 åå‘å›¾ï¼šèµ·ç‚¹ 1 â†’ dist[u] = ä» u å› 1 çš„æœ€çŸ­è·¯
>
> * P1576 åå‘å›¾ï¼šèµ·ç‚¹ B â†’ dist[A] = A æ”¯ä»˜çš„æœ€å°‘é‡‘é¢
>
> ---
>
> æ‰€ä»¥å…³é”®æ€»ç»“ï¼š
>
> 1. **èµ·ç‚¹é€‰æ‹© = ä»å“ªé‡Œå¼€å§‹ç´¯ç§¯**ï¼Œä¸å› å»ºå›¾æ–¹å‘å˜åŒ–è€Œå˜
> 2. **å»ºå›¾æ–¹å‘** = å†³å®šâ€œç´¯ç§¯çš„é¡ºåºå’Œæ–¹å‘â€ï¼Œå½±å“è®¡ç®—é€»è¾‘
> 3. **æœ€ç»ˆå€¼** = ç´¯ç§¯çš„ç»“æœï¼Œæ­£å‘å’Œåå‘å›¾ä¸åŒï¼Œå–å†³äºä½ æƒ³ç®—ä»€ä¹ˆï¼ˆåˆ°è¾¾é‡‘é¢/æ”¯ä»˜é‡‘é¢/å¾€è¿”è´¹ç”¨ç­‰ï¼‰
>
> ---
>
> å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ç”»ä¸€ä¸ª **å°ç¤ºæ„å›¾**ï¼ŒæŠŠ P1342 å’Œ P1576 çš„å»ºå›¾æ–¹å‘ã€èµ·ç‚¹ã€ç´¯ç§¯æ–¹å‘å¯¹æ¯”å‡ºæ¥ï¼Œçœ‹èµ·æ¥ä¸€ç›®äº†ç„¶ã€‚
>
> ä½ æƒ³è®©æˆ‘ç”»å—ï¼Ÿ

### Bellman_fordï¼ˆæœ¬è´¨æ¾å¼›ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,v1,v2,val;
int main(){
    cin>>n>>m;
    vector<vector<int>> grid;
    for (int i=0;i<m;i++){
        cin>>v1>>v2>>val;
        grid.push_back({v1,v2,val});
    }
    int start=1;
    int end=n;
    vector<int> mindist(n+1,INT_MAX);
    vector<bool> vis(n+1,false);
    mindist[start]=0;
    for (int i=1;i<n;i++){//æœ‰nä¸ªèŠ‚ç‚¹å°±å¯¹æ‰€æœ‰è¾¹æ¾å¼›n-1æ¬¡
        for (vector<int> &it:grid){
            int from=it[0];
            int to=it[1];
            int len=it[2];
            if (mindist[from]!=INT_MAX&&mindist[to]>mindist[from]+len){
                mindist[to]=mindist[from]+len;
            }
        }
    }
    if (mindist[end]==INT_MAX){
        cout<<"unconnected"<<endl;
    }else{
        cout<<mindist[end]<<endl;
    }
    return 0;
}
```

### SPFAï¼ˆå¯ä»¥è§†ä¸ºä¸Šä¸€ç§ç®—æ³•çš„é˜Ÿåˆ—ä¼˜åŒ–ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,v1,v2,val;
class node{
    public:
    int to;
    int len;
};
int main(){
    cin>>n>>m;
    vector<list<node>> grid(n+1);
    for (int i=0;i<m;i++){
        cin>>v1>>v2>>val;
        grid[v1].push_back((node){v2,val});
    }
    vector<int> mindist(n+1,INT_MAX);
    vector<bool> vis(n+1,false);
    int start=1;
    int end=n;
    queue<int> q;
    q.push(start);
    vis[start]=true;
    mindist[start]=0;
    while (!q.empty()){
        int cur=q.front();
        q.pop();
        vis[cur]=false;
        for (auto it:grid[cur]){
            if (mindist[it.to]>mindist[cur]+it.len){
                mindist[it.to]=mindist[cur]+it.len;
                if (!vis[it.to]){
                    q.push(it.to);
                    vis[it.to]=true;
                }
            }
        }
    }
    if (mindist[end]==INT_MAX){
        cout<<"unconnected"<<endl;
    }else{
        cout<<mindist[end]<<endl;
    }
    return 0;
}
```

ä¸€èˆ¬è€Œè¨€æ˜¯ä¸ªæ­£å¸¸çš„é¢˜ç›®éƒ½å¡SPFAå…¶å®

é‡åˆ°è´Ÿç¯ç›´æ¥æ­‡é€¼

### Floydï¼ˆæœ¬è´¨åŠ¨æ€è§„åˆ’ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,v1,v2,val;
int main(){
    cin>>n>>m;
    vector<vector<int>> grid(n+1,vector<int>(n+1,10010));
    for (int i=0;i<m;i++){
        cin>>v1>>v2>>val;
        grid[v1][v2]=val;
        grid[v2][v1]=val;
    }
    for (int k=1;k<=n;k++){
        for (int i=1;i<=n;i++){
            for (int j=1;j<=n;j++){
                grid[i][j]=min(grid[i][j],grid[i][k]+grid[k][j]);
            }
        }
    }
    int z,start,end;
    cin>>z;
    while(z--){
        cin>>start>>end;
        if (grid[start][end]!=10010){
            cout<<grid[start][end]<<endl;
        }else{
            cout<<"-1"<<endl;
        }
    }
    return 0;
}
```

å¤æ‚åº¦O(n^3)ï¼Œç¨å¾®æœ‰ç‚¹é«˜ï¼Œè§£å†³å¤šæºæœ€çŸ­è·¯ç”¨çš„

### æ‹“æ‰‘æ’åºï¼ˆåªåœ¨æœ‰å‘æ— ç¯å›¾ä¸Šæˆç«‹ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int in[100010];//ä»£è¡¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ï¼Œæ¯æ¬¡é€‰å–å…¥åº¦ä¸º0çš„é‚£ä¸ª
int main(){
    cin>>n>>m;
    vector<vector<int>> g(n+1);
    for (int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        in[v]++;
    }
    queue<int> q;
    for (int i=0;i<n;i++){
        if (in[i]==0){
            q.push(i);
        }
    }
    vector<int> res;
    while (!q.empty()){
        int p=q.front();
        q.pop();
        res.push_back(p);
        for (int i=0;i<g[p].size();i++){
            in[g[p][i]]--;
            if (in[g[p][i]]==0){
                q.push(g[p][i]);
            }
        }
    }
    if (res.size()==n){
        for (int i=0;i<res.size();i++){
            if (i==res.size()-1){
                cout<<res[i];
            }else{
                cout<<res[i]<<" ";
            }
        }
    }else{
        cout<<"-1"<<endl;
    }
    return 0;
}
```

### å¦‚ä½•é€‰æ‹©

å¼€å§‹
â†“
æ˜¯å¦æœ‰è´Ÿæƒè¾¹/è´Ÿç¯ï¼Ÿ
â”œâ”€ å¦ â†’ ç”¨Dijkstraï¼ˆæ•ˆç‡æœ€é«˜ï¼‰
â””â”€ æ˜¯ â†’ 
     â”œâ”€ å•æº â†’ SPFAï¼ˆå¹³å‡æ•ˆç‡å¥½ï¼‰æˆ– Bellman-Fordï¼ˆç¨³å®šæ£€æµ‹è´Ÿç¯ï¼‰
     â””â”€ å¤šæº â†’ Floyd-Warshall
â†“
ç‰¹æ®Šæƒ…å†µï¼š
â”œâ”€ DAGæœ‰å‘æ— ç¯å›¾ â†’ æ‹“æ‰‘æ’åº+DP
â””â”€ æ— æƒå›¾/è¾¹æƒç›¸åŒ â†’ BFS

**æƒå€¼æ­£è´Ÿå…ˆåˆ¤æ–­ï¼Œå•æºå¤šæºå†åˆ†è¾¨**
**Dijkstraæ€•è´Ÿæƒï¼ŒSPFAèƒ½è´Ÿä½†æ€•ç¯**
**å¤šæºå°±ç”¨Floydï¼Œç¨ å¯†ç¨€ç–è¦è€ƒè™‘**
**æ‹“æ‰‘æ’åºDAGç”¨ï¼Œå±‚æ¬¡åˆ†æ˜æ•ˆç‡é«˜**

| åœºæ™¯ç‰¹å¾               | é¦–é€‰ç®—æ³•       | å¤‡é€‰ç®—æ³•         | å…³é”®è®°å¿†ç‚¹               |
| :--------------------- | :------------- | :--------------- | :----------------------- |
| **è¾¹æƒå…¨ä¸ºæ­£**         | Dijkstra       | -                | "æ­£æƒå›¾ï¼ŒDijkstraæ˜¯ç‹é“" |
| **æœ‰è´Ÿæƒè¾¹ä½†æ— è´Ÿç¯**   | SPFA           | Bellman-Ford     | "æœ‰è´Ÿæƒï¼ŒSPFAæ›´æ•æ·"     |
| **éœ€è¦æ£€æµ‹è´Ÿç¯**       | Bellman-Ford   | SPFA             | "æŸ¥è´Ÿç¯ï¼ŒBellmanæœ€å¯é "  |
| **æ‰€æœ‰èŠ‚ç‚¹å¯¹æœ€çŸ­è·¯å¾„** | Floyd-Warshall | næ¬¡Dijkstra/SPFA | "å¤šå¯¹å¤šï¼ŒFloydä¸€ç«™å¼"    |
| **æœ‰å‘æ— ç¯å›¾(DAG)**    | æ‹“æ‰‘æ’åº+DP    | -                | "DAGå›¾ï¼Œæ‹“æ‰‘æ’åºæœ€ä¼˜"    |
| **æ— æƒå›¾æˆ–è¾¹æƒç›¸åŒ**   | BFS            | -                | "æ— æƒå›¾ï¼ŒBFSæœ€ç®€å•"      |
| **ç¨ å¯†å›¾**             | æ ¹æ®æƒå€¼é€‰æ‹©   | -                | "ç¨ å¯†å›¾ï¼Œæ³¨æ„Vå’ŒEå…³ç³»"   |
| **ç¨€ç–å›¾**             | Dijkstra/SPFA  | -                | "ç¨€ç–å›¾ï¼Œé‚»æ¥è¡¨æ›´ä¼˜"     |

### æ ¸å¿ƒæ•°ç»„éƒ½æ˜¯ä»€ä¹ˆæ„æ€

| ç®—æ³•               | æ ¸å¿ƒæ•°ç»„   | æ•°ç»„å«ä¹‰             | åˆå§‹å€¼          | æœ€ç»ˆå€¼       |
| :----------------- | :--------- | :------------------- | :-------------- | :----------- |
| **Dijkstra**       | `dist[]`   | èµ·ç‚¹åˆ°å„ç‚¹çš„æœ€çŸ­è·ç¦» | èµ·ç‚¹0ï¼Œå…¶ä»–âˆ    | å®é™…æœ€çŸ­è·ç¦» |
| **Bellman-Ford**   | `dist[]`   | èµ·ç‚¹åˆ°å„ç‚¹çš„æœ€çŸ­è·ç¦» | èµ·ç‚¹0ï¼Œå…¶ä»–âˆ    | å®é™…æœ€çŸ­è·ç¦» |
| **SPFA**           | `dist[]`   | èµ·ç‚¹åˆ°å„ç‚¹çš„æœ€çŸ­è·ç¦» | èµ·ç‚¹0ï¼Œå…¶ä»–âˆ    | å®é™…æœ€çŸ­è·ç¦» |
| **Floyd-Warshall** | `dist[][]` | ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·ç¦» | ç›´æ¥è¾¹æƒï¼Œæ— è¾¹âˆ | å…¨å±€æœ€çŸ­è·ç¦» |

### æ€ä¹ˆå­˜å›¾

é‚»æ¥çŸ©é˜µï¼š`vector<vector<int>> grid(n+1,vector<int>(n+1));`

é‚»æ¥è¡¨ï¼š`vector<vector<int>> grid(n+1);`

| ç®—æ³•               | æ¨èå­˜å‚¨æ–¹å¼ | å¤‡ç”¨å­˜å‚¨æ–¹å¼ | åŸå› åˆ†æ                               |
| :----------------- | :----------- | :----------- | :------------------------------------- |
| **Dijkstra**       | é‚»æ¥è¡¨       | é‚»æ¥çŸ©é˜µ     | éœ€è¦å¿«é€Ÿéå†æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰é‚»å±…         |
| **Bellman-Ford**   | è¾¹åˆ—è¡¨       | é‚»æ¥è¡¨       | éœ€è¦ç®€å•éå†æ‰€æœ‰è¾¹ï¼Œä¸å…³å¿ƒèŠ‚ç‚¹è¿æ¥å…³ç³» |
| **SPFA**           | é‚»æ¥è¡¨       | é‚»æ¥çŸ©é˜µ     | åŒDijkstraï¼Œéœ€è¦é«˜æ•ˆè®¿é—®é‚»å±…           |
| **Floyd-Warshall** | é‚»æ¥çŸ©é˜µ     | é‚»æ¥è¡¨       | éœ€è¦å¿«é€Ÿéšæœºè®¿é—®ä»»æ„ä¸¤ç‚¹é—´è·ç¦»         |

## æœ€å°ç”Ÿæˆæ ‘

### primï¼ˆæœ¬è´¨å­˜ç‚¹ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;

int v,e,v1,v2,val;
int main(){
    cin>>v>>e;
    vector<vector<int>> grid(v+1,vector<int>(v+1,10010));
    for (int i=0;i<e;i++){
        cin>>v1>>v2>>val;
        grid[v1][v2]=val;
        grid[v2][v1]=val;
    }
    vector<int> mindist(v+1,10010);
    vector<bool> in(v+1,false);
    for (int i=1;i<v;i++){
        int cur=-1;
        int minn=10011;
        for (int j=1;j<=v;j++){
            if (!in[j]&&mindist[j]<minn){
                minn=mindist[j];
                cur=j;
            }
        }
        in[cur]=true;
        for (int j=1;j<=v;j++){
            if (!in[j]&&grid[cur][j]<mindist[j]){
                mindist[j]=grid[cur][j];
            }
        }
    }
    int ans=0;
    for (int i=2;i<=v;i++){
        ans+=mindist[i];
    }
    cout<<ans<<endl;
    return 0;
}
```

### Kruskalç®—æ³•ï¼ˆå­˜è¾¹ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int v,e,v1,v2,val;
int father[1010];
void init(){
    for (int i=1;i<=v;i++){
        father[i]=i;
    }
    return;
}
int find(int a){
    if (a==father[a]){
        return a;
    }else{
        return father[a]=find(father[a]);
    }
}
bool issame(int a,int b){
    a=find(a);
    b=find(b);
    if (a==b){
        return 1;
    }else{
        return 0;
    }
}
void join(int a,int b){
    a=find(a);
    b=find(b);
    if (a==b){
        return;
    }else{
        father[b]=a;
    }
}
class node{
    public:
    int fr,to,d;
};
bool cmp(node a,node b){
    return a.d<b.d;
}
int main(){
    cin>>v>>e;
    init();
    vector<node> mp;
    for (int i=0;i<e;i++){
        cin>>v1>>v2>>val;
        mp.push_back((node){v1,v2,val});
    }
    sort(mp.begin(),mp.end(),cmp);
    int ans=0;
    for (auto it:mp){
        if (!issame(it.fr,it.to)){
            ans+=it.d;
            join(it.fr,it.to);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

**ç¨ å¯†å›¾ï¼š**primï¼ŒåŸºäºç‚¹ï¼Œmindistè¡¨ç¤ºçš„æ˜¯è·ç¦»æœ€å°ç”Ÿæˆæ ‘çš„æœ€è¿‘è·ç¦»

**ç¨€ç–å›¾ï¼š**Kruskalï¼ŒåŸºäºè¾¹ï¼Œåˆ©ç”¨è´ªå¿ƒç®—æ³•å’Œå¹¶æŸ¥é›†æ¯æ¬¡é€‰å–æœ€çŸ­çš„è¾¹ï¼Œè¾¹çš„ä¸¤ç«¯å¦‚æœä¸åœ¨åŒä¸€ä¸ªé›†åˆï¼Œé‚£ä¹ˆå°±åŠ å…¥ã€‚

## å¹¶æŸ¥é›†

```cpp
int n = 1005; // næ ¹æ®é¢˜ç›®ä¸­èŠ‚ç‚¹æ•°é‡è€Œå®šï¼Œä¸€èˆ¬æ¯”èŠ‚ç‚¹æ•°é‡å¤§ä¸€ç‚¹å°±å¥½
vector<int> father = vector<int> (n, 0); // C++é‡Œçš„ä¸€ç§æ•°ç»„ç»“æ„

// å¹¶æŸ¥é›†åˆå§‹åŒ–
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // è·¯å¾„å‹ç¼©
}

// åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// å°†v->u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›†
void join(int u, int v) {
    u = find(u); // å¯»æ‰¾uçš„æ ¹
    v = find(v); // å¯»æ‰¾vçš„æ ¹
    if (u == v) return ; // å¦‚æœå‘ç°æ ¹ç›¸åŒï¼Œåˆ™è¯´æ˜åœ¨ä¸€ä¸ªé›†åˆï¼Œä¸ç”¨ä¸¤ä¸ªèŠ‚ç‚¹ç›¸è¿ç›´æ¥è¿”å›
    father[v] = u;
}
```

## å•è°ƒæ ˆ

```cpp
vector<int> prev(n);
stack<int> st;
for (int i=0;i<=n;i++){//ä»0å¾€nï¼Œå·¦ä¾§æœ€å¤§ï¼Œä»nå¾€0ï¼Œå³ä¾§æœ€å¤§
    while (!st.empty()&&arr[st.top().]<=arr[i]){//è¿™ä¸ªæ“ä½œåªæ˜¯è®°å½•äº†ä¸‹æ ‡
        st.pop();
}
    prev[i]=st.empty()?-1:st.top();
    st.push(i);
}
```

## å•è°ƒåŒç«¯é˜Ÿåˆ—

```cpp
vector<int> win(n);
deque<int> dep;//dequeå°±æ˜¯åŒç«¯é˜Ÿåˆ—ï¼Œå¯ä»¥ä»ä¸¤å¤´è¿›å‡º
for (int i=0;i<n;i++){//é¡ºåºæ— å…³
    while (!deq.empty()&&arr[dep.back()]<=arr[i]){
        dep.pop_back();
    }
    while (!dep.empty()&&dep.front<=i-k){
        dep.pop_front();
    }
    dep.push_back(i);
    win[i]=arr[deq.front()];
}
```

## å·®åˆ†ä¸å‰ç¼€å’Œ

### ä¸€ç»´

ä¸‹é¢ç»™ä½  **æœ€æ ‡å‡†ã€æœ€ç®€æ´ã€æœ€ä¸å®¹æ˜“é”™çš„ä¸€ç»´å‰ç¼€å’Œä¸å·®åˆ†æ¨¡æ¿**ï¼ˆç«èµ›å¸¸ç”¨å†™æ³•ï¼‰ã€‚
 å…¨éƒ¨æ˜¯å¯ç›´æ¥å¤åˆ¶ä½¿ç”¨çš„æ¿å­ã€‚

------

âœ… **ä¸€ç»´å‰ç¼€å’Œæ¨¡æ¿ï¼ˆPrefix Sumï¼‰**

**åŠŸèƒ½**

å¿«é€Ÿæ±‚åŒºé—´å’Œï¼š`sum[l..r] = pre[r] - pre[l-1]`

å‡½æ•°ï¼š`partial_sum()`

------

**æ¨¡æ¿ä»£ç **

```cpp
// a[1..n] åŸæ•°ç»„
// pre[1..n] å‰ç¼€å’Œæ•°ç»„
int a[N], pre[N];

// è®¡ç®—å‰ç¼€å’Œ
for (int i = 1; i <= n; i++) {
    pre[i] = pre[i-1] + a[i];
}

// æŸ¥è¯¢åŒºé—´ [l, r] çš„å’Œ
int get_sum(int l, int r) {
    return pre[r] - pre[l-1];
}
```

------

ğŸ“Œ **æ³¨æ„äº‹é¡¹**

1. æ•°ç»„ä» **1 å¼€å§‹** æœ€ä¸å®¹æ˜“å‡ºé”™
2. æŸ¥è¯¢æ—¶å¿…é¡»ä¿è¯ `l <= r`
3. å‰ç¼€å’Œå¤§å¤šéœ€è¦å¼€ `long long` é˜²æº¢å‡º

------

âœ… **ä¸€ç»´å·®åˆ†æ¨¡æ¿ï¼ˆDifference Arrayï¼‰**

**åŠŸèƒ½**

å¯¹åŒºé—´åšæ‰¹é‡åŠ æ“ä½œï¼š

- åŸæ“ä½œï¼šå¯¹ `a[l..r]` é‡Œçš„æ¯ä¸ªå…ƒç´ åŠ  `x` â†’ O(n)
- å·®åˆ†æ³•ï¼šåªéœ€ `b[l]+=x, b[r+1]-=x` â†’ O(1)

æœ€åé€šè¿‡å‰ç¼€å’Œè¿˜åŸå‡ºçœŸå®æ•°ç»„ã€‚

------

**æ¨¡æ¿ä»£ç **

```cpp
int a[N];   // åŸæ•°ç»„
int b[N];   // å·®åˆ†æ•°ç»„ï¼ˆb æ˜¯ a çš„å·®åˆ†ï¼‰

// æ„å»ºå·®åˆ†æ•°ç»„ b
for (int i = 1; i <= n; i++) {
    b[i] = a[i] - a[i-1];
}

// åŒºé—´åŠ  xï¼ša[l..r] å…¨éƒ¨ +x
void add(int l, int r, int x) {
    b[l] += x;
    b[r+1] -= x;
}

// æœ€ç»ˆè¿˜åŸæ•°ç»„
for (int i = 1; i <= n; i++) {
    a[i] = a[i-1] + b[i];
}
```

------

ğŸ“Œ **æ³¨æ„äº‹é¡¹**

1. å·®åˆ†æ•°ç»„ `b` é€šå¸¸ä» `i=1` å¼€å§‹
2. åŸæ•°ç»„æ¢å¤æ—¶å¿…é¡»ä»å‰å¾€ååŠ 
3. å·®åˆ†é€‚åˆå¤§é‡åŒºé—´ä¿®æ”¹ï¼ˆæ‰¹é‡åŠ ï¼‰
4. æŸ¥è¯¢åŒºé—´å’Œ â†’ ç”¨å‰ç¼€å’Œ
5. ä¿®æ”¹åŒºé—´ â†’ ç”¨å·®åˆ†

------

ğŸ å¿…å¤‡ç»„åˆæ¨¡æ¿ï¼ˆå·®åˆ† + å‰ç¼€å’Œï¼‰

å¦‚æœä½ å¸¸å¸¸è¦åš**åŒºé—´åŠ  + åŒºé—´æŸ¥**çš„é¢˜ï¼Œç”¨è¿™ä¸ªç»„åˆæœ€ä¼˜ï¼š

```cpp
// å·®åˆ† b åšä¿®æ”¹
// å‰ç¼€å’Œ pre åšæŸ¥è¯¢

// ä¿®æ”¹ï¼šadd(l, r, x)
// æŸ¥è¯¢ï¼šget_sum(l, r)
```

### äºŒç»´

ä¸‹é¢ç»™ä½ æ•´ç† **äºŒç»´å‰ç¼€å’Œä¸äºŒç»´å·®åˆ†æ¨¡æ¿**ï¼Œè¿™æ˜¯ç«èµ›é‡Œéå¸¸å¸¸ç”¨çš„æ¿å­ï¼Œç›´æ¥å¤åˆ¶å¯ç”¨ã€‚

------

âœ… **äºŒç»´å‰ç¼€å’Œæ¨¡æ¿ï¼ˆ2D Prefix Sumï¼‰**

**åŠŸèƒ½**

å¿«é€Ÿè®¡ç®—çŸ©å½¢åŒºåŸŸå’Œï¼š
 `sum[x1..x2][y1..y2] = pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1]`

------

**æ¨¡æ¿ä»£ç **

```cpp
int a[N][N];      // åŸæ•°ç»„
int pre[N][N];    // å‰ç¼€å’Œæ•°ç»„

// æ„å»ºäºŒç»´å‰ç¼€å’Œ
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        pre[i][j] = a[i][j] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];
    }
}

// æŸ¥è¯¢çŸ©å½¢åŒºåŸŸ [x1..x2][y1..y2]
int get_sum(int x1, int y1, int x2, int y2) {
    return pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1];
}
```

------

ğŸ“Œ **æ³¨æ„äº‹é¡¹**

1. æ•°ç»„ä» **1 å¼€å§‹** æœ€ç¨³
2. ä¿è¯ `x1 <= x2` ä¸” `y1 <= y2`
3. é˜²æ­¢è¶Šç•Œï¼Œå¯å°† `pre[0][*]` å’Œ `pre[*][0]` åˆå§‹åŒ–ä¸º 0
4. å‰ç¼€å’Œå¯ç”¨ `long long` é˜²æº¢å‡º

------

âœ… **äºŒç»´å·®åˆ†æ¨¡æ¿ï¼ˆ2D Difference Arrayï¼‰**

**åŠŸèƒ½**

å¯¹çŸ©å½¢åŒºåŸŸæ‰¹é‡åŠ å€¼ï¼š

- åŒºé—´ `[x1..x2][y1..y2]` æ¯ä¸ªå…ƒç´  + `v`

------

**æ¨¡æ¿ä»£ç **

```cpp
int a[N][N];  // åŸæ•°ç»„
int b[N][N];  // å·®åˆ†æ•°ç»„

// æ„å»ºå·®åˆ†æ•°ç»„
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1];
    }
}

// å¯¹çŸ©å½¢åŒºåŸŸ [x1..x2][y1..y2] åŠ  v
void add(int x1, int y1, int x2, int y2, int v) {
    b[x1][y1] += v;
    b[x2+1][y1] -= v;
    b[x1][y2+1] -= v;
    b[x2+1][y2+1] += v;
}

// æœ€ç»ˆè¿˜åŸæ•°ç»„
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        a[i][j] = b[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];
    }
}
```

------

ğŸ“Œ **æ³¨æ„äº‹é¡¹**

1. å·®åˆ†æ•°ç»„ `b` è¦åˆå§‹åŒ–ä¸ºåŸæ•°ç»„çš„å·®åˆ†
2. æ¢å¤æ•°ç»„æ—¶è¦ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹é¡ºåºç´¯åŠ 
3. å¯¹çŸ©å½¢åŠ å€¼æ“ä½œåªéœ€ä¿®æ”¹å·®åˆ†çš„å››ä¸ªè§’
4. å¦‚æœæŸ¥è¯¢çŸ©å½¢å’Œ â†’ ç”¨äºŒç»´å‰ç¼€å’Œ

------

ğŸ **ç»„åˆä½¿ç”¨åœºæ™¯**

- **å¤§é‡çŸ©å½¢ä¿®æ”¹ + çŸ©å½¢æŸ¥è¯¢** â†’ å·®åˆ† + å‰ç¼€å’Œ
- **ä¸€æ¬¡æ€§ä¿®æ”¹åæŸ¥è¯¢å¤šæ¬¡** â†’ å·®åˆ†è¿˜åŸæˆåŸæ•°ç»„ â†’ å‰ç¼€å’Œ

## äºŒåˆ†

------

âœ… **1. æ™®é€šäºŒåˆ†æŸ¥æ‰¾ï¼ˆæ•°ç»„ä¸­æ‰¾å€¼/æ¡ä»¶ï¼‰**

```cpp
// åœ¨æœ‰åºæ•°ç»„ a ä¸­æŸ¥æ‰¾ target çš„æœ€å·¦å‡ºç°ä½ç½®
int binary_search_vec(vector<int>& a, int target){
    int l = 0, r = a.size() - 1;
    int ans = -1; // ä¿å­˜ç­”æ¡ˆ
    while(l <= r){
        int mid = l + (r - l) / 2;
        if(a[mid] == target){
            ans = mid;  // æ‰¾åˆ°ç›®æ ‡
            r = mid - 1; // æ”¶ç¼©åˆ°å·¦ä¾§ï¼Œæ‰¾æœ€å·¦
        } else if(a[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return ans; // è¿”å› -1 è¡¨ç¤ºä¸å­˜åœ¨
}
```

------

âœ… **2. äºŒåˆ†ç­”æ¡ˆæ¨¡æ¿ï¼ˆæ•´æ•°æœ€å°/æœ€å¤§æ»¡è¶³æ¡ä»¶ï¼‰**

```cpp
// æ±‚æœ€å°æ»¡è¶³ check(mid) çš„æ•´æ•° x
int binary_answer_min(int left_bound, int right_bound){
    int l = left_bound, r = right_bound;
    int ans = -1;
    while(l <= r){
        int mid = l + (r - l) / 2;
        if(check(mid)){ // check æ˜¯å•è°ƒå‡½æ•°
            ans = mid;
            r = mid - 1; // æ”¶ç¼©åˆ°å·¦ä¾§ï¼Œæ‰¾æœ€å°
        } else {
            l = mid + 1;
        }
    }
    return ans;
}

// æ±‚æœ€å¤§æ»¡è¶³ check(mid) çš„æ•´æ•° x
int binary_answer_max(int left_bound, int right_bound){
    int l = left_bound, r = right_bound;
    int ans = -1;
    while(l <= r){
        int mid = l + (r - l) / 2;
        if(check(mid)){ // check æ˜¯å•è°ƒå‡½æ•°
            ans = mid;
            l = mid + 1; // æ”¶ç¼©åˆ°å³ä¾§ï¼Œæ‰¾æœ€å¤§
        } else {
            r = mid - 1;
        }
    }
    return ans;
}
```

------

âœ… **3. äºŒåˆ†ç­”æ¡ˆæ¨¡æ¿ï¼ˆæµ®ç‚¹ï¼‰**

```cpp
// æ±‚æœ€å°æ»¡è¶³ check(mid) çš„æµ®ç‚¹æ•°
double binary_answer_double(double left_bound, double right_bound, double eps = 1e-6){
    double l = left_bound, r = right_bound;
    while(r - l > eps){
        double mid = l + (r - l) / 2;
        if(check(mid)){ 
            r = mid; // æ”¶ç¼©åˆ°å·¦ä¾§
        } else {
            l = mid;
        }
    }
    return r; // æˆ–è€…è¿”å› lï¼Œä¸¤è€…å·®ä¸è¶…è¿‡ eps
}
```

------

ğŸ”¹ **å°æŠ€å·§**

1. æ•´æ•°äºŒåˆ†å’Œæµ®ç‚¹äºŒåˆ†çš„åŒºåˆ«ï¼š
   - æ•´æ•°äºŒåˆ† `while(l <= r)`
   - æµ®ç‚¹äºŒåˆ† `while(r - l > eps)`
2. `check(mid)` å¿…é¡» **å•è°ƒ**ï¼ˆæ»¡è¶³â†’å³ç§»/å·¦ç§»ï¼‰
3. æ¨¡æ¿é€‚åˆï¼šæ‰¾æœ€å°/æœ€å¤§å¯è¡Œå€¼ã€åŒºé—´æœ€ä¼˜è§£ã€ç­”æ¡ˆäºŒåˆ†é¢˜

------

| é¡¹ç›®       | å†…å®¹                                                         |
| ---------- | ------------------------------------------------------------ |
| ä½œç”¨       | åœ¨æœ‰åºæ•°ç»„/åŒºé—´ä¸­æ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„å…ƒç´                           |
| æ ¸å¿ƒæ€è·¯   | æ¯æ¬¡å–ä¸­é—´ `mid` åˆ¤æ–­æ¡ä»¶ â†’ ç¼©å°åŒºé—´ â†’ æ”¶æ•›åˆ°ç­”æ¡ˆ            |
| C++æ¨¡æ¿    | `cpp int binary_search_vec(vector<int>& a, int target){ int l=0,r=a.size()-1; int ans=-1; while(l<=r){ int mid=l+(r-l)/2; if(a[mid]==target){ ans=mid; r=mid-1; } // å¦‚æœæƒ³æ‰¾æœ€å·¦å‡ºç° else if(a[mid]<target) l=mid+1; else r=mid-1; } return ans; } ` |
| å…³é”®ç‚¹     | 1. `l = 0, r = n-1` æˆ– `l=1,r=n` æ ¹æ®æ•°ç»„ä¸‹æ ‡ 2. `mid = l + (r-l)/2` é˜²æº¢å‡º 3. åˆ¤æ–­æ¡ä»¶ä¸åŒ â†’ å¯æ‰¾æœ€å·¦/æœ€å³/å­˜åœ¨ä¸å¦ |
| æ—¶é—´å¤æ‚åº¦ | O(log n)                                                     |

> æ³¨ï¼š`ans` å¯ç”¨äºå­˜æœ€å·¦/æœ€å³å‡ºç°çš„ä½ç½®ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å› bool å­˜åœ¨æ€§ã€‚

| é¡¹ç›®                          | å†…å®¹                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| ä½œç”¨                          | åœ¨è¿ç»­/å•è°ƒçš„æœç´¢ç©ºé—´é‡Œå¯»æ‰¾æœ€ä¼˜å€¼ï¼ˆæœ€å¤§/æœ€å°ï¼‰               |
| æ ¸å¿ƒæ€è·¯                      | æŠŠâ€œç­”æ¡ˆåŒºé—´â€çœ‹ä½œè¿ç»­å•è°ƒå‡½æ•° f(x)ï¼šæ»¡è¶³æ¡ä»¶ â†’ å‘å·¦/å³é€¼è¿‘ç­”æ¡ˆ |
| C++æ¨¡æ¿ï¼ˆæ±‚æœ€å°æ»¡è¶³æ¡ä»¶çš„ xï¼‰ | `cpp int l=left_bound, r=right_bound; int ans=-1; while(l<=r){ int mid = l+(r-l)/2; if(check(mid)){ ans=mid; r=mid-1; } // æœ€å°æ»¡è¶³æ¡ä»¶ else l=mid+1; } return ans; ` |
| C++æ¨¡æ¿ï¼ˆæ±‚æœ€å¤§æ»¡è¶³æ¡ä»¶çš„ xï¼‰ | `cpp int l=left_bound, r=right_bound; int ans=-1; while(l<=r){ int mid=l+(r-l)/2; if(check(mid)){ ans=mid; l=mid+1; } // æœ€å¤§æ»¡è¶³æ¡ä»¶ else r=mid-1; } return ans; ` |
| å…³é”®ç‚¹                        | 1. `check(mid)` æ˜¯å•è°ƒå‡½æ•°2. äºŒåˆ†ç­”æ¡ˆç©ºé—´å¯ä¸ºæ•´æ•°æˆ–æµ®ç‚¹3. æµ®ç‚¹äºŒåˆ†æ³¨æ„ç²¾åº¦æ§åˆ¶ï¼ˆå¦‚ eps = 1e-6ï¼‰ |
| æ—¶é—´å¤æ‚åº¦                    | O(log(max_val - min_val))                                    |

### æµ®ç‚¹äºŒåˆ†æ±‚æ–¹ç¨‹è§£

```cpp
#include <bits/stdc++.h>
using namespace std;

// ç¤ºä¾‹ï¼šæ±‚ f(x) = 0 çš„è§£
// è¿™é‡Œ f(x) å¯ä»¥æ”¹æˆä»»ä½•å•è°ƒå‡½æ•°
double f(double x){
    return pow(x, 3) - 2*x - 5; // ä¸¾ä¾‹ï¼šæ±‚ x^3 - 2x - 5 = 0 çš„è§£
}

double solve(double left_bound, double right_bound, double eps = 1e-6){
    double l = left_bound, r = right_bound;
    while(r - l > eps){
        double mid = l + (r - l) / 2.0;
        if(f(mid) >= 0){ // æ ¹æ® f(mid) å•è°ƒæ€§è°ƒæ•´
            r = mid;      // f(mid) >= 0 â†’ å·¦è¾¹æœç´¢
        } else {
            l = mid;      // f(mid) < 0 â†’ å³è¾¹æœç´¢
        }
    }
    return r; // æˆ–è€… lï¼Œä¸¤è€…å·®å€¼ <= eps
}

int main(){
    double left_bound = 0;  // æ ¹æ®é¢˜æ„è®¾ç½®èŒƒå›´
    double right_bound = 10;
    double ans = solve(left_bound, right_bound);
    cout << fixed << setprecision(6) << ans << endl; // è¾“å‡ºä¿ç•™ 6 ä½å°æ•°
    return 0;
}
```

ğŸ”¹ **æ¨¡æ¿è¯´æ˜**

1. `f(x)`ï¼šä½ è¦è§£çš„æ–¹ç¨‹ï¼Œå¯ä»¥æ¢æˆä»»æ„å•è°ƒå‡½æ•°
2. `eps`ï¼šç²¾åº¦ï¼Œä¸€èˆ¬ `1e-6` æˆ– `1e-8`
3. `left_bound, right_bound`ï¼šä½ å·²çŸ¥çš„æ ¹æ‰€åœ¨åŒºé—´ï¼Œå¿…é¡»ä¿è¯ `f(left_bound) * f(right_bound) <= 0`
4. å¾ªç¯æ¡ä»¶ï¼š`while(r - l > eps)`ï¼Œæµ®ç‚¹äºŒåˆ†ä¸èƒ½ç”¨ `l <= r`
5. è¿”å›å€¼ï¼š`r` æˆ– `l` éƒ½å¯ï¼Œç²¾åº¦ä¿è¯åœ¨ `eps` å†…

------

ğŸ”¹ **å¸¸ç”¨æ‹“å±•**

- æ±‚ **å¹³æ–¹æ ¹ã€ç«‹æ–¹æ ¹ã€å¼€ n æ¬¡æ–¹** éƒ½å¯ä»¥ç”¨æ­¤æ¨¡æ¿
- å¦‚æœæ–¹ç¨‹å•è°ƒé€’å¢æˆ–é€’å‡ï¼Œåªéœ€è°ƒæ•´ `if(f(mid) >= 0)` çš„åˆ¤æ–­æ–¹å‘
- è¾“å‡ºå¯ç”¨ `fixed << setprecision(k)` æ§åˆ¶å°æ•°ä½

## lower_bound å’Œ upper_bound

å¥½çš„ï¼Œæˆ‘ç”¨ **è¡¨æ ¼å½¢å¼**æ•´ç† `lower_bound` å’Œ `upper_bound` çš„ç”¨æ³•ã€å‚æ•°ã€è¿”å›ç±»å‹ä»¥åŠæ—¶é—´å¤æ‚åº¦ï¼Œæ–¹ä¾¿ä½ è€ƒè¯•æˆ–å†™æ¿å­ã€‚

------

| å‡½æ•°                           | åŠŸèƒ½                                     | å‚æ•°                                      | è¿”å›ç±»å‹ | è¿”å›å€¼è¯´æ˜                    | æ—¶é—´å¤æ‚åº¦ | å¤‡æ³¨              |
| ------------------------------ | ---------------------------------------- | ----------------------------------------- | -------- | ----------------------------- | ---------- | ----------------- |
| `lower_bound(start, end, val)` | åœ¨ **æœ‰åºåŒºé—´**æŸ¥æ‰¾ç¬¬ä¸€ä¸ª â‰¥ `val` çš„ä½ç½® | `start, end` ä¸ºè¿­ä»£å™¨ï¼Œ`val` ä¸ºè¦æŸ¥æ‰¾çš„å€¼ | è¿­ä»£å™¨   | æŒ‡å‘ç¬¬ä¸€ä¸ªä¸å°äº `val` çš„å…ƒç´  | O(log n)   | åŒºé—´å¿…é¡» **æœ‰åº** |
| `upper_bound(start, end, val)` | åœ¨ **æœ‰åºåŒºé—´**æŸ¥æ‰¾ç¬¬ä¸€ä¸ª > `val` çš„ä½ç½® | `start, end` ä¸ºè¿­ä»£å™¨ï¼Œ`val` ä¸ºè¦æŸ¥æ‰¾çš„å€¼ | è¿­ä»£å™¨   | æŒ‡å‘ç¬¬ä¸€ä¸ªå¤§äº `val` çš„å…ƒç´    | O(log n)   | åŒºé—´å¿…é¡» **æœ‰åº** |

------

ğŸ”¹ **ç¤ºä¾‹ä»£ç **

```cpp
vector<int> v = {1,3,3,5,7};

// lower_bound æ‰¾ç¬¬ä¸€ä¸ª >= 3
auto it1 = lower_bound(v.begin(), v.end(), 3); // æŒ‡å‘ v[1]

// upper_bound æ‰¾ç¬¬ä¸€ä¸ª > 3
auto it2 = upper_bound(v.begin(), v.end(), 3); // æŒ‡å‘ v[3]
```

- `distance(v.begin(), it1) = 1`
- `distance(v.begin(), it2) = 3`

------

ğŸ”¹ **å°æŠ€å·§/è®°å¿†**

1. `lower_bound` â†’ â€œä¸å°äº valâ€
2. `upper_bound` â†’ â€œä¸¥æ ¼å¤§äº valâ€
3. åŒºé—´å¿…é¡» **å‡åº**
4. å¯¹äº vector / array / deque / set éƒ½å¯ç”¨
5. å¯ä»¥é…åˆ `distance` è·å–ä¸‹æ ‡

------

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ æ•´ç†ä¸€ä¸ª **vector / array / set / map ä¸Š lower_bound / upper_bound å¯¹ç…§è¡¨**ï¼Œ
 è¿™æ ·è€ƒè¯•æˆ–è€…å†™æ¨¡æ¿ç›´æ¥ç”¨ä¸€å¼ è¡¨å°±èƒ½æå®šã€‚

ä½ æƒ³è®©æˆ‘æ•´ç†å—ï¼Ÿ

## æšä¸¾æŠ€å·§

> ## ä¾‹é¢˜ï¼š
>
> ## é¢˜ç›®æè¿°
>
> å·²çŸ¥ $n$ ä¸ªæ•´æ•° $x_1,x_2,\cdots,x_n$ï¼Œä»¥åŠ $1$ ä¸ªæ•´æ•° $k$ï¼ˆ$k<n$ï¼‰ã€‚ä» $n$ ä¸ªæ•´æ•°ä¸­ä»»é€‰ $k$ ä¸ªæ•´æ•°ç›¸åŠ ï¼Œå¯åˆ†åˆ«å¾—åˆ°ä¸€ç³»åˆ—çš„å’Œã€‚ä¾‹å¦‚å½“ $n=4$ï¼Œ$k=3$ï¼Œ$4$ ä¸ªæ•´æ•°åˆ†åˆ«ä¸º $3,7,12,19$ æ—¶ï¼Œå¯å¾—å…¨éƒ¨çš„ç»„åˆä¸å®ƒä»¬çš„å’Œä¸ºï¼š
>
> $3+7+12=22$
>
> $3+7+19=29$
>
> $7+12+19=38$
>
> $3+12+19=34$
>
> ç°åœ¨ï¼Œè¦æ±‚ä½ è®¡ç®—å‡ºå’Œä¸ºç´ æ•°å…±æœ‰å¤šå°‘ç§ã€‚
>
> ä¾‹å¦‚ä¸Šä¾‹ï¼Œåªæœ‰ä¸€ç§çš„å’Œä¸ºç´ æ•°ï¼š$3+7+19=29$ã€‚
>
> ## è¾“å…¥æ ¼å¼
>
> ç¬¬ä¸€è¡Œä¸¤ä¸ªç©ºæ ¼éš”å¼€çš„æ•´æ•° $n,k$ï¼ˆ$1 \le n \le 20$ï¼Œ$k<n$ï¼‰ã€‚
>
> ç¬¬äºŒè¡Œ $n$ ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä¸º $x_1,x_2,\cdots,x_n$ï¼ˆ$1 \le x_i \le 5\times 10^6$ï¼‰ã€‚
>
> ## è¾“å‡ºæ ¼å¼
>
> è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç§ç±»æ•°ã€‚
>
> ## è¾“å…¥è¾“å‡ºæ ·ä¾‹ #1
>
> ### è¾“å…¥ #1
>
> ```
> 4 3
> 3 7 12 19
> ```
>
> ### è¾“å‡º #1
>
> ```
> 1
> ```
>
> ## è¯´æ˜/æç¤º
>
> **ã€é¢˜ç›®æ¥æºã€‘**
>
> NOIP 2002 æ™®åŠç»„ç¬¬äºŒé¢˜
>
> ### é¢˜è§£ï¼š
>
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> #define int long long
> bool su(int x){
>     if (x==1||x==2) return true;
>     else{
>         for (int i=2;i*i<=x;i++){
>             if (x%i==0){
>                 return false;
>             }
>         }
>     }
>     return true;
> }
> 
> int a[25];
> int n,k,ans;
> 
> signed main(){
>     cin>>n>>k;
>     for (int i=0;i<n;i++){
>         cin>>a[i];
>     }
>     int u = 1 << n;            // è®¡ç®—å­é›†æ€»æ•°ï¼š2^n (æ¯ä¸ªå…ƒç´ æœ‰é€‰/ä¸é€‰ä¸¤ç§å¯èƒ½)
> for (int s = 0; s < u; s++) { // éå†æ‰€æœ‰å¯èƒ½çš„å­é›† (æ¯ä¸ªsçš„äºŒè¿›åˆ¶è¡¨ç¤ºå¯¹åº”ä¸€ä¸ªå­é›†)
>     
>     // __builtin_popcount(s) è®¡ç®—å­é›†ä¸­å…ƒç´ æ•°é‡(äºŒè¿›åˆ¶1çš„ä¸ªæ•°)
>     if (__builtin_popcount(s) == k) {  // åªå¤„ç†å¤§å°ä¸ºkçš„å­é›†
>         
>         int sum = 0;         // å­˜å‚¨å½“å‰å­é›†çš„å’Œ
>         for (int i = 0; i < n; i++) {  // éå†æ•°ç»„çš„æ¯ä¸ªå…ƒç´ 
>             
>             // æ£€æŸ¥ç¬¬iä¸ªå…ƒç´ æ˜¯å¦åœ¨å­é›†ä¸­
>             if (s & (1 << i))    // è‹¥sçš„ç¬¬iä½ä¸º1 (ä½è¿ç®—æŠ€å·§ï¼š1<<i åˆ›å»ºç¬¬iä½æ©ç )
>                 sum += a[i];     // å°†å…ƒç´ a[i]åŠ å…¥æ€»å’Œ
>         }
>         
>         // æ£€æŸ¥å­é›†å’Œæ˜¯å¦ä¸ºè´¨æ•° (su(sum)æ˜¯è´¨æ•°åˆ¤æ–­å‡½æ•°)
>         if (su(sum)) 
>             ans++;  // è‹¥å’Œæ˜¯è´¨æ•°ï¼Œç­”æ¡ˆ+1
>     }
> }
>     cout<<ans<<endl;
>     return 0;
> }
> ```
>
> ### æ€è·¯ï¼š
>
> å¦‚æœä¸æ˜¯çœ‹äº†é‚£ä¸€ç¯‡é¢˜è§£ï¼Œæˆ‘å¯èƒ½è¿™è¾ˆå­éƒ½æƒ³ä¸å‡ºæ¥è¿™ç§æ–¹æ³•
>
> è¿™ç§äºŒè¿›åˆ¶çš„æ–¹æ³•é€‚ç”¨äºæ±‚é›†åˆçš„å­é›†çš„é—®é¢˜ï¼Œæœ¬è´¨ä¸Šæ˜¯åˆ©ç”¨äºŒè¿›åˆ¶æ¯ä¸€ä½å¯ä»¥å­˜å‚¨ä¿¡æ¯æ¥è¿›è¡Œçš„
>
> è¯¦ç»†è§æ´›è°·é‚£æœ¬ä¹¦çš„æš´åŠ›æšä¸¾éƒ¨åˆ†

| n çš„è§„æ¨¡              | k çš„è§„æ¨¡   | æœ€ä¼˜è§£æ³•å»ºè®®                                                 |
| --------------------- | ---------- | ------------------------------------------------------------ |
| **n â‰¤ 20**            | ä»»æ„ k     | **ä½æ©ç æšä¸¾**ï¼Œå¤æ‚åº¦ O(2^n Â· n)ï¼Œæš´åŠ›å¯è¡Œ                  |
| **n â‰¤ 30, k å¾ˆå°**    | k â‰¤ 5~6    | **å›æº¯/DFS æšä¸¾ç»„åˆ**ï¼Œå¤æ‚åº¦ O( C(n,k) Â· k )                |
| **n å¾ˆå¤§ (n â‰¥ 10^5)** | k=2 æˆ– k=3 | **åŒé‡/ä¸‰é‡å¾ªç¯** æˆ–è€… **æ•°å­¦å…¬å¼**ï¼Œå¤æ‚åº¦ O(nÂ²) æˆ– O(nÂ³)ï¼Œæ³¨æ„ä¼˜åŒ– |
| **n å¾ˆå¤§ (n â‰¥ 10^5)** | k ä¸å›ºå®š   | éœ€è¦ **åŠ¨æ€è§„åˆ’ / å‰ç¼€å’Œ / çŠ¶æ€å‹ç¼© DP**ï¼Œé¿å…æ˜¾å¼æšä¸¾å­é›†   |

nä¸ªæ•°é‡Œé¢é€‰kä¸ª

## å¾ˆå¿«çš„å…¨æ’åˆ—

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[15];
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        a[i]=i;
    }
    do{
        for (int i=1;i<=n;i++){
            cout<<setw(5)<<a[i];
        }
        cout<<endl;
    }while (next_permutation(a+1,a+n+1));//whileé‡Œé¢çš„å‡½æ•°å¯ä»¥è®©è¿™ä¸ªæ•°ç»„ä»¥å­—å…¸åºæ’åºè¾“å‡º
    return 0;
}
```

`next_permutation()` æ˜¯ C++ æ ‡å‡†åº“ `<algorithm>` ä¸­çš„ä¸€ä¸ªé‡è¦å‡½æ•°ï¼Œç”¨äºç”Ÿæˆåºåˆ—çš„ä¸‹ä¸€ä¸ªå­—å…¸åºæ’åˆ—ã€‚

é…å¯¹å‡½æ•°ï¼š`prev_permutation()`

å¥‡æŠ€æ·«å·§æ¥äº†ã€‚
