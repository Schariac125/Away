# 算法：递推

## 知识点：

递推事实上是一种将一个很大的任务分解为数个小任务的思想，这是动态规划与分治思想的基础

## 例题：

洛谷P1255，这一题自己看书吧，题解区没有讲的比书里好的。

## 例题：

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 输入输出样例 #1

### 输入 #1

```
6 6 3 3
```

### 输出 #1

```
6
```

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long x[23][23];
long long ma[23][23];
void biaoji(long long x,long long y){
	ma[x][y]=1;
	ma[x-2][y-1]=1;
	ma[x+2][y+1]=1;
	ma[x-2][y+1]=1;
	ma[x+2][y-1]=1;
	ma[x-1][y-2]=1;
	ma[x-1][y+2]=1;
	ma[x+1][y-2]=1;
	ma[x+1][y+2]=1;
}

int main(){
	long long bx,by,mx,my;
	cin>>bx>>by>>mx>>my;
	bx+=2;
	by+=2;
	mx+=2;
	my+=2;
	biaoji(mx,my);
	x[2][1]=1;
	for (int i=2;i<=bx;i++){
		for (int j=2;j<=by;j++){
			if (ma[i][j]==1) continue;
			x[i][j]=x[i-1][j]+x[i][j-1];
		}
	}
	cout<<x[bx][by]<<endl;
	return 0;
}
```

### 思路：

核心思路其实很简单，我们可以发现数学规律是这样子的

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-07\Ori\9a7def16fc528660c21d336b8170e395.png)

这个时候我们只需要根据这个状态转移方程去编写代码，顺便标记一下马可以攻击到的位置就可以

至于为什么要加2，这是一个边界问题了，这样子可以防止超出边界。

## 例题：

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 输入格式

输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。

## 输出格式

输出文件只有一行，即可能输出序列的总数目。

## 输入输出样例 #1

### 输入 #1

```
3
```

### 输出 #1

```
5
```

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[20][20],n;
int main(){
	cin>>n;
	for(int x=0;x<=n;x++){
		for(int y=0;y<=n;y++){
			if(x==0) f[x][y]=1;//如果没有元素要入栈，只有一种情况
			else if(!y) f[x][y]=f[x-1][y+1];
			else f[x][y]=f[x-1][y+1]+f[x][y-1];
		}
	}
	cout<<f[n][0];
}
```

### 思路：

![image-20250722155228432](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20250722155228432.png)

## 例题：

## 题目描述

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 输入格式

输入只有一行一个整数，表示 $n$。

## 输出格式

输出一行一个整数，表示合法的数列个数。

## 输入输出样例 #1

### 输入 #1

```
6
```

### 输出 #1

```
6
```

## 说明/提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,f[1010];
int sol(int x){
    int ans=1;
    if (f[x]!=-1){
        return f[x];
    }
    for (int i=1;i<=x/2;i++){
        ans+=sol(i);
    }
    return f[x]=ans;
}

int main(){
    cin>>n;
    memset(f,-1,sizeof(f));
    f[1]=1;
    cout<<sol(n)<<endl;
    return 0;
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,f[1010],g[1010];

int main(){
    cin>>n;
    f[1]=g[1]=1;
    for (int i=2;i<=n;i++){
        f[i]=g[i/2]+1;
        g[i]=g[i-1]+f[i];
    }
    cout<<f[n]<<endl;
    return 0;
}
```

### 思路：

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-07\Ori\96c277a8919cd129a6b60aae0f26a236.png)

## 例题：

## 题目描述

对于一个递归函数 $w(a,b,c)$


- 如果 $a \le 0$ 或 $b \le 0$ 或 $c \le 0$ 就返回值 $1$。
- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$
- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。
- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$


这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。

注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。

## 输入格式

会有若干行。

并以 $-1,-1,-1$ 结束。

## 输出格式

输出若干行，每一行格式：

`w(a, b, c) = ans`

注意空格。

## 输入输出样例 #1

### 输入 #1

```
1 1 1
2 2 2
-1 -1 -1
```

### 输出 #1

```
w(1, 1, 1) = 2
w(2, 2, 2) = 4
```

## 说明/提示

### 数据规模与约定

保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。

保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \leq T \leq 10 ^ 5$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int f[10005][10005][10005];
int w(int a,int b,int c){
    if (a<=0||b<=0||c<=0) return 1;
    else if(a>20||b>20||c>20) return w(20,20,20);
    else if (f[a][b][c]!=0){
        return f[a][b][c];
    }
    else if(a<b&&b<c){
        f[a][b][c]=w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c);
    }
    else{
        f[a][b][c]=w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1);
    }
    return f[a][b][c];
}

signed main(){
    int a,b,c;
    while (1){
        cin>>a>>b>>c;
        if (a==-1&&b==-1&&c==-1){
            break;
        }
        printf("w(%lld, %lld, %lld) = %lld\n",a,b,c,w(a,b,c));
    }
    return 0;
}

```

### 思路：

记忆化搜索模板题，注意一下是怎么实现记忆化搜索的。

## 例题：

## 题目描述

有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 $\texttt{X}$ 会压缩为 $\texttt{[DX]}$ 的形式（$D$ 是一个整数且 $1\leq D\leq99$），比如说字符串 $\texttt{CBCBCBCB}$ 就压缩为 $\texttt{[4CB]}$ 或者$\texttt{[2[2CB]]}$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $\texttt{[2[2[2CB]]]}$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。

## 输入格式

输入一行，一个字符串，表示外星人发送的密码。

## 输出格式

输出一行，一个字符串，表示解压缩后的结果。

## 输入输出样例 #1

### 输入 #1

```
AC[3FUN]
```

### 输出 #1

```
ACFUNFUNFUN
```

## 说明/提示

【数据范围】

对于 $50\%$ 的数据：解压后的字符串长度在 $1000$ 以内，最多只有三重压缩。

对于 $100\%$ 的数据：解压后的字符串长度在 $20000$ 以内，最多只有十重压缩。保证只包含数字、大写字母、`[` 和 `]`。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

string expand(){
    string s="",x;
    char c;
    int d;
    while (cin>>c){
        if (c=='['){
            cin>>d;
            x=expand();
            while (d--) s+=x;
        }
        else if(c==']'){
            return s;
        }
        else{
            s+=c;
        }
    }
    return s;
}

int main(){
    cout<<expand();
    return 0;
}
```

## 例题：

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。

## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。

## 输入格式

第一行是两个数字，表示 $N$ 和 $M$。

第二行起 $N$ 个正数 $a_i$（可以有相同的数字，每个数字均在 $1000$ 以内）。

## 输出格式

一个正整数，表示点菜方案数，保证答案的范围在 int 之内。

## 输入输出样例 #1

### 输入 #1

```
4 4
1 1 2 2
```

### 输出 #1

```
3
```

## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[105];
int dp[105][10005];
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            if (j>a[i]) dp[i][j]=dp[i-1][j]+dp[i-1][j-a[i]];
            else if(j==a[i]) dp[i][j]=dp[i-1][j]+1;
            else dp[i][j]=dp[i-1][j];
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

### 思路：

首先，因为f数组存储的是方案数，所以思路可以是它可以由那些方案转移过来

1.第一种可行的方案是买当前第i道菜品，这个时候前i-1个物品所需要的钱应该是j-a\[i\], 也就是说前i个物品中所有能凑出j-a\[i\]元的方案再加上当前这道菜品，就可以变成前i个物品所需的钱为j的方案数。即f\[i\]\[j\]+=f\[i-1\]\[j-a\[i\]\]

2.不买当前第i道菜品，这时候，也就是前i-1个物品凑成j的方案，即f\[i\]\[j\]+=f\[i-1\]\[j\];

**注意这里是方案的叠加，因为每一种方案都是可行的。**

你可能以为现在已经结束了，但实际上你还没有考虑一种方案，当前第i种物品恰好为j元钱，所以可以只买它自己。这种情况其实包含在1中，但是由于f\[i\]\[0\]=0，所以不会算入这种情况。所以我们要把所有的f\[i\]\[0\]更新成1，这样就可以计算上面所述的那种情况。

**这一题，可以01背包求解，可以自行试试看**

## 例题：

## 题目描述

奶牛们正在实验秘密代码，并设计了一种方法用于生成无限长度的字符串，作为他们代码的一部分。

给定一个字符串 $s$，令 $F(s)$ 为 $s$ 后接 $s$ 向右“旋转”一个字符的结果（在右旋转中，$s$ 的最后一个字符旋转并成为新的第一个字符）。给定初始字符串 $s$，奶牛们通过重复应用 $F$ 来构建他们的无限长度代码字符串；因此每一步都会使当前字符串的长度翻倍。

给定初始字符串和一个索引 $N$，请帮助奶牛计算无限代码字符串中第 $N$ 个位置的字符。

## 输入格式

输入由一行组成，包含一个字符串和 $N$。字符串最多由 30 个大写字母组成，且 $N \leq 10^{18}$。

请注意，$N$ 可能太大，无法放入标准的 32 位整数中，因此你可能需要使用 64 位整数类型（例如，C/C++ 中的 "long long"）。

## 输出格式

请输出从初始字符串构建的无限代码字符串的第 $N$ 个字符。第一个字符的位置为 $N=1$。

## 输入输出样例 #1

### 输入 #1

```
COW 8
```

### 输出 #1

```
C
```

## 说明/提示

在这个例子中，初始字符串 COW 按以下方式扩展：

COW -> COWWCO -> COWWCOOCOWWC

### 题解：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    long long n;
    cin >> s >> n;

    long long len = s.size();
    if (n <= len) {
        cout << s[n-1] << endl;
        return 0;
    }

    long long L = len;
    while (n > len) {
        while (L < n) {
            L *= 2;
        }
        long long half = L / 2;

        if (n <= half) {
            L = half;
        } else {
            if (n == half + 1) {
                n = half;
            } else {
                n = n - half - 1;
            }
            L = half;
        }
    }

    cout << s[n-1] << endl;

    return 0;
}
```

### 思路：

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-07\Ori\68e47cdc7e36e16b3dce4bf50aa6787d.png)

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-07\Ori\0ab3edb8fc57c7aefbe32bdefab1481a.png)