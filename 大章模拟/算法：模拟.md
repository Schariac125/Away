# 算法：模拟

## 知识点：

事实上模拟不能算一种算法吧（

没什么好讲的，给出几道例题

其实也讲不完。

没有人比我更喜欢模拟

（二编）喜欢在哪？

## 例题：

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。

## 输入格式

每个输入文件包含若干行字符串，字符串由大写的 $\texttt W$ 、 $\texttt L$ 和 $\texttt E$ 组成。其中 $\texttt E$ 表示比赛信息结束，程序应该忽略 $\texttt E$ 之后的所有内容。

## 输出格式

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 $11$ 分制下的结果，第二部分是 $21$ 分制下的结果，两部分之间由一个空行分隔。

## 输入输出样例 #1

### 输入 #1

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出 #1

```
11:0
11:0
1:1

21:0
2:1
```

## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

### 题解:

```cpp
#include<bits/stdc++.h>
using namespace std;
char C;
string S;
int n,A,B;
int main()
{
	while(cin>>C)
	{
		if(C=='E')break;
		S+=C;
	}
	for(char i:S)
	{
		if(i=='W')A++;
		if(i=='L')B++;
		if(max(A,B)>=11&&abs(A-B)>=2)
		{
			cout<<A<<":"<<B<<endl;
			A=0,B=0;
		}
	}
	printf("%d:%d\n",A,B);
	A=B=0;
	puts("");
	for(char i:S)
	{
		if(i=='W')A++;
		if(i=='L')B++;
		if(max(A,B)>=21&&abs(A-B)>=2)
		{
			cout<<A<<":"<<B<<endl;
			A=0,B=0;
		}
	}
	printf("%d:%d\n",A,B);
	return 0;
}
```

## 例题：

## 题目背景

NOIP2015 普及组 T2

## 题目描述

扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。

## 输入格式

第一行是用一个空格隔开的两个整数 $n$ 和 $m$，分别表示雷区的行数和列数。

接下来 $n$ 行，每行 $m$ 个字符，描述了雷区中的地雷分布情况。字符 $\texttt{*}$ 表示相应格子是地雷格，字符 $\texttt{?}$ 表示相应格子是非地雷格。相邻字符之间无分隔符。

## 输出格式

输出文件包含 $n$ 行，每行 $m$ 个字符，描述整个雷区。用 $\texttt{*}$ 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

## 输入输出样例 #1

### 输入 #1

```
3 3
*??
???
?*?
```

### 输出 #1

```
*10
221
1*1
```

## 输入输出样例 #2

### 输入 #2

```
2 3
?*?
*??
```

### 输出 #2

```
2*1
*21
```

## 说明/提示

对于 $100\%$的数据，$1≤n≤100, 1≤m≤100$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long

int n,m;
auto a=vector<vector<char>>(105,vector<char>(105));
auto p=vector<vector<int>>(105,vector<int>(105));
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            cin>>a[i][j];
            if (a[i][j]=='*'){
                p[i][j+1]++;
                p[i][j-1]++;
                p[i+1][j]++;
                p[i-1][j]++;
                p[i+1][j+1]++;
                p[i+1][j-1]++;
                p[i-1][j-1]++;
                p[i-1][j+1]++;
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            if (a[i][j]=='*'){
                cout<<"*";
            }else{
                cout<<p[i][j];
            }
        }
        cout<<endl;
    }
    return 0;
}
```

## 例题：

# P1563 [NOIP 2016 提高组] 玩具谜题

## 题目背景

NOIP2016 提高组 D1T1

## 题目描述

小南有一套可爱的玩具小人，它们各有不同的职业。

有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章模拟\算法：模拟.assets\0u7em9pi.png) 

这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

小南一边艰难地辨认着玩具小人，一边数着:

singer 朝内，左数第 $3$ 个是 archer。

archer 朝外，右数第 $1$ 个是 thinker。

thinker 朝外，左数第 $2$ 个是 writer。

所以眼镜藏在 writer 这里！

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：

有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜题，其中第 $z$ 条指令形如“向左数/右数第 $s$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。

## 输入格式

输入的第一行包含两个正整数 $n,m$，表示玩具小人的个数和指令的条数。

接下来 $n$ 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 $0$ 表示朝向圈内，$1$ 表示朝向圈外。保证不会出现其他的数。字符串长度不超过 $10$ 且仅由英文字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 $m$ 行，其中第 $i$ 行包含两个整数 $a_i,s_i$，表示第 $i$ 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数，$1 \le s_i < n$。

## 输出格式

输出一个字符串，表示从第一个读入的小人开始，依次数完 $m$ 条指令后到达的小人的职业。

## 输入输出样例 #1

### 输入 #1

```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2
```

### 输出 #1

```
writer
```

## 输入输出样例 #2

### 输入 #2

```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4
```

### 输出 #2

```
y
```

## 说明/提示

**样例 1 说明**

这组数据就是【题目描述】中提到的例子。


**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章模拟\算法：模拟.assets\7su06u3r.png)

其中一些简写的列意义如下:

- 全朝内：若为 $\surd$，表示该测试点保证所有的玩具小人都朝向圈内；

- 全左数：若为 $\surd$，表示该测试点保证所有的指令都向左数，即对任意的 $1\leq z\leq m, a_i=0$；

- $s=1$：若为 $\surd$，表示该测试点保证所有的指令都只数 $1$ 个，即对任意的 $1\leq z\leq m,s_i=1$；

职业长度为 $1$：若为 $\surd$，表示该测试点保证所有玩具小人的职业一定是一个长度为 $1$ 的字符串。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
class man{
    public:
    long long int orient;
    string name;
};

int main(){
    long long int n,m;
    cin>>n>>m;    
    man a[1000000];
    for (int i=0;i<n;i++){
        cin>>a[i].orient>>a[i].name;
    }
    long long int ptr=0;//指针，用来指向某个人
    long long int x,y;
    for (int i=0;i<m;i++){
        cin>>x>>y;
        if (a[ptr].orient==x){
            y=y*-1;
        }
        ptr=(ptr+n+y)%n;
    }
    cout<<a[ptr].name<<endl;
    return 0;
}
```

## 例题：马猴烧酒

## 题目描述

Scarlet 最近学会了一个数组魔法，她会在 $n\times n$ 二维数组上将一个奇数阶方阵按照顺时针或者逆时针旋转 $90^\circ$。

首先，Scarlet 会把 $1$ 到 $n^2$ 的正整数按照从左往右，从上至下的顺序填入初始的二维数组中，然后她会施放一些简易的魔法。

Scarlet 既不会什么分块特技，也不会什么 Splay 套 Splay，她现在提供给你她的魔法执行顺序，想让你来告诉她魔法按次执行完毕后的二维数组。

## 输入格式

第一行两个整数 $n,m$，表示方阵大小和魔法施放次数。

接下来 $m$ 行，每行 $4$ 个整数 $x,y,r,z$，表示在这次魔法中，Scarlet 会把以第 $x$ 行第 $y$ 列为中心的 $2r+1$ 阶矩阵按照某种时针方向旋转，其中 $z=0$ 表示顺时针，$z=1$ 表示逆时针。

## 输出格式

输出 $n$ 行，每行 $n$ 个用空格隔开的数，表示最终所得的矩阵

## 输入输出样例 #1

### 输入 #1

```
5 4
2 2 1 0
3 3 1 1
4 4 1 0
3 3 2 1
```

### 输出 #1

```
5 10 3 18 15
4 19 8 17 20
1 14 23 24 25
6 9 2 7 22
11 12 13 16 21
```

## 说明/提示

对于50%的数据，满足 $r=1$

对于100%的数据 $1\leq n,m\leq500$，满足 $1\leq x-r\leq x+r\leq n,1\leq y-r\leq y+r\leq n$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int g[510][510],tot,f[510][510];//f数组充当临时数组 
int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			g[i][j]=++tot;
	for(int i=1;i<=m;i++) {
		int a,b,r,opt;
		scanf("%d %d %d %d",&a,&b,&r,&opt);//下面的分析都是针对那一块矩阵而言的 
		if(opt==0) {//第i行第j个 变成倒数第i列第j个 顺时针 
			for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					f[a-b+j][a+b-i] = g[i][j];
			for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					g[i][j] = f[i][j];
		}
		else { //第i行第j个 变成第i列倒数第j个 逆时针 
			 for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					f[a+b-j][b-a+i] = g[i][j];
			 for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					g[i][j] = f[i][j];
		}
	}
	for(int i=1;i<=n;i++) {//输出结果咯 
		for(int j=1;j<=n;j++)
			printf("%d ",g[i][j]);
		printf("\n");
	}
	return 0;
} 
```

## 例题：

# P1328 [NOIP 2014 提高组] 生活大爆炸版石头剪刀布

## 题目背景

NOIP2014 提高组 D1T1

## 题目描述

石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章模拟\算法：模拟.assets\1346.png)

现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小 A 以 `石头-布-石头-剪刀-蜥蜴人-斯波克` 长度为 $6$ 的周期出拳,那么他的出拳序列就是 `石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-...`，而如果小 B 以 `剪刀-石头-布-斯波克-蜥蜴人` 长度为 $5$ 的周期出拳,那么他出拳的序列就是 `剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-...`。

已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。

## 输入格式

第一行包含三个整数：$N,N_A,N_B$，分别表示共进行 $N$ 次猜拳、小 A 出拳的周期长度，小 B 出拳的周期长度。数与数之间以一个空格分隔。

第二行包含 $N_A$ 个整数,表示小 A 出拳的规律,第三行包含 $N_B$ 个整数，表示小 B 出拳的规律。其中，$0$ 表示 `剪刀`，$1$ 表示 `石头`，$2$ 表示 `布`，$3$ 表示 `蜥蜴人`，$4$ 表示 `斯波克`。数与数之间以一个空格分隔。

## 输出格式

输出一行，包含两个整数，以一个空格分隔，分别表示小 A、小 B 的得分。

## 输入输出样例 #1

### 输入 #1

```
10 5 6
0 1 2 3 4
0 3 4 2 1 0
```

### 输出 #1

```
6 2
```

## 输入输出样例 #2

### 输入 #2

```
9 5 5
0 1 2 3 4
1 0 3 2 4
```

### 输出 #2

```
4 4
```

## 说明/提示

对于 $100\%$ 的数据，$0 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 200$ 。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,na,nb;
int a[205],b[205];
int game[5][5] =        
{
	{0, -1, 1, 1, -1},
	{1, 0, -1, 1, -1},
	{-1, 1, 0, -1, 1},
	{-1, -1, 1, 0, 1},
	{1, 1, -1, -1, 0}
};
int main(){
    cin>>n>>na>>nb;
    int ansa=0;
    int ansb=0;
    for (int i=1;i<=na;i++){
        cin>>a[i];
    }
    for (int i=1;i<=nb;i++){
        cin>>b[i];
    }
    int ptra=1;
    int ptrb=1;
    for (int i=1;i<=n;i++){
        if (ptra>na){
            ptra=1;
        }
        if (ptrb>nb){
            ptrb=1;
        }

        int ret=game[a[ptra]][b[ptrb]];
        if (ret==1){
            ansa++;
        }else if(ret==-1){
            ansb++;
        }
        ptra++;
        ptrb++;
    }
    cout<<ansa<<" "<<ansb;
    return 0;
}
```

我爱打表

# 高精度计算：

（孩子，以后高精度计算我们还是写python吧）

## 加法

## 题目描述

高精度加法，相当于 a+b problem，**不用考虑负数**。

## 输入格式

分两行输入。$a,b \leq 10^{500}$。

## 输出格式

输出只有一行，代表 $a+b$ 的值。

## 输入输出样例 #1

### 输入 #1

```
1
1
```

### 输出 #1

```
2
```

## 输入输出样例 #2

### 输入 #2

```
1001
9099
```

### 输出 #2

```
10100
```

## 说明/提示

$20\%$ 的测试数据，$0\le a,b \le10^9$；

$40\%$ 的测试数据，$0\le a,b \le10^{18}$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define m 520

int a[m],b[m],c[m];
int main(){
    string A,B;
    cin>>A>>B;
    int len=max(A.length(),B.length());
    for (int i=A.length()-1,j=1;i>=0;i--,j++){
        a[j]=A[i]-'0';
    }
    for (int i=B.length()-1,j=1;i>=0;i--,j++){
        b[j]=B[i]-'0';
    }
    for (int i=1;i<=len;i++){
        c[i]+=a[i]+b[i];
        c[i+1]=c[i]/10;
        c[i]=c[i]%10;
    }
    if (c[len+1]) len++;
    for (int i=len;i>=1;i--){
        cout<<c[i];
    }
    return 0;
}
```

```python
a=int(input())
b=int(input())
print(a+b)
```

第二个是python题解，哈哈。

### 思路：

事实上，cpp的高精度计算其实只是在做一件事情，模拟人类计算时的竖式计算法

由于cpp的数据有位数限制，因此我们需要用字符串来模拟进行高进度计算

然后自己看代码吧。

## 乘法：

## 题目背景

高精度乘法模板题。

## 题目描述

给出两个非负整数，求它们的乘积。

## 输入格式

输入共两行，每行一个非负整数。

## 输出格式

输出一个非负整数表示乘积。

## 输入输出样例 #1

### 输入 #1

```
1 
2
```

### 输出 #1

```
2
```

## 说明/提示

每个非负整数不超过 $10^{2000}$。

### 题解：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
char a1[10001],b1[10001];
int a[10001],b[10001],i,x,len,j,c[10001];
int main ()
{
    cin>>a1>>b1;//不解释，不懂看前面
    int lena=strlen(a1);//每个部分都很清楚
	int lenb=strlen(b1);//这只是方便你们复制
    for(i=1;i<=lena;i++)a[i]=a1[lena-i]-'0';
    for(i=1;i<=lenb;i++)b[i]=b1[lenb-i]-'0';
	for(i=1;i<=lenb;i++)
	for(j=1;j<=lena;j++)
	c[i+j-1]+=a[j]*b[i];
    for(i=1;i<lena+lenb;i++)
	if(c[i]>9)
	{
		c[i+1]+=c[i]/10;
		c[i]%=10;
	}
	len=lena+lenb;
    while(c[len]==0&&len>1)len--;
    for(i=len;i>=1;i--)cout<<c[i];
    return 0;
}
```

```python
a=int(input())
b=int(input())
print(a*b)
```

### 例题：

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 输入格式

一个正整数 $n$。

## 输出格式

一个正整数 $S$，表示计算结果。

## 输入输出样例 #1

### 输入 #1

```
3
```

### 输出 #1

```
9
```

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

### 题解：

有可能我以后遇到高精度计算的题会直接语言切python了，这里不给cpp的模板了

```python
n=int(input())        #输入一个数字n，记得要用eval(),不然输入的是字符串
ans=0         #定义一个数，用来保存答案
for i in range(1,n+1):     #从1到n来算阶乘
    d=1       #阶乘值初始化为1
    for j in range(1,i+1):
        d*=j       #简单的阶乘算法
    ans+=d        #每次都加进去
print(ans)        #输出答案
```

## 高精度计算模板

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>
using namespace std;

// 比较两个大数的大小：1表示a>b，0表示相等，-1表示a<b
int compare(const string &a, const string &b) {
    if (a.length() != b.length()) {
        return a.length() > b.length() ? 1 : -1;
    }
    for (int i = 0; i < a.length(); i++) {
        if (a[i] != b[i]) {
            return a[i] > b[i] ? 1 : -1;
        }
    }
    return 0;
}

// 高精度加法
string add(string a, string b) {
    // 确保a的长度大于等于b的长度
    if (a.length() < b.length()) {
        swap(a, b);
    }
    
    string result = "";
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;
    
    while (i >= 0 || j >= 0 || carry) {
        int sum = carry;
        if (i >= 0) sum += a[i--] - '0';
        if (j >= 0) sum += b[j--] - '0';
        
        carry = sum / 10;
        result.push_back((sum % 10) + '0');
    }
    
    reverse(result.begin(), result.end());
    return result;
}

// 高精度减法（确保a >= b）
string sub(string a, string b) {
    if (compare(a, b) < 0) {
        // 返回负数结果，可根据需要修改
        return '-' + sub(b, a);
    }
    
    string result = "";
    int borrow = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;
    
    while (i >= 0) {
        int digitA = a[i--] - '0' - borrow;
        int digitB = (j >= 0) ? b[j--] - '0' : 0;
        
        borrow = 0;
        if (digitA < digitB) {
            digitA += 10;
            borrow = 1;
        }
        
        result.push_back((digitA - digitB) + '0');
    }
    
    // 移除前导零
    reverse(result.begin(), result.end());
    size_t startPos = result.find_first_not_of('0');
    if (startPos == string::npos) {
        return "0";
    }
    return result.substr(startPos);
}

// 高精度乘法
string mul(string a, string b) {
    // 处理乘数为0的情况
    if (a == "0" || b == "0") return "0";
    
    int m = a.length();
    int n = b.length();
    vector<int> product(m + n, 0);
    
    // 从最低位开始计算
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            int mul = (a[i] - '0') * (b[j] - '0');
            int sum = mul + product[i + j + 1];
            product[i + j + 1] = sum % 10;
            product[i + j] += sum / 10;
        }
    }
    
    // 转换为字符串
    string result;
    for (int p : product) {
        // 跳过前导零
        if (result.empty() && p == 0) continue;
        result.push_back(p + '0');
    }
    
    return result.empty() ? "0" : result;
}

// 高精度除法（整数除法，返回商）
string div(string dividend, string divisor) {
    if (compare(dividend, divisor) < 0) {
        return "0";
    }
    
    string quotient;
    string remainder = "";
    
    for (char digit : dividend) {
        remainder.push_back(digit);
        // 移除前导零
        while (remainder.length() > 1 && remainder[0] == '0') {
            remainder = remainder.substr(1);
        }
        
        int count = 0;
        while (compare(remainder, divisor) >= 0) {
            remainder = sub(remainder, divisor);
            count++;
        }
        
        quotient.push_back(count + '0');
    }
    
    // 移除前导零
    size_t startPos = quotient.find_first_not_of('0');
    return (startPos == string::npos) ? "0" : quotient.substr(startPos);
}

int main() {
    // 示例用法
    string a, b;
    char op;
    
    cout << "输入表达式 (如 123 + 456): ";
    cin >> a >> op >> b;
    
    switch(op) {
        case '+':
            cout << "结果: " << add(a, b) << endl;
            break;
        case '-':
            cout << "结果: " << sub(a, b) << endl;
            break;
        case '*':
            cout << "结果: " << mul(a, b) << endl;
            break;
        case '/':
            cout << "结果: " << div(a, b) << endl;
            break;
        case '>':
            cout << "结果: " << (compare(a, b) > 0 ? "true" : "false") << endl;
            break;
        default:
            cout << "不支持的操作符" << endl;
    }
    
    return 0;
}
```

## 例题：填数字与螺旋矩阵：

### 填数字：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int m[10010][10010];
int vis[10010][10010];
int xx[4] = {0, 1, 0, -1}; // 右、下、左、上
int yy[4] = {1, 0, -1, 0};

void tian(int x, int y, int dir, int num) {
    if (num > n * n) return; // 填满就停
    m[x][y] = num;
    vis[x][y] = 1;

    // 计算下一个位置
    int nx = x + xx[dir];
    int ny = y + yy[dir];

    // 如果越界或者已经走过，就换方向
    if (nx < 0 || nx >= n || ny < 0 || ny >= n || vis[nx][ny]) {
        dir = (dir + 1) % 4;
        nx = x + xx[dir];
        ny = y + yy[dir];
    }

    tian(nx, ny, dir, num + 1);
}

int main() {
    cin >> n;
    tian(0, 0, 0, 1); // 从 (0,0)，方向0(右)，数字1开始
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << setw(4) << m[i][j]; // 格式化输出
        }
        cout << endl;
    }
    return 0;
}

```

### 螺旋矩阵：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int m[10010][10010];
int vis[10010][10010];

int xx[4] = {0,1,0,-1}; 
int yy[4] = {1,0,-1,0};

vector<int> ans;
void tian(int x,int y,int num,int dir){
    if (num>n*n){
        return;
    }else{
        vis[x][y]=1;
        ans.push_back(m[x][y]);

        int bx=x+xx[dir];
        int by=y+yy[dir];

        if (bx<0||bx>=n||by<0||by>=n||vis[bx][by]){
            dir=(dir+1)%4;
            bx=x+xx[dir];
            by=y+yy[dir];
        }

        tian(bx,by,num+1,dir);
    }
}

int main(){
    cin>>n;
    for (int i=0;i<n;i++){
        for (int j=0;j<n;j++){
            cin>>m[i][j];
        }
    }
    tian(0,0,1,0);
    for (int i=0;i<ans.size();i++){
        cout<<ans[i]<<" ";
    }
    return 0;
}
```

