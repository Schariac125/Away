# 算法：贪心：

## 知识点：

**定义：从初始状态到目标状态求一个最佳方案有多个状态转移方式且仅根据当前状态来制定的策略**

步骤：

1.制定某个贪心的策略

2.证明策略的正确性

（感觉贪心其实是一种思想，不是一种模板，这个和前面的枚举很不一样）

（如果出现有一种方案明显优于另一种方案，感觉很大概率就是贪心）

（还有，能不能不要模拟了QAQ）

## 例题：接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。

## 输入格式

第一行为一个整数 $n$。

第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。

## 输出格式

输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。

## 输入输出样例 #1

### 输入 #1

```
10 
56 12 1 99 1000 234 33 55 99 812
```

### 输出 #1

```
3 2 7 8 1 4 9 6 10 5
291.90
```

## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
class man{
   public:
   int num,t;
};
bool cmp(man a,man b){
   if (a.t!=b.t){
      return a.t<b.t;
   }
   return a.num<b.num;
}
signed main(){
   int n;
   cin>>n;
   man a[1005];
   for (int i=1;i<=n;i++){
      cin>>a[i].t;
      a[i].num=i;
   }
   sort(a+1,a+n+1,cmp);
   double sum=0;
   for (int i=1;i<=n;i++){
      printf("%d ",a[i].num);
      sum+=i*a[n-i].t;
   }
   printf("\n%.2f\n",1.0*sum/n);
   return 0;
}
```

### 思路：

这个思路感觉不难

每一个人等待的时间就是等于前一个人总共的时间；

通式就是时间总和s=(n-1)t1+(n-2)t2+……+1*tn-1+0*tn;

n-1是最大系数，因此要让t1最小，tn最大。

## 例题：典型背包问题：

## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

## 输入格式

第一行两个整数 $N,T$。

接下来 $N$ 行，每行两个整数 $m_i,v_i$。

## 输出格式

一个实数表示答案，输出两位小数

## 输入输出样例 #1

### 输入 #1

```
4 50
10 60
20 100
30 120
15 45
```

### 输出 #1

```
240.00
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
class coin{
   public:
   int m,v;
};
bool cmp(coin a,coin b){
   return a.v*b.m>b.v*a.m;
}
signed main(){
   int n,t;
   cin>>n>>t;
   coin a[10000];
   for (int i=0;i<n;i++){
      cin>>a[i].m>>a[i].v;
   }
   sort(a,a+n,cmp);
   double ans=0;
   int c=t;
   int i;
   for (i=0;i<n;i++){
      if (a[i].m>c){
         break;
      }
      c-=a[i].m;
      ans+=a[i].v;
   }
   if (i<n){
      ans+=1.00*c/a[i].m*a[i].v;
   }
   printf("%.2f",ans);
   return 0;
}
```

### 思路：

很简单，按照单价来，实在装不下了再说。

## 例题：线段覆盖模板题

## 题目背景

**Python 用户可以尝试使用 pypy3 提交试题。**

快 noip 了，yyy 很紧张！

## 题目描述

现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。

## 输入格式

第一行是一个整数 $n$，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}\ (a_{i}<b_{i})$，表示比赛开始、结束的时间。

## 输出格式

一个整数最多参加的比赛数目。

## 输入输出样例 #1

### 输入 #1

```
3
0 2
2 4
1 3
```

### 输出 #1

```
2
```

## 说明/提示

- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $50\%$ 的数据，$n \le 10^3$；
- 对于 $70\%$ 的数据，$n \le 10^{5}$；
- 对于 $100\%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} < b_{i} \le 10^6$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define M 1000005
class contest{
   public:
   int l,r;
};
bool cmp(contest a,contest b){
   return a.r<=b.r;
}
signed main(){
   int n;
   cin>>n;
   contest a[M];
   for (int i=1;i<=n;i++){
      cin>>a[i].l>>a[i].r;
   }
   sort(a+1,a+n+1,cmp);
   int ans=0;
   int f=0;
   for (int i=1;i<=n;i++){
      if (a[i].l>=f){
         f=a[i].r;
         ans++;
      }
   }
   cout<<ans<<endl;
   return 0;
}
```

### 思路：

可以看luogu的那本书，里面有讲。

## 例题：更加泛化的线段题型

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

 

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

### 题解：

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& h) {
        int ans=0;
        int f=INT_MIN;//f应该从理论最小值开始
        sort(h.begin(),h.end(),[](const auto& u,const auto& v){
            return u[1]<v[1];
        });
        int n=h.size();
        for (int i=0;i<n;i++){
            if (h[i][0]>=f){
                ans++;
                f=h[i][1];
            }
        }
        return n-ans;
    }
};
```

## 例题：回文数组

## 题目描述

小蓝在无聊时随机生成了一个长度为 $n$ 的整数数组，数组中的第 $i$ 个数为 $a_i$，他觉得随机生成的数组不太美观，想把它变成回文数组，也是就对于任意 $i\in [1,n]$ 满足 $a_i=a_{n-i+1}$。小蓝一次操作可以指定相邻的两个数，将它们一起加 $1$ 或减 $1$；也可以只指定一个数加 $1$ 或减 $1$，请问他最少需要操作多少次能把这个数组变成回文数组？

## 输入格式

输入的第一行包含一个正整数 $n$。

第二行包含 $n$ 个整数 $a_1, a_2,\cdots, a_n$，相邻整数之间使用一个空格分隔。

## 输出格式

输出一行包含一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
4
1 2 3 4
```

### 输出 #1

```
3
```

## 说明/提示

**【样例说明】**

第一次操作将 $a_1, a_2$ 加 $1$，变为 $2, 3, 3, 4$；

后面两次操作将 $a_1$ 加 $1$，变为 $4,3,3,4$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \le n \le 10$；  
对于所有评测用例，$1 \le n \le 10^5$，$-10^6 \le a_i \le 10^6$。

### 题解：

```cpp
#include<bits/stdc++.h>

using ll = long long;
const int maxn = 100005;

ll a[maxn], diff[maxn], ans;

int main() {
  int n;
  std::cin >> n;
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
  }
  for (int i = 1; i <= n / 2; i++) {
    diff[i] = a[n - i + 1] - a[i];
  }
  for (int i = 1; i <= n / 2; i++) {
    ans += abs(diff[i]);
    if (diff[i] > 0 && diff[i + 1] > 0) {
      diff[i + 1] -= std::min(diff[i], diff[i + 1]);
    }
    if (diff[i] < 0 && diff[i + 1] < 0) {
      diff[i + 1] -= std::max(diff[i], diff[i + 1]);
    }
  }
  std::cout << ans;
}
```

### 思路：

洛谷那么多题解我只看懂了一篇

我们用 diffi 表示 ai 和 an−i+1 的差。我们用 ans 变量记录所需要的操作次数。设 i 从 1 枚举到 ⌊2n⌋，先将 ans 加上 diffi。

如果 diffi 和 diffi+1 都大于 0，那么将 diffi+1 减去 min(diffi,diffi+1)，我们可以利用第一个操作将 diffi 和 diffi+1 都变小。

如果 diffi 和 diffi+1 都小于 0，那么将 diffi+1 减去 max(diffi,diffi+1)，我们可以利用第一个操作将 diffi 和 diffi+1 都变大。

最后输出 ans 即可。

## 例题：平均：

### 问题描述

有一个长度为 n*n* 的数组（n*n* 是 10 的倍数），每个数 ai*a**i* 都是区间 [0,9][0,9] 中的整数。小明发现数组里每种数出现的次数不太平均，而更改第 i*i* 个数的代价为 bi*b**i*，他想更改若干个数的值使得这 1010 种数出现的次数相等（都等于 n1010*n*），请问代价和最少为多少。

### 输入格式

输入的第一行包含一个正整数 n*n*。

接下来 n*n* 行，第 i*i* 行包含两个整数 ai,bi*a**i*,*b**i* ，用一个空格分隔。

### 输出格式

输出一行包含一个正整数表示答案。

### 样例输入

```
10
1 1
1 2
1 3
2 4
2 5
2 6
3 7
3 8
3 9
4 10
```

### 样例输出

```
27
```

### 样例说明

只更改第 1,2,4,5,7,81,2,4,5,7,8 个数，需要花费代价 1+2+4+5+7+8=27

### 评测用例规模与约定

对于 2020% 的评测用例，n≤1000*n*≤1000；

对于所有评测用例，n≤105*n*≤105，0<bi≤2×1050<*b**i*≤2×105。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

class mon{
   public:
   int a,b;
};
bool cmp(mon x,mon y){
   if (x.a == y.a) return x.b < y.b;
   else return x.a < y.a;
}
signed main(){
   int n;
   cin>>n;
   mon a[1000005];
   int tong[10];
   for (int i=1;i<=n;i++){
      cin>>a[i].a>>a[i].b;
      tong[a[i].a]++;
   }
   int counts=n/10;
   int ans=0;
   sort(a+1,a+1+n,cmp);
   for (int i=1;i<=n;i++){
      if (tong[a[i].a]>counts){
         ans+=a[i].b;
         tong[a[i].a]--;
      }
   }
   cout<<ans<<endl;
   return 0;
}
```

### 思路：

这题是篮球杯困难啊，真的有困难吗（）

简单来说，每个数字出现的次数都是一定的，直接利用桶排查找出顺序，然后大于题目要求的数量的开始处理

思路是将所有数字按照代价大小进行排列，如果读取到这个数字桶排大于固定值，那就加上这个代价，减掉一个次数，很简单。

## 例题：食堂

## 题目描述

S 学校里一共有 $a_2$ 个两人寝、$a_3$ 个三人寝，$a_4$ 个四人寝，而食堂里有 $b_4$ 个四人桌和 $b_6$ 个六人桌。学校想要安排学生们在食堂用餐，并且满足每个寝室里的同学都在同一桌就坐，请问这个食堂最多同时满足多少同学用餐？

## 输入格式

**本题采用多组数据输入。**

输入共 $q+1$ 行。

第一行为一个正整数 $q$ 表示数据组数。

后面 $q$ 行，每行五个非负整数 $a_2,a_3,a_4,b_4,b_6$ 表示一组数据。

## 输出格式

输出共 $q$ 行，每行一个整数表示对应输入数据的答案。

## 输入输出样例 #1

### 输入 #1

```
2
3 0 1 0 1
0 2 2 1 1
```

### 输出 #1

```
6
10
```

## 说明/提示

**【样例说明】**

对于第一组数据，只有一个六人桌，因此最多安排三个两人寝的同学就餐，答案为 $(2+2+2)=6$。

对于第二组数据，用一个六人桌安排两个三人寝的同学，用一个四人桌安排一个四人寝的同学，答案为 $(3+3)+(4)=10$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，保证 $a_2+a_3+a_4\leq 8$。

对于 $100\%$ 的评测用例，保证 $q\leq 100$，$b_4+b_6\leq a_2+a_3+a_4\leq 100$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//这行不重要，解除cin和cout的捆绑用的
	long long t,a2,a3,a4,b4,b6,ans;
	cin>>t;
	while(t--)
	{
		cin>>a2>>a3>>a4>>b4>>b6;
		ans=0;
		while(a3>1&&b6)a3-=2,b6--,ans+=6;
		while(a4&&a2&&b6)a2--,a4--,b6--,ans+=6;
		while(a2>2&&b6)a2-=3,b6--,ans+=6;
		while(a3&&a2&&b6)a3--,a2--,b6--,ans+=5;
		while(a4&&b6)a4--,b6--,ans+=4;
		while(a2>1&&b6)a2-=2,b6--,ans+=4;
		while(a3&&b6)a3--,b6--,ans+=3;
		while(a2&&b6)a2--,b6--,ans+=2;
		while(a4&&b4)a4--,b4--,ans+=4;
		while(a2>1&&b4)a2-=2,b4--,ans+=4;
		while(a3&&b4)a3--,b4--,ans+=3;
		while(a2&&b4)a2--,b4--,ans+=2;
		cout<<ans<<"\n";
	}
}
```

### 思路：

模拟的我想吐

这题就是很经典的贪心，六人桌先把三人寝的全安排了，然后再安排四人，二人，最后考虑四人桌，这样子遗漏最少

思路有了，模拟去吧，一模拟一个老实。

**你很喜欢模拟对吗？**

## 例题：

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

### 题解：

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        // max_reach: 记录从起点出发，当前能到达的最远位置（动态维护）
        int max_reach = 0;
        
        // current_end: 当前跳跃能覆盖的边界（当 i 到达此位置时，必须跳下一步）
        int current_end = 0;
        
        // jumps: 记录跳跃次数
        int jumps = 0;
        
        // 遍历数组（不遍历最后一个元素，因为无需从终点起跳）
        // 时间复杂度: O(n)，因为每个元素只访问一次
        for (int i = 0; i < nums.size() - 1; i++) {
            // 更新 max_reach：尝试从当前位置 i 跳跃，看能否刷新最远距离
            // 操作: O(1)
            max_reach = max(max_reach, i + nums[i]);
            
            // 关键判断：是否到达当前跳跃的边界？
            if (i == current_end) {
                jumps++;           // 必须进行一次跳跃
                current_end = max_reach;  // 更新下一跳跃的边界
                
                // 提前终止：如果已能覆盖终点，直接退出循环
                if (current_end >= nums.size() - 1) {
                    break;  // 避免无效遍历
                }
            }
        }
        
        // 返回最小跳跃次数
        return jumps;
    }
};
// 时间复杂度: O(n) —— 线性遍历数组
// 空间复杂度: O(1) —— 仅使用常数空间变量
```

### 二解:

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans=0;
        int ptr=0;//定义一个指针
        int end=1;
        int n=nums.size();
        while (end<n){
            int maxp=0;
            for (int i=ptr;i<end;i++){//只是小于，所以end初始得是1，不然for就没意义了
                maxp=max(maxp,i+nums[i]);
            }
            ptr=end;
            end=maxp+1;
            ans++;
        }
        return ans;
    }
};
```

### 思路：

![45-c.png](C:\Users\asus\Desktop\程序设计\算法笔记\大章贪心\算法：贪心：.assets\1727057167-mGElnQ-45-c.png)

## 例题：献给三国杀11周年的一封情书：

（b标题我自己都绷不住）

### 问题描述

小蓝正在玩一款游戏。游戏中魏(X)、蜀(Y)、吴(Z)三个国家各自拥有一定数量的士兵X,Y,Z*X*,*Y*,*Z*（一开始可以认为都为 00）。游戏有 n 个可能会发生的事件，每个事件之间相互独立且最多只会发生一次，当第 i*i* 个事件发生时会分别让 X,Y,Z*X*,*Y*,*Z* 增加Ai,Bi,Ci

当游戏结束时（所有事件的发生与否已经确定），如果 X,Y,Z的其中一个大于另外两个之和，我们认为其获胜。例如，当 X>Y+Z时，我们认为魏国获胜。小蓝想知道游戏结束时如果有其中一个国家获胜，最多发生了多少个事件?如果不存在任何能让某国获胜的情况，请输出 −1。

### 输入格式

输入的第一行包含一个整数 n*n*。

第二行包含 n个整数表示 Ai相邻整数之间使用一个空格分隔。

第三行包含 n 个整数表示 Bi相邻整数之间使用一个空格分隔。

第四行包含 n 个整数表示 Ci相邻整数之间使用一个空格分隔。

### 输出格式

输出一行包含一个整数表示答案。

### 样例输入

```
3
1 2 2
2 3 2
1 0 7
```

### 样例输出

```
2
```

### 题解：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;//不开long long将挂掉两个测试点 

const int N=1e5+100;

bool cmp(int a,int b)//从大到小排序 
{
    return a>b;
}

int A[N],B[N],C[N];//存放魏蜀吴三个国家发生对应事件的得分 
int weight[N];//weight[i]存放魏/蜀/吴发生第i件事对于总得分的影响 
int n;

int get_ans(int a[],int b[],int c[])//a获胜,发生最多的事件数 
{
    ll sum=0;//累加当前总贡献 
    memset(weight,0,sizeof(weight));//weight数组清零 
    for(int i=1;i<=n;i++)//计算每个事件对a的纯贡献 
    {
        //假设a[i]=7,b[i]=2,c[i]=2,则发生i事件对a的纯贡献是7-2-2=3,
        //可以理解为该发生事件使a比b+c的得分高了3 
        weight[i]=a[i]-b[i]-c[i];
    }        
    sort(weight+1,weight+n+1,cmp);//将纯贡献按从大到小排序 
    int ans=0;//记录可以发生多少事件使a>b+c 
    for(int i=1;i<=n;i++)
    {
        sum+=weight[i];//累加贡献 
        if(sum>0)ans++;//累计贡献严格大于0,计数加1 
        else break;//若不大于0,由于序列递减,后面只会越来越小,直接退出 
    }
    if(ans==0)return -1;//一个事件都不能发生,返回-1 
    return ans;
}

int main()
{
    scanf("%d",&n);
    //输入原始数据,A、B、C分别存储魏蜀吴三个国家发生对应事件增加的得分 
    for(int i=1;i<=n;i++)scanf("%d",&A[i]);
    for(int i=1;i<=n;i++)scanf("%d",&B[i]);
    for(int i=1;i<=n;i++)scanf("%d",&C[i]);
    
    int ans_A=get_ans(A,B,C);//假设魏国获胜,发生最多的事件数 
    int ans_B=get_ans(B,A,C);//假设蜀国获胜,发生最多的事件数 
    int ans_C=get_ans(C,A,B);//假设吴国获胜,发生最多的事件数 
    int ans=max(ans_A,max(ans_B,ans_C));//三者取最大值即可 
    printf("%d\n",ans);
    return 0;
}
```

### 思路：

## 🌟1.枚举 + 排序

### 🍎解题思路

1.题目要求使得某个国家胜利的最大事件数目，胜利条件为X>Y+Z，那么可以暴力枚举每个国家胜利的对应的最大事件数目，取max即可

2.以X国为例，某个事件发生对于X国的贡献为w = X-Y-Z，从大到小累加贡献w，那么w第一次小于等于0的时候，就是一个临界点，从前往后加的事件数目一定是最多的个数，因为保证了每个事件贡献最大

3.对3个国家分别按照法2求最大事件数，以-1为下界，取Max即可

### 🍭技巧

1.分数 恒等变形，转化为贡献度，之后排序处理很方便

2.排序之后，保证子问题最大，从而推出整体最优（贪心）

## 例题：最大预算

## 题目描述

小蓝所在学校周边新开业了一家游乐园，小蓝作为班长，打算组织大家去游乐园玩。已知一共有 $N$ 个人参加这次活动，游乐园有 $M$ 个娱乐项目，每个项目都需要买门票后才可进去游玩。门票的价格并不是固定的，团购的人越多单价越便宜，当团购的人数大于某个阈值时，这些团购的人便可以免费进入项目进行游玩。这 $M$ 个娱乐项目是独立的，所以只有选择了同一个项目的人才可以参与这个项目的团购。第 $i$ 个项目的门票价格 $H_i(X)$ 与团购的人数 $X$ 的关系可以看作是一个函数：

$$H_i(X) = \max(K_i \times X + B_i, 0)$$

其中 $\max$ 表示取二者之中的最大值。当 $H_i = 0$ 时说明团购人数达到了此项目的免单阈值。

这 $N$ 个人可以根据自己的喜好选择 $M$ 个娱乐项目中的一种，或者有些人对这些娱乐项目都没有兴趣，也可以选择不去任何一个项目。每个人最多只会选择一个娱乐项目，如果多个人选择了同一个娱乐项目，那么他们都将享受对应的团购价格。小蓝想知道他至少需要准备多少钱，使得无论大家如何选择，他都有能力支付得起所有 $N$ 个人购买娱乐项目的门票钱。

## 输入格式

第一行两个整数 $N$、$M$，分别表示参加活动的人数和娱乐项目的个数。接下来 $M$ 行，每行两个整数，其中第 $i$ 行为 $K_i$、$B_i$，表示第 $i$ 个游乐地点的门票函数中的参数。

## 输出格式

一个整数，表示小蓝至少需要准备多少钱，使得大家无论如何选择项目，自己都支付得起。

## 输入输出样例 #1

### 输入 #1

```
4 2
-4 10
-2 7
```

### 输出 #1

```
12
```

## 说明/提示

### 样例说明

样例中有 $4$ 个人，$2$ 个娱乐项目，我们用一个二元组 $(a, b)$ 表示 $a$ 个人选择了第一个娱乐项目，$b$ 个人选择了第二个娱乐项目，那么就有 $4 - a - b$ 个人没有选择任何项目，方案 $(a, b)$ 对应的门票花费为 $\max(-4 \times a + 10, 0) \times a + \max(-2 \times b + 7, 0) \times b$，所有的可能如下所示：

| $a$  | $b$  | 花费 |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  1   |  5   |
|  0   |  2   |  6   |
|  0   |  3   |  3   |
|  0   |  4   |  0   |
|  1   |  0   |  6   |
|  1   |  1   |  11  |
|  1   |  2   |  12  |
|  1   |  3   |  9   |
|  2   |  0   |  4   |
|  2   |  1   |  9   |
|  2   |  2   |  10  |
|  3   |  0   |  0   |
|  3   |  1   |  5   |
|  4   |  0   |  0   |

其中当 $a = 1, b = 2$ 时花费最大，为 $12$。此时 $1$ 个人去第一个项目，所以第一个项目的单价为 $10 - 4 = 6$，在这个项目上的花费为 $6 \times 1 = 6$；$2$ 个人去第二个项目，所以第二个项目得单价为 $7 - 2 \times 2 = 3$，在这个项目上的花费为 $2 \times 3 = 6$；还有 $1$ 个人没去任何项目，不用统计；总花费为 $12$，这是花费最大的一种方案，所以答案为 $12$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N, M \leq 10$。
- 对于 $50\%$ 的评测用例，$1 \leq N, M \leq 1000$。
- 对于 $100\%$ 的评测用例，$1 \leq N, M, B_i \leq 10^5$，$-10^5 \leq K_i < 0$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  int n, m;
  cin >> n >> m;
  priority_queue<tuple<long long, int, int, int>> pq;
  for (int i = 0; i < m; i ++) {
    int k, b;
    cin >> k >> b;
    pq.emplace(b + k, k, b, 1);
  }
  long long ans = 0;
  while (n --) {
    auto [delta_price, k, b, x] = pq.top();
    pq.pop();
    if (delta_price <= 0) break;
    ans += delta_price;
    long long price = 1ll * (b + k * x) * x;
    long long next_price = 1ll * (b + k * (x + 1)) * (x + 1);
    pq.emplace(next_price - price, k, b, x + 1);
  }
  cout << ans << endl;
}
```

### 思路:

重点来讲讲为什么用优先队列。

优先队列有一个性质，它可以进行自动排序，保证队列顶端的元素一定是优先级最高的，省去了很多麻烦

这一题我们实际上就是去按部就班的选，算出每一个的差值，然后加到里面去，当那个差值小于0时间，就可以退出了。

然后下面附上一个详细思路

![img](C:\Users\asus\Desktop\程序设计\算法笔记\大章贪心\算法：贪心：.assets\b53b035cfa6c7f21945da336cc9cbca7.png)

## 例题：巧克力

## 题目描述

小蓝很喜欢吃巧克力，他每天都要吃一块巧克力。

一天小蓝到超市想买一些巧克力。超市的货架上有很多种巧克力，每种巧克力有自己的价格、数量和剩余的保质期天数，小蓝只吃没过保质期的巧克力，请问小蓝最少花多少钱能买到让自己吃 $x$ 天的巧克力。

## 输入格式

输入的第一行包含两个整数 $x$，$n$，分别表示需要吃巧克力的天数和巧克力的种类数。

接下来 $n$ 行描述货架上的巧克力，其中第 $i$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示第 $i$ 种巧克力的单价为 $a_i$，保质期还剩 $b_i$ 天（从现在开始的 $b_i$ 天可以吃），数量为 $c_i$。

## 输出格式

输出一个整数表示小蓝的最小花费。如果不存在让小蓝吃 $x$ 天的购买方案，输出 $−1$。

## 输入输出样例 #1

### 输入 #1

```
10 3
1 6 5
2 7 3
3 10 10
```

### 输出 #1

```
18
```

## 说明/提示

**【样例说明】**

一种最佳的方案是第 $1$ 种买 $5$ 块，第 $2$ 种买 $2$ 块，第 $3$ 种买 $3$ 块。前 $5$ 天吃第 $1$ 种，第 $6$、$7$ 天吃第 $2$ 种，第 $8$ 至 $10$ 天吃第 $3$ 种。

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$n,x \le 1000$。

对于所有评测用例，$1\le n,x\le 10^5$，$1 ≤ a_i,b_i ,c_i\le10^9$。

蓝桥杯 2021 国赛 C 组 I 题。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
class choco{
    public:
    int a,b,c;
};
bool cmp(choco x,choco y){
    if (x.a==y.a) return x.b>y.b;
    return x.a<y.a;
}
signed main(){
    int x,n;
    cin>>x>>n;
    int num=0;
    choco s[100005];
    for (int i=1;i<=n;i++){
        cin>>s[i].a>>s[i].b>>s[i].c;
    }
    sort(s+1,s+n+1,cmp);
    int ans=0;
    for (int i=x;i>0;i--){
        bool flag=false;
        for (int j=1;j<=n;j++){
            if (s[j].b>=x&&s[j].c>=1){
                s[j].c--;
                ans+=s[j].a;
                flag=true;
                break;
            }
        }
        if (flag=false){
            cout<<"-1";
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

其实我有点懒得写

用贪心解法的话，首先考虑从第一天开始从前往后枚举，选择最低价购买。但这样做会有问题，因为这种贪心会提前选单价最低但保质期较长的商品，往后枚举只剩单价大的了。

所以正确的贪心是：从后往前枚举，每次选单价最小的，这样子就不会有上面的问题。单价最小排一遍序即可。

## 例题：

## P1090 [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 输入格式

共两行。  
第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  

第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。

## 输出格式

一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。

## 输入输出样例 #1

### 输入 #1

```
3 
1 2 9
```

### 输出 #1

```
15
```

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$；

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, ans;
priority_queue<int, vector<int>, greater<int> > q;
int main() {
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int t;
        cin >> t;
        q.push(t);
    }
    while (q.size() > 1) {
        int t1 = q.top(); q.pop();
        int t2 = q.top(); q.pop();
        ans += t1 + t2;
        q.push(t1 + t2);
    }
    cout << ans << endl;
    return 0;
}
```

### 思路：

建议降橙，思路非常简单，用优先队列维护，从小到大，每次取最小的两个，然后合并之后再加入队列就行了。