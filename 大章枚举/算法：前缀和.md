# 算法：前缀和

## 前缀和预处理：

```cpp
vector<int> prefix(n);
for (int i=0;i<n;i++){
    if (i==1) prefix[i]=prefix[i-1];
    prefix[i]=prefix[i]+arr[i];
}
```

上面的写法终究显得有一点累赘

可以使用下面这一串代码来实现

```cpp
partial_sum(arr.begin(),arr.end(),prefix.begin()+1);
```

再求前缀积等方式时，可以将partial_sum()函数的第四个参数传入一个如何计算这个数据的方式，例如

```cpp
partial_sum(arr.begin(),arr.end(),prefix.begin()+1,[](int a,int b){
    return a^b;
})//其中的“[]”表示的是一个匿名函数
```

## 二维前缀：

**记得要注意看会不会越界的问题**

这样子的代码也可以实现二维数组的前缀和

```cpp
auto s=vector(n+1,vector<int>(m+1));
for (int i=1;i<=n;i++){
    partial_sum(a[i].begin(),a[i].end(),s[i].begin());
    for (int j=1;j<=m;j++){
        s[i][j]=s[i][j]+s[i][j-1];
    }
}
```

如这样一个二位的平面存放数据

1 2 3 4 5

2 3 **4 5** 6

3 4 **5 6** 7

4 5 6 7 8

计算为二维的前缀和这个就可以转化为这样子的一个矩阵平面

1 **3** 6 10 **25**

3 8 15 24 35

6 **15** 27 **42** 60

10 24 42 64 90

如果要求一个特定矩阵中的数组元素和，如求原矩阵中

4 5 

5 6这个矩阵的元素和可以利用42-15-10+3

代码如下：

```cpp
sum(x1,y1,x2,y2)=p[x2][y2]-p[x2][y1-1]-p[x1-1][y2]+p[x1-1][y1-1];
```

本质上是数学中的容斥原理，根据这个可以计算每一维的前缀

### 二维前缀最推荐的写法

不用partial_sum更好写，纯骗局

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
      b[i][j] =
          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  // 求前缀和
    }
  }//a为原数组，b为前缀和数组
```



## 例题1：

小蓝有 20230610 颗磁力弹珠，他对金字塔形状尤其感兴趣，如下图所示：

![图片描述](https://dn-simplecloud.shiyanlou.com/questions/uid1882407-20231023-1698049339195)

高度为 11 的金字塔需要 11 颗弹珠；

高度为 22 的金字塔需要 44 颗弹珠；

高度为 33 的金字塔需要 1010 颗弹珠；

高度为 44 的金字塔需要 2020 颗弹珠。

小蓝想要知道用他手里的弹珠可以摆出的最高的金字塔的高度是多少？

### 代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<int> arr(10001);
    for (int i=1;i<10000;i++){
        arr[i]=((1+i)*i)/2;
    }
    vector<int> prefix(10001);
    partial_sum(arr.begin()+1,arr.end(),prefix.begin()+1);
    for (int i=1;;i++){
        if(prefix[i]>20230610){
            cout<<i-1<<endl;
            break;
        }
    }
    return 0;
}
```

## 例题2：

### P5638 【CSGRound2】光骓者的荣耀

### 题目背景

小 K 又在做白日梦了。他进入到他的幻想中，发现他打下了一片江山。

### 题目描述

小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。

小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。

不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。

但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。

注意：**他可以不访问所有的城市，使用传送器不耗费时间**。

### 输入格式

两行，第一行 $n,k$。

第二行 $n-1$ 个整数，第 $i$  个表示$a_i$。

### 输出格式

一个整数，表示答案。

### 输入输出样例 #1

#### 输入 #1

```
4 0
1 2 3
```

#### 输出 #1

```
6
```

### 输入输出样例 #2

#### 输入 #2

```
4 1
1 2 3
```

#### 输出 #2

```
3
```

### 说明/提示

#### 样例解释 1：

样例 1,2 的图示均为以下图片：

![MZbuTK.png](https://s2.ax1x.com/2019/11/08/MZbuTK.png)

不使用传送器直接走，答案为 $6$，可以证明这个是最小值。

#### 样例解释 2：

在 $3$ 处使用，传送到 $4$，答案为 $3$，可以证明这个是最小值。

#### 数据范围：

对于所有数据，$a_i > 0$

![Kvrl34.jpg](https://s2.ax1x.com/2019/11/04/Kvrl34.jpg)

## 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define M 100005
int main(){
    long long n,k;
    cin>>n>>k;
    vector<long long>arr(M);
    for (int i=1;i<n;i++){
        cin>>arr[i];
    }
    vector<long long>prefix(M);
    prefix[1]=0;
    partial_sum(arr.begin()+1,arr.end(),prefix.begin()+1);
    long long max1=-1;
    for (int i=k+1;i<M;i++){
        if(prefix[i]-prefix[i-k]>max1) max1=prefix[i]-prefix[i-k];
    }
    cout<<prefix[n]-max1<<endl;
    return 0;
}
```

（小声bb虽然这个有俩测试点没过，我不知道到底是啥极端的数据这能不过）

## 例题3：（孩子们这题给我糖麻了）

### P2004 领地选择

### 题目描述

作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。

首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。

### 输入格式

第一行三个整数 $N,M,C$，表示地图的宽和长以及首都的边长。

接下来 $N$ 行每行 $M$ 个整数，表示了地图上每个地块的价值。价值可能为负数。

### 输出格式

一行两个整数 $X,Y$，表示首都左上角的坐标。

### 输入输出样例 #1

#### 输入 #1

```
3 4 2
1 2 3 1
-1 9 0 2
2 0 1 1
```

#### 输出 #1

```
1 2
```

### 说明/提示

对于 $60\%$ 的数据，$N,M\le 50$。

对于 $90\%$ 的数据，$N,M\le 300$。

对于 $100\%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。每块地价值的绝对值不超过 32767。

## 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m,c;
    cin>>n>>m>>c;
    auto sum=vector(n+1,vector<int>(m+1));
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            int x;
            cin>>x;
            sum[i][j]=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
        }
    }
    int max1=INT_MIN;
    int x=1;
    int y=1;
    for (int i=0;i<=n-c;i++){
        for (int j=0;j<=m-c;j++){
            int res=sum[i+c][j+c]-sum[i+c][j]-sum[i][j+c]+sum[i][j];
            if (res>max1){
                max1=res;
                x=i+1;
                y=j+1;
            }
        }
    }
    cout<<x<<" "<<y;
    return 0;
}
```

## 例题4：接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](C:\Users\asus\Desktop\程序设计\算法：前缀和.assets\rainwatertrap-17520505284821.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

 

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

### 题解：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        vector<int> leftmax(n);
        vector<int> rightmax(n);
        for (int i=0;i<n;i++){
            if (i==0) leftmax[i]=height[i];
            else leftmax[i]=max(leftmax[i-1],height[i]);
        }
        for (int j=n-1;j>=0;j--){
            if (j==n-1) rightmax[j]=height[j];
            else rightmax[j]=max(rightmax[j+1],height[j]);
        }
        int sum=0;
        for (int i=1;i<n-1;i++){
            sum+=max(0,min(leftmax[i-1],rightmax[i+1])-height[i]);
        }
        return sum;
    }
};
```

其实就是用前缀和与后缀和来记录每一个的最高峰，然后再通过遍历去求得每一个点可以装的雨水，由于最后前后缀和减掉高度有可能是负数，负数是不需要的，所以要将其与0做比较。

## 例题5：挖矿：

小蓝正在数轴上挖矿，数轴上一共有 n*n* 个矿洞，第 i*i* 个矿洞的坐标为 ai*a**i* 。 小蓝从 0 出发，每次可以向左或向右移动 11 的距离，当路过一个矿洞时，就会进行挖矿作业，获得 11 单位矿石，但一个矿洞不能被多次挖掘。小蓝想知道在移动距离不超过 m*m* 的前提下，最多能获得多少单位矿石?

### 输入格式

输入的第一行包含两个正整数 n,m*n*,*m*，用一个空格分隔。

第二行包含 n*n* 个整数 a1,a2,⋯,an*a*1,*a*2,⋯,*a**n*，相邻整数之间使用一个空格分隔。

### 输出格式

输出一行包含一个整数表示答案。

### 样例输入

```text
5 4
0 -3 -1 1 2
```

### 样例输出

```text
4
```

### 样例说明

路径：0→−1→0→1→20→−1→0→1→2，可以对 0,−1,1,20,−1,1,2 四个矿洞挖掘并获得最多 4 块矿石。

### 评测用例规模与约定

对于 20%20% 的评测用例，1≤n≤1031≤*n*≤103；

对于所有评测用例，1≤n≤105,−106≤ai≤106,1≤m≤2×1061≤*n*≤105,−106≤*a**i*≤106,1≤*m*≤2×106 。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p=1000001;
int main(){
    int n,m;
    cin>>n>>m;
    vector<int> arr(2*p);
    while (n>0){
        int x;
        cin>>x;
        arr[x+p]++;
        n--;
    }//这里的代码用以求出每一个点的矿物数量
    partial_sum(arr.begin(),arr.end(),arr.begin());//化为前缀和，以便于下一步求解出这个区间的内的总矿数
    int res=0;
    for (int i=0;i+i<=m;i++){
        int l=-i+p;
        int r=m-(i*2)+p;
        res=max(res,arr[r]-arr[l-1]);
        r=i+p;
        l=-(m-2*i)+p;
        res=max(res,arr[r]-arr[l-1]);
    }
    cout<<res<<endl;
    return 0;
}
```

这个的最优策略其实只有两个，一直向一边走，或者只折返一次。

## 例题6：抓娃娃：

小明拿了 n*n* 条线段练习抓娃娃。他将所有线段铺在数轴上，第 i*i* 条线段的左端点在 li*l**i*，右端点在 ri*r**i*。小明用 m*m* 个区间去框这些线段，第 i*i* 个区间的范围是 [Li*L**i*, Ri*R**i*]。如果一个线段有 **至少一半** 的长度被包含在某个区间内，则将其视为被这个区间框住。请计算出每个区间框住了多少个线段?

### 输入格式

输入共 n+m+1*n*+*m*+1 行。

第一行为两个正整数 n*n*, m*m*。

后面 n*n* 行，每行两个整数 li*l**i*, ri*r**i*。

后面 m*m* 行，每行两个整数 Li*L**i*, Ri*R**i*。

### 输出格式

输出共 m*m* 行，每行一个整数。

### 样例输入

```text
3 2
1 2
1 3
3 4
1 4
2 4
```

### 样例输出

```text
3
2
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p=2000001;
int main(){
    int n,m;
    cin>>n>>m;
    vector<int> arr(p);
    while (n>0){
        int l,r;
        cin>>l>>r;
        arr[l+r]++;
        n--;
    }
    partial_sum(arr.begin(),arr.end(),arr.begin());
    while (m>0){
        int l,r;
        cin>>l>>r;
        cout<<arr[r*2]-arr[l*2-1]<<endl;
        m--;
    }
    return 0;
}
```

这个题的思路本质上就是如果一个线段的中点落在一个区间内，那么这个线段一定就会大半都在这个区间内，所以我们可以很简单的想到遍历每一个中点，但实际上这么做会错（别问我怎么知道的）（问就是我亲身实验出来的）（谁懂写了十分钟代码的绝望感）

我们可以像上一题的挖矿一样用一个数组统计每一条线段的中点，再利用桶排的思想求出每一个中点出现的次数，由于中点可能会出现小数部分，我们需要将这一些数据都统一的乘上2，以保证这个数据为一个整数，再前缀和结束之后，只需要直接将那几个区间给出来就行。

## 例题：最大正方形

## 题目描述

在一个 $n\times m$ 的只包含 $0$ 和 $1$ 的矩阵里找出一个不包含 $0$ 的最大正方形，输出边长。

保证矩阵里有至少一个 $1$。

## 输入格式

输入文件第一行为两个整数 $n,m(1\leq n,m\leq 100)$，接下来 $n$ 行，每行 $m$ 个数字，用空格隔开，$0$ 或 $1$。

## 输出格式

一个整数，最大正方形的边长。

## 输入输出样例 #1

### 输入 #1

```
4 4
0 1 1 1
1 1 1 0
0 1 1 0
1 1 0 1
```

### 输出 #1

```
2
```

### 题解：

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
int a[103][103];
int b[103][103];  // 前缀和数组，相当于上文的 sum[]

int main() {
  int n, m;
  cin >> n >> m;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
      b[i][j] =
          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  // 求前缀和
    }
  }

  int ans = 0;

  int l = 1;
  while (l <= min(n, m)) {  // 判断条件
    for (int i = l; i <= n; i++) {
      for (int j = l; j <= m; j++) {
        if (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) {
          ans = max(ans, l);  // 在这里统计答案
        }
      }
    }
    l++;
  }

  cout << ans << endl;
  return 0;
}
```

这题挺经典的，建议反复观看
