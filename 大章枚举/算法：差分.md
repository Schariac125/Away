# 算法：差分：

## 知识点：

差分可以用于快速处理区间的加减，属于是前缀和的逆运算

**前缀和**

```cpp
for (int i=0;i<n;i++){
    if (i==0) s[i]=a[i];
    else s[i]=s[i-1]+a[i];
}
//partial_sum(a.begin(),a.end(),s.begin());
```

**而差分算法则是前缀和的逆运算，需要从后面往前推，代码如下：**

```cpp
for (int i=n-1,i>=0;i--){
    if (i==0) d[i]=a[i];
    else d[i]=a[i]-a[i-1];
}
```

在处理差分的时候也有一个类似于partial_sum的函数。

```cpp
adjacent_difference(a.begin(),a.end(),d.begin());
```

定理1：

```cpp
a[l,r]+k<==>d[l]+k,d[r+1]-k;
```

### 二维数组的差分：

以下代码可以实现二维数组的差分的计算：

```cpp
auto d=vector(n+1,vector<int>(m+1));
for (int i=n;i>=1;i--){
    for (int j=m;j>=1;j--){
        d[i][j]=a[i][j]-a[i-1][j];
    }
    adjacent_difference(d[i].begin(),d[i].end(),d[i].begin());
}
```

差分公式：

在矩形区域 `[x1, y1]` 到 `[x2, y2]` 的所有元素减少 `c`：

```cpp
D[x1][y1]     -= c;
D[x2+1][y1]   += c;
D[x1][y2+1]   += c;
D[x2+1][y2+1] -= c;
```

## 例题：刷油漆：

### P9094 [PA 2020] Mieszanie kolorów

### 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Mieszanie kolorów](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/kol/)**

Byteasar 正准备给栅栏涂漆。他已经准备了 $n$ 罐白色油漆，他把这些油漆排列成一排，从 $1$ 到 $n$ 编号。他想用这些油漆，但他不想把栅栏涂成白色。他委托了调色专家，调色专家有三种颜料：黄色、蓝色和红色。专家进行了 $m$ 次操作，其中第 $i$ 次操作是向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的所有罐子中加入某种颜料。

油漆的最终颜色取决于被添加到其中的颜料。添加的颜料按照下表和图示进行混合。

|        颜料        | 颜色 |
| :----------------: | :--: |
|         无         | 白色 |
|        黄色        | 黄色 |
|        蓝色        | 蓝色 |
|        红色        | 红色 |
|    黄色 + 蓝色     | 绿色 |
|    黄色 + 红色     | 橙色 |
|    蓝色 + 红色     | 紫色 |
| 黄色 + 蓝色 + 红色 | 棕色 |

![](C:\Users\asus\Desktop\程序设计\算法：差分.assets\zow92g6w.png)

Byteasar 想要给栅栏涂成一种颜色。思来想去，他选择了绿色，因为绿色代表了你常会在算法竞赛中看到的 Accepted。他想知道现在有多少罐油漆是绿色的，请帮他数数。

### 输入格式

第一行两个整数 $n,m$，分别表示油漆的罐数和专家进行的操作数。

接下来 $m$ 行，每行三个整数 $l_i,r_i,k_i$，表示在第 $i$ 次操作中向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的罐子中加入颜料。加入的颜料是黄色（$k_i=1$），蓝色（$k_i=2$）或红色（$k_i=3$）中的一种。

### 输出格式

输出一行一个整数，表示在所有操作之后绿色油漆的罐数。

### 输入输出样例 #1

### 输入 #1

```
9 5
2 8 1
4 5 2
6 7 3
5 6 2
1 2 2
```

### 输出 #1

```
3
```

## 说明/提示

#### 样例 1 解释

操作结束后，这些油漆分别是蓝色、绿色、黄色、绿色、绿色、棕色、橙色、黄色和白色的。因此，只有三罐油漆是绿色。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n,m\le 10^6$，$1\le l_i\le r_i\le n$，$1\le k_i\le 3$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,A[1000005],B[1000005],C[1000005],x,y,z,ans;//定义
int main()
{
	cin>>n>>m;//输入
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;//输入
		if(z==1) A[x]++,A[y+1]--;//黄色颜料处理
		if(z==2) B[x]++,B[y+1]--;//蓝色颜料处理
		if(z==3) C[x]++,C[y+1]--;//红色颜料处理
	}
	for(int i=1;i<=n;i++) A[i]+=A[i-1],B[i]+=B[i-1],C[i]+=C[i-1];//前缀差分
	for(int i=1;i<=n;i++) 
	if( A[i] && B[i] && !C[i]) ans++; //判断是否为绿色
	cout<<ans;//输出答案
    return 0;//最好return 0;
} 
```

### 总结：

事实上，差分最主要的应用就是在于通过它是前缀和的逆运算这个特点可以将一个数组对区间的操作转化为对它的差分数组两个端点的操作，这样子的话可以大大缩短对区间操作的时间复杂度，比枚举更有优势。

一般而言对区间的操作我们可以视为对左右两个端点（l与r+1）的操作，这样子操作完之后，通过partial_sum函数将数组还原回原本的数组，最后进行一次枚举就行

另外，差分数组比原数组要多出一个。

## 例题2：紧急大棋一盘：

### 问题描述

小蓝拥有 n×n *n*×*n* 大小的棋盘，一开始棋盘上全都是白子。小蓝进行了 m*m* 次操作，每次操作会将棋盘上某个范围内的所有棋子的颜色取反（也就是白色棋子变为黑色，黑色棋子变为白色）。请输出所有操作做完后棋盘上每个棋子的颜色。

### 输入格式

输入的第一行包含两个整数 n*n*，m*m*，用一个空格分隔，表示棋盘大小与操作数。

接下来 m*m* 行每行包含四个整数 x1*x*1，y1*y*1，x2*x*2，y2*y*2，相邻整数之间使用一个空格分隔，表示将在 x1*x*1 至 x2*x*2 行和 y1*y*1 至 y2*y*2 列中的棋子颜色取反。

### 输出格式

输出 n*n* 行，每行 n*n* 个 0 或 1 表示该位置棋子的颜色。如果是白色则输出 0，否则输出 1。

### 样例输入

```
3 3
1 1 2 2
2 2 3 3
1 1 3 3
```

### 样例输出

```
001
010
100
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m;
    auto arr=vector(n+2,vector(n+2,0));//设置一个n*n的全白棋盘
    int x1,x2,y1,y2;
    for (int i=0;i<m;i++){
        cin>>x1>>y1>>x2>>y2;
        arr[x1][y1]++;//这个往下就是二维数组的差分公式
        arr[x1][y2+1]--;
        arr[x2+1][y1]--;
        arr[x2+1][y2+1]++;
    }
    for (int i=1;i<=n;i++){
        partial_sum(arr[i].begin(),arr[i].end(),arr[i].begin());
        for (int j=1;j<=n;j++){
            arr[i][j]+=arr[i-1][j];
            cout<<(arr[i][j]&1);//作用：判断 arr[i][j] 的值是奇数还是偶数（检查奇偶性）
                                //等价于数学上的模2操作：arr[i][j] % 2
        }
        cout<<endl;
    }
    return 0;
}
```

### 总结：

这一题没什么好说的就是利用差分后面再把它弄回去，只需要注意一下公式就行了。

## 例题3：重排

### 问题描述

给定一个数组 A*A* 和一些查询 Li,Ri*L**i*,*R**i*, 求数组中第 Li*L**i* 至第 Ri*R**i* 个元素之和。

小蓝觉得这个问题很无聊, 于是他想重新排列一下数组, 使得最终每个查 询结果的和尽可能地大。小蓝想知道相比原数组, 所有查询结果的总和最多可 以增加多少?

### 输入格式

输入第一行包含一个整数 n*n* 。

第二行包含 n*n* 个整数 A1,A2,⋯,An*A*1,*A*2,⋯,*A**n*, 相邻两个整数之间用一个空格分隔。

第三行包含一个整数 m*m* 表示查询的数目。

接下来 m*m* 行, 每行包含两个整数 Li、Ri*L**i*、*R**i*, 相邻两个整数之间用一个空格分 隔。

### 输出格式

输出一行包含一个整数表示答案。

### 样例输入

```txt
5
1 2 3 4 5
2
1 3
2 5
```

### 样例输出

```text
4
```

### 样例说明

原来的和为 6+14=206+14=20, 重新排列为 (1,4,5,2,3)(1,4,5,2,3) 后和为 10+14=2410+14=24, 增 加了 4。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    cin>>n;
    vector<long long> a(n);
    for (int i=0;i<n;i++){
        cin>>a[i];
    }
    vector<long long> sum(n+1);
    partial_sum(a.begin(),a.end(),sum.begin()+1);
    cin>>m;
    long long total=0;
    vector<long long>diff(n+2);
    while(m--){
        int l,r;
        cin>>l>>r;
        diff[l]++;
        diff[r+1]--;
        total+=sum[r]-sum[l-1];
    }
    partial_sum(diff.begin(),diff.end(),diff.begin());
    sort(diff.begin(),diff.end(),greater<long long>());
    sort(a.begin(),a.end(),greater<long long>());
    long long ans=0;
    for (int i=0;i<n;i++){
        ans+=a[i]*diff[i];
    }
    cout<<ans-total<<endl;
    return 0;
}
```

### 思路：

1.解读题目：在纸上模拟，可以知道在多次询问区间L-R下求区间内的数的和是可以通过预处理前缀和得到；而所有区间和恰好是每个数的频率乘以数字本身 2.解题思路：要求最后增加了多少，容易想到对于重叠区间的频率比较高的数自然要乘上最大的数才能得到最多的增长，所以一个基本想法是将每个数统计频率，然后排好序再将所给的数也同样排好序再对应相乘相加，最后再将前后变化相减即可 3.解题方法：对于统计频率而且有前缀和，比较容易想到差分数组，差分数组恰好可以配合前缀和得到每个数的频率，这样时间复杂度比起暴力要好不少

## 例题4：商品库存管理：

在库存管理系统中，跟踪和调节商品库存量是关键任务之一。小蓝经营的仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，编号范围从 11 至 n*n*。初始时，每种商品的库存量均为 00。

为了高效地监控和调整库存量，小蓝的管理团队设计了 m*m* 个操作，每个操作涉及到一个特定的商品区间，即一段连续的商品编号范围（例如区间 [L,R][*L*,*R*]）。执行这些操作时，区间内每种商品的库存量都将增加 11。然而，在某些情况下，管理团队可能会决定不执行某些操作，使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。

现在，管理团队需要一个评估机制，来确定如果某个操作未被执行，那么最终会有多少种商品的库存量为 00。对此，请你为管理团队计算出，每个操作未执行时，库存量为 00 的商品的种类数。

### **输入格式**

第一行包含两个整数 n*n* 和 m*m*，分别表示商品的种类数和操作的个数。

接下来的 m*m* 行，每行包含两个整数 L*L* 和 R*R*，表示一个操作涉及的商品区间。

### **输出格式**

输出共 m*m* 行，每行一个整数，第 i*i* 行的整数表示如果不执行第 i*i* 个操作，则最终库存量为 00 的商品种类数。

### **样例输入**

```
5 3
1 2
2 4
3 5
```

### **样例输出**

```
1
0
1
```

### **样例说明**

考虑不执行每个操作时，其余操作对商品库存的综合影响：

- **不执行操作 1**：剩余的操作是操作 22（影响区间 [2,4][2,4]）和操作 33（影响区间 [3,5][3,5]）。执行这两个操作后，商品库存序列变为 [0,1,2,2,1][0,1,2,2,1]。在这种情况下，只有编号为 11 的商品的库存量为 00。因此，库存量为 00 的商品种类数为 11。
- **不执行操作 2**：剩余的操作是操作 11（影响区间 [1,2][1,2]）和操作 33（影响区间 [3,5][3,5]）。执行这两个操作后，商品库存序列变为 [1,1,1,1,1][1,1,1,1,1]。在这种情况下，所有商品的库存量都不为 00。因此，库存量为 00 的商品种类数为 00。
- **不执行操作 3**：剩余的操作是操作 11（影响区间 [1,2][1,2]）和操作 22（影响区间 [2,4][2,4]）。执行这两个操作后，商品库存序列变为 [1,2,1,1,0][1,2,1,1,0]。在这种情况下，只有编号为 55 的商品的库存量为 00。因此，库存量为 00 的商品种类数为 11。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
class thing{
    public:
    int l,r;
};
int main(){
    int n,m;
    cin>>n>>m;
    vector<int> a(n+2);
    vector<thing> b(m);
    for (int i=0;i<m;i++){
        cin>>b[i].l>>b[i].r;
        a[b[i].l]++;
        a[b[i].r+1]--;
    }
    vector<int> res(n);
    partial_sum(a.begin()+1,a.end(),res.begin());
    int zero=0;
    for (int i=0;i<n;i++){
        //cout<<res[i]<<" ";
        if (res[i]==0) zero++;
    }
    //cout<<endl;
    for (int i=0;i<m;i++){
        int sum=0;
        for (int j=b[i].l-1;j<=b[i].r-1;j++){
            if (res[j]==1) sum++; 
        }
        cout<<sum+zero<<endl;
    }
    return 0;
}
```

### 思路：

这一题，如果尝试暴力枚举，你在篮球杯上面最多最多只能对五个测试点（总共十二个）别问我怎么知道的。

这一题实际上很简单，把所有操作之后的结果罗列出来，在根据区间寻找为1的端点。这个点就是在这里没有处理的情况下会是0的地方。

另外还要注意，我们要找出这一整个数组中最后结果依然为0的对象，这个也要计算在内。

哦马基里基米曼波~

## 例题5:网格贴邮票（这怎么是力扣困难我草）

给你一个 `m x n` 的二进制矩阵 `grid` ，每个格子要么为 `0` （空）要么为 `1` （被占据）。

给你邮票的尺寸为 `stampHeight x stampWidth` 。我们想将邮票贴进二进制矩阵中，且满足以下 **限制** 和 **要求** ：

1. 覆盖所有 **空** 格子。
2. 不覆盖任何 **被占据** 的格子。
3. 我们可以放入任意数目的邮票。
4. 邮票可以相互有 **重叠** 部分。
5. 邮票不允许 **旋转** 。
6. 邮票必须完全在矩阵 **内** 。

如果在满足上述要求的前提下，可以放入邮票，请返回 `true` ，否则返回 `false` 。

 

**示例 1：**

![img](C:\Users\asus\Desktop\程序设计\算法：差分.assets\ex1.png)

```
输入：grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
输出：true
解释：我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。
```

**示例 2：**

![img](C:\Users\asus\Desktop\程序设计\算法：差分.assets\ex2.png)

```
输入：grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
输出：false 
解释：没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。
```

### 题解：

```cpp
class Solution {
public:
    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));
        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }

        for (int i = 1; i + stampHeight - 1 <= m; i++) {
            for (int j = 1; j + stampWidth - 1 <= n; j++) {
                int x = i + stampHeight - 1;
                int y = j + stampWidth - 1;
                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {
                    diff[i][j]++;
                    diff[i][y + 1]--;
                    diff[x + 1][j]--;
                    diff[x + 1][y + 1]++;
                }
            }
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

### 思路：

我还是觉得这题对我而言难度有点太变态了

（二编）孩子们，难度已经不变态了，因为我看过更变态的了

简单而言，在这个矩阵里面，有被覆盖的点会被标记为1，那么在这个点的二维前缀和就一定会大于1，先求出每一个前缀和以便于预处理

后面如果被邮票覆盖上了，就把那个点加上1，从0变成1

对二维空间的操作使用差分是比较简单的，可以把它的时间复杂度大大缩小，利用那个公式就能写出来，这个公式前面已经写过了。

把差分前缀和回去就可以得出原本的数组状态。

然后去遍历每一个单位，如果发现这个单位为0，即没办法覆盖完全，返回false

另外，这个邮票根据我的观察，应该是效率最低的那种贴法（）