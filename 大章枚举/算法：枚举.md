## 算法：枚举：

## 例题引入：

一个整数如果按从低位到高位的顺序，奇数位 (个位、百位、万位 ⋯⋯ ) 上的数字是奇数，偶数位 (十位、千位、十万位 ⋯⋯ ) 上的数字是偶数，我们就称之为 “好数”。

给定一个正整数 N*N*，请计算从 1 到 N*N* 一共有多少个好数。

一个整数 N*N*。

**输出格式**

一个整数代表答案。

**样例输入 1**

```text
24
```

**样例输出 1**

```text
7
```

**样例输入 2**

```text
2024
```

**样例输出 2**

```text
150
```

我给出的代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
int jirou(int n){
    if (n%2==0){
        return 1;
    }else{
        return 2;
    }
}
int goodnum(int n){
    int i=1;//可能要修改的参数
    int ans=1;
    while (n>0){
        int temp=n%10;
        if (jirou(i)==jirou(temp)){
            ans++;
            i++;
        }else{
            i++;
        }
        n/=10;
    }
    if (ans==i){
        return 1;
    }else{
        return 0;
    }
}
int main(){
    int a;
    cin>>a;
    int sum=0;
    for (int i=1;i<=a;i++){
        sum+=goodnum(i);
    }
    cout<<sum<<endl;
    return 0;
}
```

## 例题：

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

## 输出格式

输出一个整数，表示种类数。

## 输入输出样例 #1

### 输入 #1

```
4 3
3 7 12 19
```

### 输出 #1

```
1
```

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
bool su(int x){
    if (x==1||x==2) return true;
    else{
        for (int i=2;i*i<=x;i++){
            if (x%i==0){
                return false;
            }
        }
    }
    return true;
}

int a[25];
int n,k,ans;

signed main(){
    cin>>n>>k;
    for (int i=0;i<n;i++){
        cin>>a[i];
    }
    int u = 1 << n;            // 计算子集总数：2^n (每个元素有选/不选两种可能)
for (int s = 0; s < u; s++) { // 遍历所有可能的子集 (每个s的二进制表示对应一个子集)
    
    // __builtin_popcount(s) 计算子集中元素数量(二进制1的个数)
    if (__builtin_popcount(s) == k) {  // 只处理大小为k的子集
        
        int sum = 0;         // 存储当前子集的和
        for (int i = 0; i < n; i++) {  // 遍历数组的每个元素
            
            // 检查第i个元素是否在子集中
            if (s & (1 << i))    // 若s的第i位为1 (位运算技巧：1<<i 创建第i位掩码)
                sum += a[i];     // 将元素a[i]加入总和
        }
        
        // 检查子集和是否为质数 (su(sum)是质数判断函数)
        if (su(sum)) 
            ans++;  // 若和是质数，答案+1
    }
}
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

如果不是看了那一篇题解，我可能这辈子都想不出来这种方法

这种二进制的方法适用于求集合的子集的问题，本质上是利用二进制每一位可以存储信息来进行的

详细见洛谷那本书的暴力枚举部分

## 例题：

## 题目描述

排列与组合是常用的数学方法，其中组合就是从 $n$ 个元素中抽出 $r$ 个元素（不分顺序且 $r \le n$），我们可以简单地将 $n$ 个元素理解为自然数 $1,2,\dots,n$，从中任取 $r$ 个数。

现要求你输出所有组合。

例如 $n=5,r=3$，所有组合为：

$123,124,125,134,135,145,234,235,245,345$。

## 输入格式

一行两个自然数 $n,r(1<n<21,0 \le r \le n)$。

## 输出格式

所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。

**注意哦！输出时，每个数字需要 $3$ 个场宽。以 C++ 为例，你可以使用下列代码：**

```cpp
cout << setw(3) << x;
```

输出占 $3$ 个场宽的数 $x$。注意你需要头文件 `iomanip`。

## 输入输出样例 #1

### 输入 #1

```
5 3
```

### 输出 #1

```
1  2  3
  1  2  4
  1  2  5
  1  3  4
  1  3  5
  1  4  5
  2  3  4
  2  3  5
  2  4  5
  3  4  5
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,r;
int a[30];
signed main(){
    cin>>n>>r;
    int u=1<<n;
    for (int s=u-1;s>=0;s--){
        int cnt=0;
        for (int i=0;i<n;i++){
            if (s&(1<<i)){
                a[cnt++]=i;
            }
        }
        if (cnt==r){
            for (int i=r-1;i>=0;i--){
                cout<<setw(3)<<(n-a[i]);//z
            }
            cout<<endl;
        }
    }
    return 0;
}
```

二进制真王朝了，直接删除集合问题了。

## 例题：全排序

## 题目描述

按照字典序输出自然数 $1$ 到 $n$ 所有不重复的排列，即 $n$ 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。

## 输入格式

一个整数 $n$。

## 输出格式

由 $1 \sim n$ 组成的所有不重复的数字序列，每行一个序列。

每个数字保留 $5$ 个场宽。

## 输入输出样例 #1

### 输入 #1

```
3
```

### 输出 #1

```
1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
```

## 说明/提示

$1 \leq n \leq 9$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[15];
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        a[i]=i;
    }
    do{
        for (int i=1;i<=n;i++){
            cout<<setw(5)<<a[i];
        }
        cout<<endl;
    }while (next_permutation(a+1,a+n+1));//while里面的函数可以让这个数组以字典序排序输出
    return 0;
}
```

这里介绍一下next_permutation()

`next_permutation()` 是 C++ 标准库 `<algorithm>` 中的一个重要函数，用于生成序列的下一个字典序排列。以下是详细介绍：

### 基本功能

- **作用**：将序列重新排列成下一个字典序更大的排列

- 

  原型

  ：

  ```
  template<class BidirIt>
  bool next_permutation(BidirIt first, BidirIt last);
  ```

- 

  返回值

  ：

  - 如果存在下一个排列，返回 `true` 并修改序列
  - 如果已经是最大排列，返回 `false` 并将序列变为最小排列

### 工作原理

1. **自右向左** 找到第一对满足 `a[i] < a[i+1]` 的元素（此时 `a[i+1..end]` 是降序）
2. **自右向左** 找到第一个大于 `a[i]` 的元素 `a[j]`
3. **交换** `a[i]` 和 `a[j]`
4. **反转** `a[i+1]` 到末尾的子序列

```
graph TD
    A[开始] --> B[从右向左找 a_i < a_{i+1}]
    B -- 找到 --> C[从右向左找 a_j > a_i]
    B -- 未找到 --> D[反转为最小排列]
    C --> E[交换 a_i 和 a_j]
    E --> F[反转 a_{i+1} 到末尾]
    F --> G[返回 true]
    D --> H[返回 false]
```

### 使用示例

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    
    // 生成所有排列
    do {
        for (int num : v) 
            cout << num << " ";
        cout << endl;
    } while (next_permutation(v.begin(), v.end()));
    
    return 0;
}
```

输出：

```
1 2 3 
1 3 2 
2 1 3 
2 3 1 
3 1 2 
3 2 1 
```

### 重要特性

1. **字典序顺序**：严格遵循从小到大的字典序

2. 

   包含重复元素

   ：会跳过重复排列

   ```
   vector<int> v = {1, 1, 2};
   // 输出：112, 121, 211（共3种排列）
   ```

3. **前置条件**：序列应先排序（通常升序）

4. **效率**：时间复杂度 O(n)，空间复杂度 O(1)

### 实际应用场景

1. **排列问题**：解决旅行商问题、八皇后等组合优化问题

   ```
   // 生成所有可能的路径排序
   vector<int> path = {0, 1, 2, 3}; // 城市编号
   do {
       calculateDistance(path);
   } while (next_permutation(path.begin(), path.end()));
   ```

2. **组合数学**：生成排列验证公式

3. **密码学**：生成排列作为密钥空间

4. **测试用例**：生成所有可能的输入顺序

### 配对函数：prev_permutation()

- **功能**：生成前一个字典序排列

- 

  使用

  ：

  ```
  vector<int> v = {3, 2, 1};
  do {
      // 输出：321 → 312 → 231 → 213 → 132 → 123
  } while (prev_permutation(v.begin(), v.end()));
  ```

### 注意事项

1. **必须可变序列**：迭代器需支持写操作

2. **自定义比较**：提供自定义比较函数支持特殊类型

   ```
   struct Point { int x, y; };
   bool comp(const Point& a, const Point& b) {
       return a.x < b.x || (a.x == b.x && a.y < b.y);
   }
   
   vector<Point> points = {...};
   next_permutation(points.begin(), points.end(), comp);
   ```

3. **序列长度限制**：适用于 n≤20 的问题（20! ≈ 2e18）

`next_permutation()` 是算法竞赛和实际应用中处理排列问题的核心工具，它封装了复杂的排列逻辑，只需一行代码即可实现排列生成。

## 例题：

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三位数 | 代表的数字 |
| :----: | :--------: |
| $123$  |    $1$     |
| $132$  |    $2$     |
| $213$  |    $3$     |
| $231$  |    $4$     |
| $312$  |    $5$     |
| $321$  |    $6$     |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

## 输入格式

共三行。  
第一行一个正整数 $N$，表示火星人手指的数目（$1 \le N \le 10000$）。  
第二行是一个正整数 $M$，表示要加上去的小整数（$1  \le  M  \le  100$）。  
下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。

## 输出格式

$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。

## 输入输出样例 #1

### 输入 #1

```
5
3
1 2 3 4 5
```

### 输出 #1

```
1 2 4 5 3
```

## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题

### 题解

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[10010];

int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    while (m--){
        next_permutation(a+1,a+n+1);
    }
    for (int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }
    return 0;
}
```

## 例题：

## 题目描述

只要一个由 $N \times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。

小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。

## 输入格式

第一行是两个整数 $N,M$。

接下来 $N$ 行是一个矩阵，矩阵的每一个小方块是 `W`（白），`B`（蓝），`R`（红）中的一个。

## 输出格式

一个整数，表示至少需要涂多少块。

## 输入输出样例 #1

### 输入 #1

```
4 5
WRWRW
BWRWB
WRWRW
RWBWR
```

### 输出 #1

```
11
```

## 说明/提示

### 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```
一共需要改 $11$ 个格子。

### 数据范围

对于 $100\%$ 的数据，$N,M \leq 50$。

### 题解：

```cpp
int n,m,ans,mi=inf;//mi初始化成一个很大的数
char c[N][N];
int main()
{
	int i,j,k,g;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	  for(j=1;j<=m;j++) cin>>c[i][j];
	for(i=1;i<=n-2;i++)//由于白色下面还有蓝色和红色，所以i（白与蓝的边界）枚举到（n-2）
	  for(j=i+1;j<=n-1;j++)//j（蓝与红的边界）至少要比i大1，同理枚举到（n-1），这样可以减少枚举次数
	  {
	    ans=0;//初始化
        //壮观地枚举三个区域
	    for(k=1;k<=i;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='W') ans++;
	    for(k=i+1;k<=j;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='B') ans++;
	    for(k=j+1;k<=n;k++)
	      for(g=1;g<=m;g++) if(c[k][g]!='R') ans++;
        //强迫症（本蒟蒻）看到这些语句表示很开心
	    mi=min(ans,mi);//更新答案
	  }
	cout<<mi<<endl;
	return 0;
}
```

## 例题：看lovelive看的

## 题目背景

> **知らないことばかりなにもかもが（どうしたらいいの？）**    
> **一切的一切 尽是充满了未知数（该如何是好）**   
> **それでも期待で足が軽いよ（ジャンプだ！）**     
> **但我仍因满怀期待而步伐轻盈（起跳吧！）**       
> **温度差なんていつか消しちゃえってね**     
> **冷若冰霜的态度 有朝一日将会消失得无影无踪**      
> **元気だよ元気をだしていくよ**     
> **拿出活力 打起精神向前迈进吧**     

 ![](C:\Users\asus\Desktop\程序设计\算法笔记\大章枚举\算法：枚举.assets\4471.png) 

我们 Aqours，要第一次举办演唱会啦！

虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！

歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！

演唱会一定会顺利进行的！

希望不要发生**停电**什么的事故哦……！

## 题目描述

可是……这个篮球场，好像很久没有使用过的样子啊……

里面堆满了学校的各种杂物呢……

我们 Aqours 的成员要怎么在里面列队站下呢？


我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……

我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。

我们想知道一共有多少种可行的站位方式呢。

Aqours 的真正的粉丝的你，能帮我们算算吗？

## 输入格式

第一行三个整数 $R, C, K$。

接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。

## 输出格式

总共的站位方式数量。

## 输入输出样例 #1

### 输入 #1

```
5 5 2
.###.
##.#.
..#..
#..#.
#.###
```

### 输出 #1

```
8
```

## 说明/提示

|           |    $R$     |    $C$     |       $K$        |   备注   |
| :-------: | :--------: | :--------: | :--------------: | :------: |
| $1\sim2$  | $\leq 10$  | $\leq 10$  | $\leq \min(R,C)$ |    无    |
| $3\sim4$  | $\leq 100$ | $\leq 100$ |     $\leq 1$     |    无    |
| $5\sim6$  | $\leq 100$ | $\leq 100$ | $\leq \min(R,C)$ | 没有障碍 |
| $7\sim10$ | $\leq 100$ | $\leq 100$ | $\leq \min(R,C)$ |    无    |

对于所有数据，$1 \leq R,C \leq 100$，$1 \leq k \leq \min(R,C)$。

#### 以下是彩蛋

在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int r,c,k;
char a[105][105];

int main(){
    cin>>r>>c>>k;
    for (int i=1;i<=r;i++){
        for (int j=1;j<=c;j++){
            cin>>a[i][j];
        }
    }
    int ans=0;
    bool f=true;
    if (k==1){
        for (int i=1;i<=r;i++){
            for (int j=1;j<=c;j++){
                if (a[i][j]=='.') ans++;
            }
        }
    }else{
        for(int i=1;i<=r;i++)//横向搜索
	{
		for(int j=1;j<=c;j++)
		{
			f=true;
			for(int s=0;s<k;s++)
			{
				if(a[i+s][j]!='.')
				{
					f=false;
					break;
				}
			}
			if(f==true)
			{
				ans++;
			}
		}
	}
	for(int i=1;i<=r;i++)//纵向搜索
	{
		for(int j=1;j<=c;j++)
		{
			f=true;
			for(int s=0;s<k;s++)
			{
				if(a[i][j+s]!='.')
				{
					f=false;
					break;
				}
			}
			if(f==true)
			{
				ans++;
			}
		}
	}
    }
      cout<<ans<<endl;
      return 0;  
}
```

### 思路：

这种题目其实比较优秀的思路应该是搜索，但我这里用了枚举

其实思路很简单啊，就是去枚举每一个点，然后找到符合条件的点就往右边和下面延伸，再判断

记得在只有一人的时候要特判一下

## 例题：

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 输入格式

第一行一个整数 $n$。

第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。

## 输出格式

一行一个整数代表答案。

## 输入输出样例 #1

### 输入 #1

```
4 
1
1
2
2
```

### 输出 #1

```
1
```

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

### 题解：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5*1e3+500,mod=1e9+7;
int num[maxn],n,Max=-1,Min=0x3f3f,ans=0;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		num[a]++;
		Max=max(Max,a);Min=min(Min,a);
	}
	for(int i=Min+1;i<=Max;i++)
	{
		if(num[i]>=2)
		{
			for(int j=Min;j<=i/2;j++)
			{
				if(j!=i-j)
					ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;
				else if(num[j]>=2&&j*2==i)
					ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;
			}
			ans%=mod;
		}
	}
	cout<<ans;
}
```

### 思路：

![img](C:\Users\asus\Desktop\程序设计\算法笔记\大章枚举\算法：枚举.assets\aae08ab0d8371bbe5cc77fd4086ff27f.png)

## 例题：

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。

## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。

## 输入格式

本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。

第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。

第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。

第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。

第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。

## 输出格式

输出一行,为复习完毕最短时间。

## 输入输出样例 #1

### 输入 #1

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 输出 #1

```
20
```

## 说明/提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5],i,j,k,sum,t,homework[21],dp[2501];
int main(){
	for(i=1;i<=4;i++)
		cin>>a[i];
	for(i=1;i<=4;i++){
		sum=0;	
		for(j=1;j<=a[i];j++)
			{cin>>homework[j];//输入
			sum+=homework[j];}//总时间累加
		for(j=1;j<=a[i];j++)
			for(k=sum/2;k>=homework[j];k--)//只要是总和的一半
				dp[k]=max(dp[k],dp[k-homework[j]]+homework[j]);//01背包
		t+=sum-dp[sum/2];//累加为另一个脑子
		for(j=1;j<=sum/2;j++)
		dp[j]=0;//清零
	}
	cout<<t;//输出
	return 0;
}
```

### 思路：

这一题主要是一个01背包的问题，我先复制一下大佬题解

```
后来思考了一下，便感觉是dp，对于一道题只有两个状态，一是加到左脑，二是加到右脑，所以是01背包
这里还可以用另一个思想，将一边的脑子加到最接近一半则另一边脑子时间就是正解
```

然后，最玄学的13行和14行其实是个模板，意思是求出最接近背包容量的最大值。

模板：

```cpp
// 初始化：dp数组全为0
vector<int> dp(C + 1, 0);

// 动态规划计算
for(int i = 0; i < n; i++) {
    for(int j = C; j >= w[i]; j--) {  // 从后向前遍历，避免覆盖
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

- 物品数量 `n`

- 背包容量 `C`

- 物品重量数组 `w[]`

- 物品价值数组 `v[]`

- 定义二维数组 `dp[i][j]` 表示考虑前 `i` 个物品时，背包容量为 `j` 时能获得的最大价值

  这段代码的01背包优化部分是实现问题解决方案的核心，我将通过分解其工作原理、执行步骤和数学证明来详细解释：

  ## 代码段分析

  ```
  for(j=1;j<=a[i];j++) {
      for(k=sum/2;k>=homework[j];k--) {
          dp[k]=max(dp[k],dp[k-homework[j]]+homework[j]);
      }
  }
  ```

  ### 1. 问题抽象

  - **背包容量**：`sum/2`（该科目总作业时间的一半）
  - **物品**：每个作业看作一个物品
  - **物品重量**：作业时间 `homework[j]`
  - **物品价值**：同样是作业时间 `homework[j]`
  - **目标**：在不超过容量 `sum/2` 的前提下，最大化装入背包的作业价值（时间总和）

  ### 2. 执行过程分解

  以示例数据说明：作业时间 `homework = [3, 4, 5]`，总时间 `sum=12`，`sum/2=6`

  **初始化状态**：`dp = [0, 0, 0, 0, 0, 0]` (索引0-5)

  **第一层循环(j=0) - 作业3**:
   背包容量k从6降到3

  - `k=6`: `dp[6] = max(dp[6], dp[6-3]+3) = max(0, dp[3]+3) = 0+3=3`
  - `k=5`: `dp[5] = max(0, dp[2]+3) = 3`
  - `k=4`: `dp[4] = max(0, dp[1]+3) = 3`
  - `k=3`: `dp[3] = max(0, dp[0]+3) = 3`
     更新后：`dp = [0,0,0,3,3,3,3]`

  **第二层循环(j=1) - 作业4**:
   背包容量k从6降到4

  - `k=6`: `max(dp[6]=3, dp[6-4]+4) = max(3, dp[2]+4)=max(3,0+4)=4`
  - `k=5`: `max(3, dp[5-4=1]+4)=max(3,0+4)=4`
  - `k=4`: `max(3, dp[0]+4)=4`
     更新后：`dp = [0,0,0,3,4,4,4]`

  **第三层循环(j=2) - 作业5**:
   背包容量k从6降到5

  - `k=6`: `max(dp[6]=4, dp[6-5]+5)=max(4, dp[1]+5)=max(4,5)=5`
  - `k=5`: `max(4, dp[0]+5)=5`
     更新后：`dp = [0,0,0,3,4,5,5]`

  ### 3. 数学意义证明

  通过动态规划达到以下效果：

  ```
  dp[k] = 在容量k下可达到的最大时间总和
          = max{∑homework[j] | 所选作业∑homework[j] ≤ k}
  ```

  最终 `dp[sum/2] = 5` 表示：

  - 可达到的最近接 sum/2(6) 的时间总和为5
  - 剩余作业时间 = 12-5 = 7
  - 实际分组：
    - 组A(背包): 作业3和4？不对，实际最优组合是3和5(3+5=8)？但为何dp[6]=5？

  ### 4. 关键理解：为何这样工作？

  实际上，算法找到的是**不超过容量限制下的最大时间组合**，不一定正好包含当前作业。在示例中：

  - 当处理作业5时(k=6)：

    ```
    dp[6] = max(当前最优4, 包含5的选项)
    包含5的选项：需要剩余容量1，查看dp[1]=0，所以是0+5=5
    选择5比现有的4更好
    ```

  最终dp[6]=5意味着找到了包含作业5(时间5)的方案，此时背包剩余容量1无法装入其他作业。

  ### 5. 倒序遍历的重要性

  代码关键点：`for(k=sum/2; k>=homework[j]; k--)`

  **为何需要倒序？**

  正序遍历会导致同一个物品被多次使用：

  ```
  如果正序(k=3→6)
  初始: dp[3]=3
  当k=6时: dp[6]=max(dp[6], dp[3]+3)=0+3+3=6? 
  → 错误地使用了同一个作业两次
  ```

  倒序遍历确保每个物品只使用一次，因为计算dp[k]时，dp[k-homework[j]]使用的是前一物品的状态。

  ### 6. 最终价值计算

  ```
  t += sum - dp[sum/2];
  ```

  - `dp[sum/2]`：背包中作业的最小组合时间
  - `sum - dp[sum/2]`：剩余作业时间（即两个大脑中较大者）
  - `t` 累计所有科目中较大者的时间

  ### 7. 算法正确性证明

  设S为该科目所有作业时间的集合，算法找到：

  ```
  分组结果：组A ⊆ S, 组B = S - A
  使得 |∑(组A) - ∑(组B)| 最小化
  ```

  数学上等价于：

  ```
  最小化 max(∑A, ∑B) 
  = 最小化 max(∑A, sum-∑A)
  = 最小化 |2∑A - sum|
  ```

  这恰好是01背包问题在容量限制为sum/2下的最优解。

  ### 8. 算法复杂度分析

  - 外层循环：作业数量n（≤20）
  - 内层循环：背包容量V=sum/2（≤3000/2=1500）
  - 总复杂度：O(n×V) ≈ 20×1500=30,000次操作
  - 空间复杂度：O(V)，仅需一维数组

  这种基于01背包的优化方案高效地解决了作业分组问题，通过巧妙地转换问题，利用动态规划避免了穷举所有可能分组组合（2^n指数级复杂度）。
  
  
