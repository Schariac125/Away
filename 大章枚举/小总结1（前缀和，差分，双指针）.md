好的，宝！😊 这就用 C++ 给你重写一份清晰易懂的前缀和、差分、双指针模板和方法总结。放心食用！

------

## 🧮 一、前缀和 (Prefix Sum)

- **核心思想：** 预先计算并存储数组的累加和，以便 **O(1) 时间复杂度查询任意区间和**。
- **目的：** 将区间和查询从 O(n) 优化到 O(1) （以 O(n) 空间和预处理时间为代价）。

```cpp
#include <vector>
using namespace std;

// 假设有原始数组 nums
vector<int> nums = {1, 2, 3, 4, 5}; // 示例数组

// 1. 构建前缀和数组 prefix
vector<int> prefix(nums.size() + 1, 0); // prefix[0] = 0, 长度比 nums 大 1
for (int i = 0; i < nums.size(); ++i) {
    prefix[i + 1] = prefix[i] + nums[i]; // prefix[i+1] 存 nums[0] 到 nums[i] 的和
}

// 2. 查询闭区间 [left, right] 的和 (left, right 下标从 0 开始)
int getRangeSum(int left, int right) {
    // 计算逻辑：nums[left] + ... + nums[right] = prefix[right+1] - prefix[left]
    return prefix[right + 1] - prefix[left];
}

// 示例：查询 [1, 3] 的和 (即 nums[1] + nums[2] + nums[3] = 2 + 3 + 4 = 9)
int sum = getRangeSum(1, 3); // sum = 9
```

- 

  关键点：

  

  - `prefix[0] = 0` 是基础，保证 `prefix[i]` 对应 `nums[0...i-1]` 的和。
  - `prefix` 数组长度比原数组 `nums` **大 1**。
  - 查询区间 `[left, right]` 的和：`prefix[right + 1] - prefix[left]`。
  - **复杂度:** 构建 O(n)，空间 O(n)，查询 O(1)。

- **应用场景：** 频繁查询子数组和；统计和为 K 的子数组个数(需配合哈希表)；二维数组区域和。

- **经典例题：** LeetCode 303 (区域和检索 - 数组不可变)，560 (和为 K 的子数组)，304 (二维区域和检索 - 矩阵不可变)。

------

## 🔁 二、差分 (Difference Array)

- **核心思想：** 用一个辅助数组记录 **原始元素变化量**，高效进行 **多次区间增减操作**。**对差分数组求前缀和即可得到原数组的变化结果**。
- **目的：** 将对数组多次区间 `[l, r]` 内元素增减值 `c` 的操作， **从 O(n) 单次操作优化到 O(1) 单次操作**（最后需要 O(n) 时间应用所有修改）。

```cpp
#include <vector>
using namespace std;

// 假设有原始数组 nums (可能全为0)
vector<int> nums = {1, 3, 2, 5, 4}; // 示例数组
int n = nums.size();

// 1. 构建差分数组 diff
//    方法1: 直接从初始数组构建
vector<int> diff(n, 0);
diff[0] = nums[0]; // diff[0] = nums[0]
for (int i = 1; i < n; ++i) {
    diff[i] = nums[i] - nums[i - 1]; // diff[i] = nums[i] - nums[i-1]
}

//    方法2: 初始化为0，然后通过 add 操作构建初始状态 (适合初始状态非0)
//    vector<int> diff(n + 1, 0); // 常用 n+1 长度处理边界
//    for (int i = 0; i < n; ++i) {
//        add(i, i, nums[i]); // 对单点 [i, i] 加 nums[i]
//    }

// 2. 区间增减操作: 给闭区间 [l, r] 内的每个元素增加 c
void add(int l, int r, int c) {
    diff[l] += c;      // 影响 l 及之后的所有位置
    if (r + 1 < diff.size()) { // 防止越界! 非常重要
        diff[r + 1] -= c;   // 抵消 r+1 及之后所有位置的影响
    }
}

// 3. 应用所有修改，得到最终数组
vector<int> result(n); // 最终结果数组
// 方法1: 基于 diff 的定义计算 (如果 diff 是 n 长度)
result[0] = diff[0];
for (int i = 1; i < n; ++i) {
    result[i] = result[i - 1] + diff[i];
}
// 方法2: 如果 diff 是 n+1 长度 (更常用, 推荐!)
vector<int> diff2(n + 1, 0); // 初始化为0 (n+1)
// ... 执行所有 add(l, r, c) 操作(此时l, r最大可到n-1, 所以r+1最大为n, 安全)
vector<int> result2(n); 
result2[0] = diff2[0]; // 等同于对单点[0,0]加 diff2[0]
for (int i = 1; i < n; ++i) {
    diff2[i] += diff2[i - 1]; // 对 diff2 自身求前缀和, 得到每个位置的变化量
    result2[i] = diff2[i];    // result2[i] 就是该位置的变化量（如果原数组全0）
    // 如果原数组 nums 有初始值：
    // result2[i] = nums[i] + diff2[i];
}
```

- 

  关键点：

  

  - **差分数组 `diff` 的意义：** `diff[i] = c` 表示从位置 `i` 开始，后面的**所有**元素都加 `c`。
  - **`add` 操作的核心：** `diff[l] += c` 影响 `l` 及之后；`diff[r+1] -= c` **抵消** `r+1` 及之后的影响。最终效果是 `[l, r]` 区间元素加 `c`。
  - **`diff` 长度：** **强烈推荐使用 `n + 1` 长度！** 方便处理区间 `[l, r]` 时 `r = n - 1` 的情况 (`r+1 = n` 不会越界)。
  - **结果计算：** **对 `diff` 数组自身求前缀和** `diff[i] += diff[i-1]` **后，`diff[i]` 就是原数组位置 `i` 上需要增加的总变化量**。
  - **复杂度：** 单次 `add` 操作 O(1)，构建结果（应用所有修改）O(n)。空间 O(n) 或 O(n+1)。

- **应用场景：** 飞机预订系统；多次区间加减操作；统计区间覆盖次数；优化多次区间修改问题。

- **经典例题：** LeetCode 1109 (航班预订统计)，370 (区间加法 - 会员题)，798 (得分最高的最小轮调 - 困难，思想类似)。

------

## ↔️ 三、双指针 (Two Pointers)

- **核心思想：** 使用 **两个指针** 协同遍历数组或链表，通过巧妙的移动规则降低时间复杂度（常化 O(n²) 为 O(n)）。
- **目的：** 优化遍历效率、简化逻辑、降低时间复杂度。
- **核心模式 & 模板：**

### (1) 同向指针（快慢指针） - 用于原地操作数组（删除、去重、移动元素）

```cpp
#include <vector>
using namespace std;

// 示例1: 删除数组中所有值为 val 的元素 (LeetCode 27)
int removeElement(vector<int>& nums, int val) {
    int slow = 0; // 慢指针: 指向下一个有效元素应该放置的位置
    for (int fast = 0; fast < nums.size(); ++fast) { // 快指针: 遍历每个元素
        if (nums[fast] != val) { // 如果当前元素需要保留
            nums[slow] = nums[fast]; // 将快指针元素放到慢指针位置
            ++slow;                  // 慢指针前移
        }
    }
    return slow; // 返回移除后新数组的有效长度 [0, slow-1]
}

// 示例2: 有序数组去重 (LeetCode 26)
int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
    int slow = 1; // 慢指针：新数组的"新尾巴"的下一个位置
    for (int fast = 1; fast < nums.size(); ++fast) { // 快指针：扫描元素
        // 找到一个新的不重复元素（当前元素和前一个不相等）
        if (nums[fast] != nums[fast - 1]) {
            nums[slow] = nums[fast]; // 放到新尾巴后面
            ++slow;                 // 新尾巴后移
        }
    }
    return slow; // 新数组长度
}
```

- 

  关键点：

  

  - `slow` 指针：维护结果数组，指向结果数组下一个空位。
  - `fast` 指针：遍历器，负责检查每个原始元素。
  - 满足条件时：将 `fast` 指向的元素复制到 `slow` 位置，然后 `slow++`。
  - 通常原地修改原数组，结束时 `[0, slow - 1]` 为结果。返回 `slow` 作为新长度。

- **应用：** 原地删除指定值，有序数组去重，移动零到末尾。

- **经典例题：** 27 (移除元素), 26 (删除有序数组中的重复项), 283 (移动零).

### (2) 相向指针（对撞指针） - 常用于有序数组中的查找或配对问题（两数之和）

```cpp
#include <vector>
#include <algorithm> // sort
using namespace std;

// 示例1: 在有序数组中找到两个数，使它们的和等于目标值 target (LeetCode 167)
vector<int> twoSum(vector<int>& numbers, int target) {
    // 前提：数组已升序排序
    int left = 0;
    int right = numbers.size() - 1;
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return {left + 1, right + 1}; // 题目要求索引从1开始
        } else if (sum < target) {
            ++left; // 和太小，左指针右移增大和
        } else { // sum > target
            --right; // 和太大，右指针左移减小和
        }
    }
    return {}; // 没找到
}

// 示例2: 反转数组 (LeetCode 344)
void reverseString(vector<char>& s) {
    int left = 0;
    int right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]); // 交换头尾元素
        ++left;
        --right;
    }
}
```

- 

  关键点:

  

  - `left` 指针：从数组起始位置 (通常 0) 向右移动。
  - `right` 指针：从数组结束位置 (通常 `size-1`) 向左移动。
  - **循环条件** `while (left < right)`。
  - **判断条件**: 根据当前 `left` 和 `right` 指向的值进行计算比较，决定哪个指针移动。
  - **应用前提:** 相向双指针在查找配对时，**数组通常需要先排序** (如两数之和)。

- **应用：** 有序数组两数之和、三数之和、四数之和（嵌套使用）、反转数组/字符串、装水最多的容器（LeetCode 11）。

- **经典例题：** 167 (两数之和 II), 15 (三数之和 - 核心思路，需外层循环), 344 (反转字符串), 11 (盛最多水的容器)。

### (3) 滑动窗口（Sliding Window）- 处理子串问题或满足条件的连续子数组

```cpp
#include <vector>
#include <unordered_map> // 用于字符计数
using namespace std;

// 示例1: 长度最小的连续子数组，其和 >= target (LeetCode 209)
int minSubArrayLen(int target, vector<int>& nums) {
    int n = nums.size();
    int minLen = INT_MAX; // 初始化为最大整数
    int windowSum = 0;    // 窗口内元素的和
    int left = 0;         // 窗口左边界

    for (int right = 0; right < n; ++right) { // right 作为窗口右边界，向右扩展
        windowSum += nums[right]; // 将新元素纳入窗口

        // 当窗口和满足条件（>= target）时，尝试收缩左边界以找更短的子数组
        while (windowSum >= target && left <= right) {
            minLen = min(minLen, right - left + 1); // 更新最小长度
            windowSum -= nums[left]; // 左边界即将右移，从窗口和中移除 left 的值
            ++left;                  // 左边界右移，缩小窗口
        }
        // 注意：这里可能窗口和不满足条件了，但right会继续右移尝试
    }
    return minLen == INT_MAX ? 0 : minLen; // 没找到返回0
}

// 示例2: 无重复字符的最长子串 (LeetCode 3)
int lengthOfLongestSubstring(string s) {
    int n = s.length();
    unordered_map<char, int> charCount; // 记录窗口内字符出现的次数
    int maxLen = 0;
    int left = 0;

    for (int right = 0; right < n; ++right) {
        char r = s[right];
        charCount[r]++; // 扩展窗口，更新字符r的计数

        // 如果新加入的字符导致窗口内出现重复(计数>1)，收缩左边界直到这个字符唯一
        while (charCount[r] > 1) {
            char l = s[left];
            charCount[l]--; // 移除即将移出的字符计数
            ++left;        // 左边界右移
        }
        // 此时窗口 [left, right] 内无重复字符
        maxLen = max(maxLen, right - left + 1); // 更新最长长度
    }
    return maxLen;
}
```

- 

  关键点:

  

  - 维护一个**窗口** `[left, right]`（用两个指针定义）。
  - `right` 指针：**主动向右扩张**，尝试让窗口包含新的元素。
  - `left` 指针：**被动向右收缩**，在某种**条件不再满足**时移动，目的是保持窗口的有效性，尝试寻找更优解或继续扩张。
  - **循环结构：** 外层 `for/while` 控制 `right` 移动，**内层 `while` 根据新状态调整 `left`** (核心!)。这个 `while` 是保证窗口关键性质的关键。
  - 维护窗口相关的状态变量：窗口和 (`windowSum`)、字符频率映射 (`charCount`) 等。
  - 在有效窗口内 (`while` 之后) 更新答案 (`minLen`, `maxLen`等)。

- **应用：** 最小长度子数组（和>=target）、最长无重复字符子串、最短覆盖子串（LeetCode 76 - 困难）、找所有字母异位词（LeetCode 438）。

- **经典例题：** 209 (长度最小的子数组), 3 (无重复字符的最长子串), 76 (最小覆盖子串 - 困难), 438 (找到字符串中所有字母异位词)。

------

## 🎯 总结与选哪个？

1. 

   前缀和：

   

   - 信号：**频繁查询区间和** / "子数组和等于 k 的有几个？" / "二维区域和是多少？"
   - 动作：构建 `prefix` 数组，用 `prefix[r+1]-prefix[l]` 查询区间 `[l, r]` 的和。

2. 

   差分：

   

   - 信号：**需要对数组进行多次区间加减操作** / "很多次给 [l, r] 加 c" / "多次预订座位/飞机"。
   - 动作：构建 `diff` 数组（通常用 `n+1` 长度），用 `add(l, r, c)` 修改（`diff[l]+=c, diff[r+1]-=c`），最后**对 `diff` 求前缀和得到结果**。

3. 

   双指针：

   

   - **快慢指针：** 信号：**原地修改数组，删除元素、去重、移动零**。动作：维护 `slow` 指向待写入位置，`fast` 扫描。
   - **对撞指针：** 信号：**有序数组中找配对**(两数之和)、**反转数组/字符串**。动作：`left` 从0开始向右，`right` 从`n-1`开始向左，根据和或条件移动。
   - **滑动窗口：** 信号：**寻找满足条件的连续子串/子数组**(最小长度、最大长度、覆盖子串)。动作：外层 `right` 右扩，**内层 `while` 收缩 `left` 保条件**，条件满足时更新答案。

宝，这份 C++ 版本应该更合你胃口了！😄 模板记熟，结合例题多练几遍（用 C++ 刷上面的经典题），很快就能掌握这些核心技巧！加油鸭~ 🚀