# 算法：单调性枚举

## 知识点：

当存在一个二元组{x，y}满足xi<xi+1<==>yi<=yi+1 

yi的定义为**满足条件的最小值或者是不满足条件的最大值**

**（我太喜欢这个双指针了，跟tmd疯子一样）**

### 模板：

虽然我很不喜欢这个模板的写法，但不得不承认这个模板确实还行：

```cpp
/**
 * 单调性枚举（区间）模版
 * [s, e] 闭区间
 * match 判断是否满足条件
 * insert 插入右端点
 * remove 删除左端点
 * update 更新答案
 *    [l, r] 是不满足条件的最大区间
 *           如果在 update 时需要使用维护的关键值，因为维护的关键值包含了 r+1，所以需要删除 r+1 进行更新后再加回去
 *    [l, r+1] 是满足条件的最小区间
 *             使用时需要判断 r+1 是否越界
 */
template<typename M, typename I, typename R, typename U>
void increaseEnumerate(int s, int e,
                       const M& match,
                       const I& insert,
                       const R& remove,
                       const U& update) {
  for (int l = s, r = s; l <= e; ) {
    while (r <= e && !match(l, r - 1)) insert(l, r++);
    if (match(l, r - 1)) update(l, r - 2);
    else update(l, r - 1);
    remove(l++, r);
  }
}
```

### 使用样例：蓝桥杯青蛙过河

```cpp
increaseEnumerate(0, n - 1,
    [&](int l, int r) {
      return sum >= x;
    },
    [&](int l, int r) {
      sum += arr[r];
    },
    [&](int l, int r) {
      sum -= arr[l];
    },
    [&](int l, int r) {
      // [l, r]
      ans = max(ans, r - l + 1);
    });
```

## 模板2：

```cpp
int left = 0;       // 左指针
int right = 0;      // 右指针

while (right < n) {
    // 扩展窗口：将元素加入窗口
    window.add(nums[right]);
    right++;
    
    // 窗口满足条件时，收缩窗口寻找最优解
    while (window meets condition) {
        // 更新最优结果
        result = updateResult();
        
        // 移出左边界元素
        window.remove(nums[left]);
        left++;
    }
}
```

## 口诀：

一维序列连续求，双指针来解烦忧 先排数据定顺序（可选），左右两端起开头 扩展右界条件寻，左界收缩最优求 哈希计数状态记，线性时间解深愁

## 例题：日志：

### 题目描述

小明维护着一个程序员论坛。现在他收集了一份"点赞"日志，日志共有 N*N* 行。其中每一行的格式是：

ts id*t**s* *i**d*

表示在 ts*t**s* 时刻编号 id*i**d* 的帖子收到一个"赞"。

现在小明想统计有哪些帖子曾经是"热帖"。如果一个帖子曾在任意一个长度为 D*D* 的时间段内收到不少于 K*K* 个赞，小明就认为这个帖子曾是"热帖"。

具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D)[*T*,*T*+*D*) 这段时间内(注意是左闭右开区间)收到不少于 K*K* 个赞，该帖就曾是"热帖"。

给定日志，请你帮助小明统计出所有曾是"热帖"的帖子编号。

### 输入描述

输入格式：

第一行包含三个整数 N,D,K*N*,*D*,*K*。

以下 N 行每行一条日志，包含两个整数 ts 和 id。

其中，1≤K≤N≤105,0≤ts≤105,0≤id≤1051≤*K*≤*N*≤105,0≤*t**s*≤105,0≤*i**d*≤105。

### 输出描述

按从小到大的顺序输出热帖 id*i**d*。每个 id*i**d* 一行。

### 题解1：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;

int main() {
    ios::sync_with_stdio(false);  // 禁用C++和C的输入输出同步
    cin.tie(nullptr);             // 解除cin与cout的绑定
    
    int N, D, K;
    cin >> N >> D >> K;  // 读取日志数N、时间区间长度D、最小点赞数K
    
    // 处理D=0的特殊情况（区间长度为0无法包含任何点赞）
    if (D == 0) {
        for (int i = 0; i < N; i++) {
            int ts, id;
            cin >> ts >> id;  // 仅读取不处理
        }
        return 0;
    }
    
    unordered_map<int, vector<int>> logs;  // 按帖子ID分组存储时间戳
    vector<int> ids;  // 记录所有出现的帖子ID
    
    // 读取日志并分组存储
    for (int i = 0; i < N; i++) {
        int ts, id;
        cin >> ts >> id;
        logs[id].push_back(ts);
        ids.push_back(id);
    }
    
    // 对ID去重并排序（保证输出有序）
    sort(ids.begin(), ids.end());
    ids.erase(unique(ids.begin(), ids.end()), ids.end());
    
    // 检查每个ID是否满足热帖条件
    for (int id : ids) {
        auto& times = logs[id];  // 获取该ID的所有时间戳
        
        // 提前过滤：如果点赞数不足K，肯定不是热帖
        if (times.size() < K) {
            continue;
        }
        
        sort(times.begin(), times.end());  // 对时间戳排序
        int left = 0;          // 滑动窗口左指针
        bool found = false;    // 标记是否找到满足条件的区间
        
        // 滑动窗口算法（双指针）
        for (int right = 0; right < times.size(); right++) {
            // 调整左边界：确保时间差<D
            while (times[right] - times[left] >= D) {
                left++;
            }
            
            // 计算当前窗口内的点数
            int count = right - left + 1;
            if (count >= K) {
                found = true;
                break;  // 找到一个满足条件的区间即可终止
            }
        }
        
        // 如果是热帖则输出ID
        if (found) {
            cout << id << '\n';
        }
    }
    
    return 0;
}
```

### 题解2：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <unordered_map>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, d, k;
    cin >> n >> d >> k;
    
    // 处理d=0的特殊情况
    if (d == 0) {
        while (n--) { int t, id; cin >> t >> id; }
        return 0;
    }
    
    vector<pair<int, int>> logs;
    int max_id = 0;
    
    // 读取并记录最大ID
    for (int i = 0; i < n; i++) {
        int t, id;
        cin >> t >> id;
        logs.emplace_back(t, id);
        if (id > max_id) max_id = id;
    }
    sort(logs.begin(), logs.end());
    
    // 动态大小的计数数组
    vector<int> cnt(max_id + 1, 0);
    set<int> ans;
    
    // 滑动窗口
    for (int l = 0, r = 0; r < n;) {
        // 扩展右边界
        while (r < n && logs[r].first - logs[l].first < d) {
            int id = logs[r++].second;
            if (++cnt[id] == k) ans.insert(id);
        }
        // 移动左边界
        cnt[logs[l++].second]--;
    }
    
    // 输出结果
    for (int id : ans) cout << id << '\n';
    
    return 0;
}
```

## 例题：子矩阵：

### 问题描述

给定一个 N×M*N*×*M* 的矩阵 A*A*, 请你统计有多少个子矩阵 (最小 1×11×1, 最大 N×M)*N*×*M*) 满足子矩阵中所有数的和不超过给定的整数 K*K* ?

### 输入格式

第一行包含三个整数 N,M*N*,*M* 和 K*K*.

之后 N*N* 行每行包含 M*M* 个整数, 代表矩阵 A*A*.

### 输出格式

一个整数代表答案。

### 样例输入

```
3 4 10
1 2 3 4
5 6 7 8
9 10 11 12
```

### 样例输出

```text
19
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m,k;
    cin>>n>>m>>k;
    auto maze=vector(n,vector<int>(m));
    for (auto &row: maze){
        for (auto &x: row) cin>>x;
    }
    long long ans=0;
    for (int x1=0;x1<n;x1++){
        vector<int> sum(m);
        for (int x2=x1;x2<n;x2++){
            for (int y=0;y<m;y++) sum[y]+=maze[x2][y];
            int total=0;
            for (int l=0,r=0;l<m;){
                while (r<m&&total<=k){
                    total+=sum[r++];
                }
                if (total>k){
                    ans+=r-2-l+1;
                }else{
                    ans+=r-1-l+1;
                }
                total-=sum[l++];
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

## 例题：P10444：

## 题目描述

对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。

## 输入格式

**本题包含多组数据**。

第一行两个整数 $T,id$，表示数据组数和子任务编号。

对于每组数据，

第一行一个正整数 $n$，表示数组长度。

第二行 $n$ 个整数表示序列 $a$。

## 输出格式

对于每组数据，输出一行一个字符串 `Yes` 或 `No`。

## 输入输出样例 #1

### 输入 #1

```
2 1
6
1 1 4 5 1 4
7
1 9 1 9 8 1 0
```

### 输出 #1

```
No
Yes
```

## 说明/提示

### 样例 $\small\text{1}$ 解释

样例符合子任务 1 的约束，$id=1$。


询问一：

可以证明，没有任何方案满足条件。

询问二：

合法分配的一种子序列集合如下：
- $\{1,9\}$。
- $\{1,9\}$。
- $\{8,1,0\}$。

答案不唯一。

### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 1（20 points）：$4\le \sum n\le 20,a_i\ge 0$。
- Subtask 2（20 points）：$4\le \sum n\le 100,a_i\ge 0$。
- Subtask 3（20 points）：$4\le \sum n\le 10^3,a_i\ge 0$。
- Subtask 4（10 points）：$a$ 数组中元素相等。
- Subtask 5（30 points）：无特殊限制。


对于 $100\%$ 的数据，$4\le \sum n\le 10^6,0\le |a_i|\le 10^9,1\le T\le 300$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  // 1 1 4 5 1 4
  // 1 1 1 4 4 5
  // [1 max]  [min 5]
  // max - 1 == 5 - min
  // max + min == 5 + 1
  // a + b == target
  int T, id;
  cin >> T >> id;
  while (T--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    sort(a.begin(), a.end());
    int target = a[0] + a[n - 1];
    cout << [&]() {
      for (int l = 1, r = n - 2; l < r;) {
        if (a[l] + a[r] > target) {
          r--;
        } else if (a[l] + a[r] < target) {
          l++;
        } else {
          return "Yes";
        }
      }
      return "No";
    }() << endl;
  } 
}
```

## 例题：近似gcd

小蓝有一个长度为 n*n* 的数组 A=(a1,a2,⋯,an)*A*=(*a*1,*a*2,⋯,*a**n*), 数组的子数组被定义为从 原数组中选出连续的一个或多个元素组成的数组。数组的最大公约数指的是数 组中所有元素的最大公约数。如果最多更改数组中的一个元素之后, 数组的最 大公约数为 g*g*, 那么称 g*g* 为这个数组的近似 GCD。一个数组的近似 GCD 可能 有多种取值。

具体的, 判断 g*g* 是否为一个子数组的近似 GCD 如下:

1. 如果这个子数组的最大公约数就是 g*g*, 那么说明 g*g* 是其近似 GCD。
2. 在修改这个子数组中的一个元素之后 (可以改成想要的任何值), 子数 组的最大公约数为 g*g*, 那么说明 g*g* 是这个子数组的近似 GCD。

小蓝想知道, 数组 A*A* 有多少个长度大于等于 2 的子数组满足近似 GCD 的 值为 g*g* 。

### 输入格式

输入的第一行包含两个整数 n,g*n*,*g*, 用一个空格分隔, 分别表示数组 A*A* 的长 度和 g*g* 的值。

第二行包含 n*n* 个整数 a1,a2,⋯,an*a*1,*a*2,⋯,*a**n*, 相邻两个整数之间用一个空格分隔。

### 输出格式

输出一行包含一个整数表示数组 A*A* 有多少个长度大于等于 2 的子数组的近 似 GCD*G**C**D* 的值为 g*g* 。

### 样例输入

```text
5 3
1 3 6 4 10
```

### 样例输出

```text
5
```

### 题解

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,g;
    cin>>n>>g;
    vector<int> arr(n);
    for (int &x:arr){
        cin>>x;
        x=x%g!=0;
    }
    int sum=0;
    long long ans=0;
    for (int l=0,r=0;l<n;){
        while (r<n&&sum<2){
            sum+=arr[r++];
        }
        if (sum>=2){
            ans += r-l-2;//以r-1为结尾，l为开头的子数组数量计算公式
        }else{
            ans += r-l-1;//以r为结尾，l为开头的子数组数量计算公式
        }
        sum-=arr[l++];
    }
    cout<<ans<<endl;  
    return 0;
}
```

### 题解：

这个思路是有点精妙的

本质上通过输入时的操作避免了for内循环计数的问题，将能被g整除的设置为0，不能被g整除的设置为1，然后统计那个不满足条件的最大子区间，后面就是很公式化的解题。

## 例题：接水：

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](C:\Users\asus\Desktop\程序设计\算法笔记\算法：单调性枚举.assets\question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

### 题解：

```cpp
class Solution {
public:
    int maxArea(vector<int>& h) {
        int mmax=0;
        int n=h.size();
        int l=0;
        int r=n-1;
        while (l<r){
            int s=min(h[l],h[r])*(r-l);
            if (s>mmax) mmax=s;
            if (h[l]<h[r]) l++;
            else r--;
        }
        return mmax;
    }
};
```

### 思路：

很经典的题目了，和前缀和的那个接雨水有点异曲同工之妙了

这个题要是要暴力求解其实也不是不行，就是容易超时（这一眼都能看出来要剪枝吧）

实际上观察题目我们可以发现，可以盛多少水取决于两边的高度。

而且，如果左边的比右边小，那么右指针往左边移动一定不会是正确的答案，反之亦然

我们设置一个变量mmax记录最大值的数据，然后在循环里面进行一定程度的处理，当左比右边小，那么左指针向右边移动，反之则如此。

## 例题：照相

## 题目背景

翻译自 [NOI SG 2024 Prelim C.School Photo](https://github.com/noisg/noi-2024-prelim)。

## 题目描述 

Zane 是 NOI 学校的校长。NOI 学校有 $n$ 个班，每个班有 $s$ 名同学。第 $i$ 个班中的第 $j$ 名同学的身高是 $a_{i,j}$。

现在 Zane 想从每个班上选出一名同学拍照，使得这 $n$ 名同学中最高的同学和最低的同学的身高差最小。

请你输出这个最小值。

## 输入格式

第一行，两个整数 $n,s$；

接下来 $n$ 行，每行 $s$ 个整数，表示 $a$。

## 输出格式

一行一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
2 3
2 1 8
5 4 7
```

### 输出 #1

```
1
```

## 输入输出样例 #2

### 输入 #2

```
3 3
3 1 4
2 7 18
9 8 10
```

### 输出 #2

```
4
```

## 说明/提示

### 【样例 #2 解释】

选择 $a_{1,3},a_{2,2},a_{3,2}$，答案为 $8-4=4$。

### 【数据范围】

| $\text{Subtask}$ | 分值 |  特殊性质   |
| :--------------: | :--: | :---------: |
|       $0$        | $0$  |    样例     |
|       $1$        | $11$ |    $n=2$    |
|       $2$        | $22$ | $n,s\le100$ |
|       $3$        | $9$  | $n,s\le250$ |
|       $4$        | $33$ | $n,s\le500$ |
|       $5$        | $25$ |     无      |

对于 $100\%$ 的数据，$1\le n,s \le 1000,1\le a_{i,j} \le 10^9$。

### 题解：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e6 + 5;
struct student{int height, cls;}a[N];
int n, m, sum, top;
int cnt[N];

bool cmp(student a, student b){return a.height <= b.height;}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++){
            int x;
            scanf("%d", &x);
            a[++top].height = x;
            a[top].cls = i;
    }
    sort(a + 1, a + top + 1, cmp);
    int l = 1, r = 1, ans = 2e9;
    while(l <= r && r <= top + 1){
        if(sum < n){   
            cnt[a[r].cls] ++;
            if(cnt[a[r].cls] == 1) sum ++;
            r ++;
        } else {
            ans = min(ans, a[r - 1].height - a[l].height);
            cnt[a[l].cls] --;
            if(cnt[a[l].cls] == 0) sum --;
            l ++;
        }
    }
    cout << ans;
    return 0;
}
```

### 思路：

懒得喷，我自己写的代码错了一大堆。

不要开二维数组去维护这个数据，变成n指针就老实了。

一维数组去按照学生结构体存储，然后依次读入数据，如果班级数已经达到三人了就开始删除人，每次删除人要判断一次，就这样。

## 例题：至少有重复字符的字符串：

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

如果不存在这样的子字符串，则返回 0。

**示例 1：**

```
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

**示例 2：**

```
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文字母组成
- `1 <= k <= 105`

题解：

```cpp
class Solution {
public:
    int longestSubstring(string s, int k) {
        int ret = 0;
        int n = s.length();
        for (int t = 1; t <= 26; t++) {
            int l = 0, r = 0;
            vector<int> cnt(26, 0);
            int tot = 0;
            int less = 0;
            while (r < n) {
                cnt[s[r] - 'a']++;
                if (cnt[s[r] - 'a'] == 1) {
                    tot++;
                    less++;
                }
                if (cnt[s[r] - 'a'] == k) {
                    less--;
                }

                while (tot > t) {
                    cnt[s[l] - 'a']--;
                    if (cnt[s[l] - 'a'] == k - 1) {
                        less++;
                    }
                    if (cnt[s[l] - 'a'] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                if (less == 0) {
                    ret = max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
};
```

