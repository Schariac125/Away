# 算法：搜索

## 知识点：

### 深度优先搜索

给出一个公式化的模板然后我再详细说说，这个是回溯来着。

```cpp
void dfs(int k){
    if (所有空都填完了){
        判断最优解/记录答案;
        return;
    }
    for (枚举这个空可以填的选项){
        if (这个选项是合法的){
            记录下这个空(保存现场);
            dfs(k+1);
            取消这个空(恢复现场);
        }
    }
}
```

传统的枚举需要固定for循环的层数，这种操作会让程序变得十分复杂，并且不能随意的增删枚举的次数，dfs利用了递归算法，枚举每一个填空中可能的选项，如果合法就填写下一个选项，然后继续，如果这个选项找不到合法的，不用继续枚举，回去修改上一个选项，这就是回溯算法。

在不用到回溯的情况下，其实dfs更像是一种遍历图并且打标记的。

### 广度优先搜索

```cpp
Q.push(初始状态);//从初始状态入队
while (!Q.empty()){
    State u=Q.front();//取出队首
    Q.pop();//出队
    for (枚举所有可扩展的状态){//找到u的所有可抵达状态v
        if (是合法的){//v要满足某些条件
            Q.push(v);//入队，同时可能要判断某些条件
        }
    }
}
```

## 例题：

## P1219 [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。

## 输入格式

一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。

## 输出格式

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 输入输出样例 #1

### 输入 #1

```
6
```

### 输出 #1

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100

int a[maxn], n, ans = 0;
int b1[maxn];         // 列标记
int b2[2 * maxn];     // 主对角线标记（行+列），扩大为2倍
int b3[2 * maxn];     // 副对角线标记（行-列+n），扩大为2倍

void dfs(int x) {
    if (x > n) {
        ans++;
        if (ans <= 3) {
            for (int i = 1; i <= n; i++) {
                cout << a[i] << " ";
            }
            cout << endl;
        }
        return;
    }
    for (int i = 1; i <= n; i++) {
        // 关键修正：检查 b2[x+i] 和 b3[x-i+n]
        if (b1[i] == 0 && b2[x + i] == 0 && b3[x - i + n] == 0) {
            a[x] = i;
            b1[i] = 1;
            b2[x + i] = 1;      // 标记主对角线
            b3[x - i + n] = 1;  // 标记副对角线（+n防负）
            dfs(x + 1);
            b1[i] = 0;
            b2[x + i] = 0;
            b3[x - i + n] = 0;
        }
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << ans;
    return 0;
}
```

### 思路：

dfs模板题

分行枚举棋子位数，每一行并不会发生冲突，b1[i]说明第i列已经被占据，而斜边可以利用b2和b3数组来表示，然后就是套模板了。

## 例题：

## P2392 kkksc03考前临时抱佛脚

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。

## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。

## 输入格式

本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。

第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。

第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。

第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。

第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。

## 输出格式

输出一行,为复习完毕最短时间。

## 输入输出样例 #1

### 输入 #1

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 输出 #1

```
20
```

## 说明/提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
int nowtime,maxtime,sum;
int ans,maxdeep;
int s[4],a[21];

void dfs(int x){
    if (x>maxdeep){
        maxtime=max(maxtime,nowtime);
        return;
    }
    if (nowtime+a[x]<=sum/2){
        nowtime+=a[x];
        dfs(x+1);
        nowtime-=a[x];
    }
    dfs(x+1);
}

int main(){
    cin>>s[0]>>s[1]>>s[2]>>s[3];
    for (int i=0;i<4;i++){
        nowtime=0;
        maxdeep=s[i];
        sum=0;
        for (int j=1;j<=s[i];j++){
            cin>>a[j];
            sum+=a[j];
        }
        maxtime=0;
        dfs(1);
        ans+=(sum-maxtime);
    }
    cout<<ans;
    return 0;
}
```

思路见深入浅出p191

## 例题：广度优先搜索模板

## P1443 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 输入输出样例 #1

### 输入 #1

```
3 3 1 1
```

### 输出 #1

```
0 3 2    
3 -1 1    
2 1 4
```

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

2022 年 8 月之后，本题去除了对输出保留场宽的要求。为了与之兼容，本题的输出以空格或者合理的场宽分割每个整数都将判作正确。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 410

struct coord{
    int x,y;
};

queue<coord> q;
int ans[maxn][maxn];
int walk[8][2]={{1,2},{2,1},{-1,2},{1,-2},{-1,-2},{-2,1},{-2,-1},{2,-1}};

int main(){
    int n,m,sx,sy;
    memset(ans,-1,sizeof(ans));
    cin>>n>>m>>sx>>sy;
    coord tmp={sx,sy};
    q.push(tmp);
    ans[sx][sy]=0;
    while (!q.empty()){
        coord u=q.front();
        int ux=u.x,uy=u.y;
        q.pop();
        for (int k=0;k<8;k++){
            int x=ux+walk[k][0],y=uy+walk[k][1];
            int d=ans[ux][uy];
            if (x<1||x>n||y<1||y>m||ans[x][y]!=-1){
                continue;
            } 
            ans[x][y]=d+1;
            coord tmp={x,y};
            q.push(tmp);
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            cout<<ans[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```

### 思路：

广度优先搜索模板题

思路见深入浅出p195

## 例题：

## P1135 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？

## 输入格式

共二行。  

第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。

第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。

## 输出格式

一行，即最少按键次数，若无法到达，则输出 `-1`。

## 输入输出样例 #1

### 输入 #1

```
5 1 5
3 3 1 2 5
```

### 输出 #1

```
3
```

## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

class node{
    public:
    int floor,d;
};

queue<node> q;
int n,a,b;
int k[1000],vis[1000];
int main(){
    cin>>n>>a>>b;
    for (int i=1;i<=n;i++){
        cin>>k[i];
    }
    q.push((node){a,0});
    vis[a]=1;
    node now;
    while (!q.empty()){
        now=q.front();
        q.pop();
        if (now.floor==b) break;
        for (int i=-1;i<=1;i+=2){
            int ret=now.floor+k[now.floor]*i;
            if (ret>=1&&ret<=n&&vis[ret]==0){
                q.push((node){ret,now.d+1});
                vis[ret]=1;
            }
        }
    }
    if (now.floor==b){
        cout<<now.d<<endl;
    }else{
        cout<<"-1"<<endl;
    }
    return 0;
}
```

思路见深入浅出。

## 例题：2024机考原题

## P8662 [蓝桥杯 2018 省 AB] 全球变暖

## 题目描述

你有一张某海域 $N \times N$ 像素的照片，`.` 表示海洋、 `#` 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 $2$ 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。

## 输入格式

第一行包含一个整数 $N$。$(1 \le N \le 1000)$。

以下 $N$ 行 $N$ 列代表一张海域照片。

照片保证第 $1$ 行、第 $1$ 列、第 $N$ 行、第 $N$ 列的像素都是海洋。

## 输出格式

一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......
```

### 输出 #1

```
1
```

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

char m[1005][1005],f[1005][1005];
int n,vis[1005][1005];
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
int sum=0,ans=0;
void dfs(int x,int y){
    m[x][y]='.';
    for (int i=0;i<4;i++){
        int dx=x+xx[i];
        int dy=y+yy[i];
        if (m[dx][dy]=='#'&&dx>=1&&dx<=n&&dy>=1&&dy<=n){
            dfs(dx,dy);
        }
    }
    return;
}
void dfs1(int x,int y){
    f[x][y]='.';
    for (int i=0;i<4;i++){
        int dx=x+xx[i];
        int dy=y+yy[i];
        if (f[dx][dy]!='.'&&dx>=1&&dx<=n&&dy>=1&&dy<=n){
            dfs1(dx,dy);
        }
    }
    return;
}
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cin>>m[i][j];
            f[i][j]=m[i][j];
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            if (m[i][j]=='#'){
                sum++;
                dfs(i,j);
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            if (f[i][j]=='#'){
            if (f[i+xx[0]][j+yy[0]]=='.'||f[i+xx[1]][j+yy[1]]=='.'||f[i+xx[2]][j+yy[2]]=='.'||f[i+xx[3]][j+yy[3]]=='.'){
                f[i][j]='-';
            }
        }
        }
    }
    
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            if (f[i][j]=='#'){
                ans++;
                dfs1(i,j);
            }
        }
    }
    cout<<sum-ans<<endl;
    return 0;
}
```

### 思路：

那么多题解看下来，我只看懂了一篇，只能说不愧是金标大佬。其他几篇dfs用的地方都说的不明不白

思路很简单，如果一块陆地上下左右都是陆地，就算与他相邻的陆地都被淹没，那这块地也不会被淹，这个小岛就没有被完全淹没。所以我们只需要遍历一遍，看每个岛的陆地是否沿海即可。

至于使用dfs的原因，dfs是对每一个坐标遍历，当遇到一个陆地（岛）的时候就遍历这个岛上的所有陆地，如果有不会被淹没的陆地，就返回1，答案+1。在这之后需要把这个岛抹掉也就是无论陆地与否全改成海（.），防止后续到达这个岛上的其它点时重复计算。

dfs天生在处理这种连续区块的题目上具有优势，反复评鉴了。

## 例题：

## P1036 [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

## 输出格式

输出一个整数，表示种类数。

## 输入输出样例 #1

### 输入 #1

```
4 3
3 7 12 19
```

### 输出 #1

```
1
```

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,k,ans;
int a[25];
bool su(int x){
    if (x==2) return 1;
    for (int i=2;i*i<=x;i++){
        if (x%i==0){
            return 0;
        }
    }
    return 1;
}

void dfs(int start,int cnt,int s){//start是从哪个开始枚举，cnt是现在已经有几个数了，s是现在几个数的和
    if (cnt==k){
        if (su(s)){
            ans++;
        }
        return;
    }
    for (int i=start;i<=n;i++){
        dfs(i+1,cnt+1,s+a[i]);
    }
}

int main(){
    cin>>n>>k;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    dfs(1,0,0);
    cout<<ans<<endl;
    return 0;
}
```

### 思路

考虑使用 DFS。递归生成所有可能的组合。`start` 表示当前选择的起始位置，`s` 表示当前组合的和，`cnt` 表示已经选择的数的个数。对于每一种组合，计算它们的和，并判断这个和是否是素数。如果和是素数，那么答案加一。

## 例题：

## P2036 [COCI 2008/2009 #2] PERKET

## 题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。

## 输入格式

第一行一个整数 $n$，表示可供选用的食材种类数。

接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。

## 输出格式

一行一个整数，表示可能的总酸度和总苦度的最小绝对差。

## 输入输出样例 #1

### 输入 #1

```
1
3 10
```

### 输出 #1

```
7
```

## 输入输出样例 #2

### 输入 #2

```
2
3 8
5 8
```

### 输出 #2

```
1
```

## 输入输出样例 #3

### 输入 #3

```
4
1 7
2 6
3 8
4 9
```

### 输出 #3

```
1
```

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。
#### 说明
- 本题满分 $70$ 分。
- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

class food{
    public:
    int s,b;
};

int n;
food a[15];
int sn=1,bn=0;
int f[25];
int ans=INT_MAX;
void dfs(int x){
    if (x>n){
        return;
    }else{
        for (int i=1;i<=n;i++){
            if (f[i]==0){
                sn*=a[i].s;
                bn+=a[i].b;
                ans=min(ans,abs(sn-bn));
                f[i]=1;
                dfs(x+1);
                f[i]=0;
                sn/=a[i].s;
                bn-=a[i].b;
            }
        }
    }
}

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>a[i].s>>a[i].b;
    }
    dfs(1);
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

dfs模板题

套模板就行，思路其实很简单，只要记得每次更新答案就行。

## 例题：

## P1605 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 输入格式

第一行为三个正整数 $N,M,T$，分别表示迷宫的长宽和障碍总数。

第二行为四个正整数 $SX,SY,FX,FY$，$SX,SY$ 代表起点坐标，$FX,FY$ 代表终点坐标。

接下来 $T$ 行，每行两个正整数，表示障碍点的坐标。

## 输出格式

输出从起点坐标到终点坐标的方案总数。

## 输入输出样例 #1

### 输入 #1

```
2 2 1
1 1 2 2
1 2
```

### 输出 #1

```
1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,t;
int xx[5]={1,-1,0,0},yy[5]={0,0,1,-1};
bool g[15][15],vis[15][15];
int total,fx,fy,sx,sy,l,r;
void dfs(int x,int y){
    if (x==fx&&y==fy){
        total++;
        return;
    }else{
        for (int i=0;i<4;i++){
            int ux=x+xx[i];
            int uy=y+yy[i];
            if (vis[ux][uy]==0&&g[ux][uy]==1){
                vis[x][y]=1;
                dfs(ux,uy);
                vis[x][y]=0;
            }
        }
    }
}

int main(){
    cin>>n>>m>>t;
    cin>>sx>>sy;
    cin>>fx>>fy;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            g[i][j]=1;
        }
    }
    for (int i=1;i<=t;i++){
        cin>>l>>r;
        g[l][r]=0;
    }
    dfs(sx,sy);
    cout<<total;
    return 0;
}
```

### 思路：

这搜索看了两天终于有点小彻小悟了

先简述一下在我的理解里面什么时候用的dfs什么时候用bfs

简单而言，如果这个问题不涉及到边权的问题，那么极大概率是使用dfs进行的，如果这个问题涉及到了边权的问题，那么极大概率就是bfs

通俗一点，只是想出迷宫用d，还要最少路线用b。

这一题其实很简单啊，一个经典的回溯算法例题，创建一个二维数组用来模拟地图，然后输入障碍物坐标，设置为0，然后用dfs遍历每一个坐标，标记。

结束了。

## 例题：

## P1019 [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。

## 输入格式

输入的第一行为一个单独的整数 $n$ 表示单词数，以下 $n$ 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。

## 输出格式

只需输出以此字母开头的最长的“龙”的长度。

## 输入输出样例 #1

### 输入 #1

```
5
at
touch
cheat
choose
tact
a
```

### 输出 #1

```
23
```

## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

### 题解：

```cpp
#include <iostream>
using namespace std;

const int N = 30;
int n, vis[N], ans;
string s[N];
char c;

void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> s[i];
    cin >> c;
    for (int i = 1; i <= n; ++i) if (s[i][0] == c) {
        ++vis[i];
        dfs(s[i]);
        --vis[i];
    } cout << ans << '\n';
    return 0;
}
```

## 例题：

# P1101 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 输入格式

第一行输入一个数 $n$。$(7 \le n \le 100)$。

第二行开始输入 $n \times n$ 的字母矩阵。

## 输出格式

突出显示单词的 $n \times n$ 矩阵。

## 输入输出样例 #1

### 输入 #1

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出 #1

```
*******
*******
*******
*******
*******
*******
*******
```

## 输入输出样例 #2

### 输入 #2

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg
```

### 输出 #2

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int xx[8]={0,0,1,-1,1,-1,1,-1},yy[8]={1,-1,0,0,1,1,-1,-1},n;
char g[105][105];
bool biao[105][105];
string p="yizhong";//dir是方向函数
bool dfs(int x,int y,int next,int dir){
    if (g[x][y]!=p[next]){
        return false;
    }
    if (next==6){
        biao[x][y]=true;
        return true;
    }
    int ux=x+xx[dir];
    int uy=y+yy[dir];
    if (ux<1||ux>n||uy<1||uy>n){
        return false;
    }
    if (dfs(ux,uy,next+1,dir)){
        biao[x][y]=true;
        return true;
    }
    return false;
}

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cin>>g[i][j];
        }
    }
    memset(biao,false,sizeof(biao));
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            if (g[i][j]==p[0]){
                for (int k=0;k<8;k++){
                    dfs(i,j,0,k);
                }
            }
        }
    }
    char ans[105][105];
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            if (biao[i][j]!=true){
                ans[i][j]='*';
            }else{
                ans[i][j]=g[i][j];
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cout<<ans[i][j];
        }
        cout<<endl;
    }
    return 0;
}
```

### 思路：

可以再看看这个模板

![img](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\feb0e34eda4dc4a5fdac7ee248cf7437.png)

对待这种连续性问题有奇效。

## 例题：

## P2404 自然数的拆分问题

## 题目描述

任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。

## 输入格式

输入：待拆分的自然数 $n$。

## 输出格式

输出：若干数的加法式子。

## 输入输出样例 #1

### 输入 #1

```
7
```

### 输出 #1

```
1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4
```

## 说明/提示

数据保证，$2\leq n\le 8$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10];
int n;
void dfs(int x,int c,int qs){
    if (x==n){
        for (int i=0;i<c;i++){
            if (i!=c-1){
                cout<<a[i]<<"+";
            }else{
                cout<<a[i]<<endl;
            }
        }
        return;
    }
    if (x>n) return;
    for (int i=qs;i<n;i++){
        a[c]=i;
        dfs(x+i,c+1,i);
        a[c]=0;
    }
}

int main(){
    cin>>n;
    dfs(0,0,1);
    return 0;
}

```

### 思路：

很简单的回溯算法，x表示初始值，c为第几个数字，单纯的输出工具人，qs为要从哪个数字开始遍历。

## 例题：

## P1596 [USACO10OCT] Lake Counting S

## 题目描述

由于最近的降雨，水在农夫约翰的田地里积聚了。田地可以表示为一个 $N \times M$ 的矩形（$1 \leq N \leq 100$；$1 \leq M \leq 100$）。每个方格中要么是水（`W`），要么是干地（`.`）。农夫约翰想要弄清楚他的田地里形成了多少个水塘。一个水塘是由连通的水方格组成的，其中一个方格被认为与它的八个邻居相邻。给定农夫约翰田地的示意图，确定他有多少个水塘。

## 输入格式

第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$。

第 $2$ 行到第 $N+1$ 行：每行 $M$ 个字符，表示农夫约翰田地的一行。

每个字符要么是 `W`，要么是 `.`。

字符之间没有空格。

## 输出格式

第 $1$ 行：农夫约翰田地中的水塘数量。

## 输入输出样例 #1

### 输入 #1

```
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

### 输出 #1

```
3
```

## 说明/提示

输出详情：共有三个水塘：一个在左上角，一个在左下角，还有一个沿着右侧。

（由 ChatGPT 4o 翻译）

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

char g[105][105];
int n,m;
int xx[8]={0,0,1,-1,1,-1,1,-1},yy[8]={1,-1,0,0,1,1,-1,-1};
void dfs(int x,int y){
    g[x][y]='-';
    for (int i=0;i<8;i++){
        int ux=x+xx[i];
        int uy=y+yy[i];
        if (g[ux][uy]=='W'&&ux>=1&&ux<=n&&uy>=1&&uy<=m){
            dfs(ux,uy);
        }
    }
    return;
}

int main(){
    cin>>n>>m;
    int ans=0;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            cin>>g[i][j];
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            if (g[i][j]=='W'){
                ans++;
                dfs(i,j);
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

模板题，没啥好说的。

## 例题：

## P1162 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 输入格式

每组测试数据第一行一个整数 $n(1 \le n \le 30)$。

接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \times n$ 的方阵。

方阵内只有一个闭合圈，圈内至少有一个 $0$。

## 输出格式

已经填好数字 $2$ 的完整方阵。

## 输入输出样例 #1

### 输入 #1

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出 #1

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[32][32],b[32][32];
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//第一个表示不动，是充数的，后面的四个分别是上下左右四个方向
int n,i,j;
void dfs(int p,int q){
    int i;
    if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;//如果搜过头或者已经被搜过了或者本来就是墙的就往回
    a[p][q]=1;//染色
    for (i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);//向四个方向搜索
}
int main(){
    cin>>n;
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++){
            cin>>b[i][j];//其实不拿两个数组也可以，不过我喜欢啦
            if (b[i][j]==0) a[i][j]=0;
            else a[i][j]=2;
        }
    dfs(0,0);//搜索 从0，0开始搜
    for (i=1;i<=n;i++){
        for (j=1;j<=n;j++)
        if (a[i][j]==0) cout<<2<<' ';//如果染过色以后i，j那个地方还是0，说明没有搜到，就是周围有墙，当然就是被围住了，然后输出2
        else cout<<b[i][j]<<' ';//因为被染色了，本来没有被围住的水和墙都染成了1，所以就输出b[i][j]
        cout<<'\n';//换行
    }
}
```

### 思路：

我说染色法王朝了你二朵龙吗？

## 例题：

给你一个 `m x n` 的迷宫矩阵 `maze` （**下标从 0 开始**），矩阵中有空格子（用 `'.'` 表示）和墙（用 `'+'` 表示）。同时给你迷宫的入口 `entrance` ，用 `entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]` 表示你一开始所在格子的行和列。

每一步操作，你可以往 **上**，**下**，**左** 或者 **右** 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 `entrance` **最近** 的出口。**出口** 的含义是 `maze` **边界** 上的 **空格子**。`entrance` 格子 **不算** 出口。

请你返回从 `entrance` 到最近出口的最短路径的 **步数** ，如果不存在这样的路径，请你返回 `-1` 。

**示例 1：**

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\nearest1-grid.jpg)

```
输入：maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
输出：1
解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。
一开始，你在入口格子 (1,2) 处。
- 你可以往左移动 2 步到达 (1,0) 。
- 你可以往上移动 1 步到达 (0,2) 。
从入口处没法到达 (2,3) 。
所以，最近的出口是 (0,2) ，距离为 1 步。
```

**示例 2：**

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\nearesr2-grid.jpg)

```
输入：maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
输出：2
解释：迷宫中只有 1 个出口，在 (1,2) 处。
(1,0) 不算出口，因为它是入口格子。
初始时，你在入口与格子 (1,0) 处。
- 你可以往右移动 2 步到达 (1,2) 处。
所以，最近的出口为 (1,2) ，距离为 2 步。
```

**示例 3：**

![](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\nearest3-grid.jpg)

```
输入：maze = [[".","+"]], entrance = [0,0]
输出：-1
解释：这个迷宫中没有出口。
```

**提示：**

-   `maze.length == m`
-   `maze[i].length == n`
-   `1 <= m, n <= 100`
-   `maze[i][j]` 要么是 `'.'` ，要么是 `'+'` 。
-   `entrance.length == 2`
-   `0 <= entrance<sub>row</sub> < m`
-   `0 <= entrance<sub>col</sub> < n`
-   `entrance` 一定是空格子。

### 题解：

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size();
        int n = maze[0].size();
        // 上下左右四个相邻坐标对应的行列变化量
        vector<int> dx = {1, 0, -1, 0};
        vector<int> dy = {0, 1, 0, -1};
        queue<tuple<int, int, int>> q;
        // 入口加入队列并修改为墙
        q.emplace(entrance[0], entrance[1], 0);
        maze[entrance[0]][entrance[1]] = '+';
        while (!q.empty()){
            auto [cx, cy, d] = q.front();
            q.pop();
            // 遍历四个方向相邻坐标
            for (int k = 0; k < 4; ++k){
                int nx = cx + dx[k];
                int ny = cy + dy[k];
                // 新坐标合法且不为墙
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && maze[nx][ny] == '.'){
                    if (nx == 0 || nx == m - 1 || ny == 0 || ny == n - 1){
                        // 新坐标为出口，返回距离作为答案
                        return d + 1;
                    }
                    // 新坐标为空格子且不为出口，修改为墙并加入队列
                    maze[nx][ny] = '+';
                    q.emplace(nx, ny, d + 1);
                }
            }
        }
        // 不存在到出口的路径，返回 -1
        return -1;
    }
};
```

### 思路：

bfs模板题。

## 模板题：

## P4779 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 输入格式

第一行为三个正整数 $n, m, s$。
第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。

## 输出格式

输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。

## 输入输出样例 #1

### 输入 #1

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
```

### 输出 #1

```
0 2 4 3
```

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

### 题解：

```cpp
#include <bits/stdc++.h>
#ifndef DEBUG
#define debug
#endif
using namespace std;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int n, m, s;
  cin >> n >> m >> s;
  auto graph = vector(n + 1, vector<pair<int, int>>());
  while (m--) {
    int u, v, c;
    cin >> u >> v >> c;
    graph[u].emplace_back(v, c);
  }
  using pii = pair<int, int>; // distance, u
  priority_queue<pii, vector<pii>, greater<pii>> q;
  auto min_dist = vector(n + 1, INT_MAX);
  auto calced = vector(n + 1, 0);
  min_dist[s] = 0;
  q.emplace(0, s);
  debug(graph);
  while (!q.empty()) {
    auto [dist, u] = q.top();
    debug(q.top());
    q.pop();
    if (calced[u]) continue;
    calced[u] = true;
    for (auto [v, c]: graph[u]) {
      if (min_dist[v] <= min_dist[u] + c) continue;
      min_dist[v] = min_dist[u] + c;
      q.emplace(min_dist[u] + c, v);
    }
  }
  for (int i = 1; i <= n; i ++) cout << min_dist[i] << ' ';
}
```

背诵重点，开一个数组存储每个点可以通往哪里并且路程是多少，然后把初始位置位置设置成0，然后比对每个数据，更新，放入优先队列。

### 思路：

我知道思路是什么，但是很抱歉，我写不出来。

### 前言

-   算法由于它上限 的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法dijkstra:.（不知道为什么这个复制不上）

### 什么是?

-   是一种单源最短路径算法,时间复杂度上限为(朴素),在实际应用中较为稳定加上堆优化之后更是具有的时间复杂度,在稠密图中有不俗的表现.

### 的原理/流程?

-   本质上的思想是贪心,它只适用于不含负权边的图.
-   我们把点分成两类,一类是已经确定最短路径的点,称为"白点",另一类是未确定最短路径的点,称为"蓝点"
-   的流程如下
-   初始化其余节点的值为无穷大.
-   找一个值最小的蓝点把节点变成白点.
-   遍历的所有出边若则令
-   重复两步,直到所有点都成为白点
-   时间复杂度为

### 为什么是正确的

-   当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第步中找出的蓝点必然满足已经是起点到的最短路径我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度

### 图解

-   (令)
-   开始时我们把初始化为,其余点初始化为 ![初始化](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\5b583277e47e9-17536062392419.png)
-   第一轮循环找到值最小的点,将变成白点,对所有与相连的蓝点的值进行修改,使得 ![1](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\5b58347b9a37b-175360623924111.png)
-   第二轮循环找到值最小的点,将变成白点,对所有与相连的蓝点的值进行修改,使得 ![2](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\5b586fa8de335-175360623924213.png)
-   第三轮循环找到值最小的点,将变成白点,对所有与相连的蓝点的值进行修改,使得 ![3](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\5b58703e8d0d6-175360623924215.png)
-   接下来两轮循环分别将设为白点,算法结束,求出所有点的最短路径
-   时间复杂度

### 为什么不能处理有负权边的情况?

-   我们来看下面这张图 ![4](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\5b58724845b8d-175360623924217.png)
-   到的边权为,显然从到的最短路径为 但在循环开始时程序会找到当前值最小的点,并标记它为白点.
-   这时的然而并不是起点到的最短路径.因为已经被标为白点,所以不会再被修改了.我们在边权存在负数的情况下得到了错误的答案.

### 的堆优化?

-   观察的流程,发现步骤可以优化
    
-   怎么优化呢?
    
-   ~我会zkw线段树!我会斐波那契堆!~
    
-   我会堆!
    
-   我们可以用堆对数组进行维护,用的时间取出堆顶元素并删除,用遍历每条边,总复杂度

最公式化的模板如下：

![img](C:\Users\asus\Desktop\程序设计\算法笔记\大章搜索\算法：搜索.assets\c81f4f24ae8b2c9521c9e17d3b5dd332.png)

## 例题：

## P1825 [USACO11OPEN] Corn Maze S

## 题目描述

去年秋天，农夫约翰带着奶牛们参观了一个玉米迷宫。但这不是一个普通的玉米迷宫：它有几个重力驱动的传送滑梯，可以让奶牛瞬间从迷宫中的一个点传送到另一个点。滑梯是双向的：奶牛可以瞬间从滑梯的起点滑到终点，或者从终点滑到起点。如果奶牛踩到滑梯的任一端，她必须使用滑梯。

玉米迷宫的外部完全由玉米包围，只有一个出口。

迷宫可以用一个 $N \times M$（$2 \leq N \leq 300$；$2 \leq M \leq 300$）的网格表示。每个网格元素包含以下项目之一：

* 玉米（玉米网格元素不可通行）
* 草地（容易通过！）
* 滑梯端点（会将奶牛传送到另一个端点）
* 出口

奶牛只能从一个空间移动到相邻的下一个空间，前提是它们相邻且都不包含玉米。每个草地空间有四个潜在的邻居可以让奶牛到达。从一个草地空间移动到相邻空间需要 $1$ 个时间单位；从一个滑梯端点移动到另一个端点需要 $0$ 个时间单位。

填满玉米的空间用井号（`#`）表示。草地空间用英文句号（`.`）表示。滑梯端点对用相同的大写字母（`A` 到 `Z`）表示，并且没有两个不同的滑梯端点用相同的字母表示。出口用等号（`=`）表示。

贝茜迷路了。她知道自己在网格中的位置，并用「at」符号（`@`）标记了她当前的草地空间。她需要的最短时间是多少才能移动到出口空间？

## 输入格式

第一行：两个用空格隔开的整数 $N$ 和 $M$。

第 $2 \sim N+1$ 行：第 $i+1$ 行描述了迷宫中的第 $i$ 行的情况（共有 $M$ 个字符，每个字符之间没有空格）。

## 输出格式

一个整数，表示起点到出口所需的最短时间。

## 输入输出样例 #1

### 输入 #1

```
5 6
###=##
#.W.##
#.####
#.@W##
######
```

### 输出 #1

```
3
```

## 说明/提示

例如以下矩阵，$N=5,M=6$。

```plain
###=##
#.W.##
#.####
#.@W##
######
```

唯一的一个装置的结点用大写字母 $\tt{W}$ 表示。

最优方案为：先向右走到装置的结点，花费一个单位时间，再到装置的另一个结点上，花费 $0$ 个单位时间，然后再向右走一个，再向上走一个，到达出口处，总共花费了 $3$ 个单位时间。

（由 ChatGPT 4o 翻译）

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
int n,m;
char g[310][310];
int vis[310][310];
class pro{
    public:
    int x,y,step;
};
void goto_another(int &nx,int &ny,int k)//goto_another函数用于寻找另一个传送门，nx、ny代表当前点的坐标，记得要加上取地址符'&'，因为每当贝西踏入一个传送门，它就会立即被传送至另一个传送门，不能在原地停留
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(g[i][j]==g[nx][ny]&&(i!=nx||j!=ny))//如果a[i][j]这个点的是一个与a[nx][ny]相同的传送门，并且a[i][j]与a[nx][ny]不是同一个点
            {
                nx=i;//改变当前坐标，将贝西强行移动至另一个传送门处
                ny=j;
                return ;//告辞
            }
        }
    }
}
queue<pro> q;
int main(){
    cin>>n>>m;
    int bx,by;
    int fx,fy;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            cin>>g[i][j];
            if (g[i][j]=='@'){
                bx=i;
                by=j;
            }
            if (g[i][j]=='='){
                fx=i;
                fy=j;
            }
        }
    }
    q.push((pro){bx,by,0});
    vis[bx][by]=1;
    while (!q.empty()){
        auto u=q.front();
        q.pop();
        if (u.x==fx&&u.y==fy){
            cout<<u.step;
            return 0;
        }
        if (g[u.x][u.y]>='A'&&g[u.x][u.y]<='Z'){
            goto_another(u.x,u.y,u.step);
        }
        for (int i=0;i<4;i++){
            int xn=u.x+xx[i];
            int yn=u.y+yy[i];
            if (xn>=1&&xn<=n&&yn>=1&&yn<=m&&g[xn][yn]!='#'&&!vis[xn][yn]){
                vis[xn][yn]=1;
                q.push(pro{xn,yn,u.step+1});
            } 
        }
    }
    return 0;
}
```

### 思路：

传送门类的题目一般而言都玩的非常花，这可能还是最简单的传送门，但是一般思路就是建立传送门映射，然后如果到了传送门直接传送。