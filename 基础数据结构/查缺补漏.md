# æŸ¥ç¼ºè¡¥æ¼ï¼š

## é“¾è¡¨ï¼š

### é“¾è¡¨è¶…è¯¦ç»†å…¥é—¨æŒ‡å—ï¼ˆé’ˆå¯¹é›¶åŸºç¡€åˆå­¦è€…ï¼‰

#### ğŸŒŸ ä»€ä¹ˆæ˜¯é“¾è¡¨ï¼Ÿ

é“¾è¡¨æ˜¯æœ€åŸºç¡€çš„**åŠ¨æ€æ•°æ®ç»“æ„**ä¹‹ä¸€ï¼Œå°±åƒä¸€åˆ—ç«è½¦ï¼š

- æ¯èŠ‚è½¦å¢ = **èŠ‚ç‚¹ï¼ˆNodeï¼‰**
- è½¦å¢ä¹‹é—´çš„è¿æ¥é’© = **æŒ‡é’ˆï¼ˆPointerï¼‰**
- ç¬¬ä¸€èŠ‚è½¦å¢ = **å¤´èŠ‚ç‚¹ï¼ˆHeadï¼‰**
- æœ€åä¸€èŠ‚è½¦å¢çš„æŒ‚é’©ä¸ºç©º = **NULLï¼ˆæˆ– nullptrï¼‰**

------

### ğŸ” èŠ‚ç‚¹ç»“æ„è§£å‰–

æ¯ä¸ªèŠ‚ç‚¹ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š

```
struct Node {
    int data;       // æ•°æ®åŸŸ â†’ å­˜å‚¨å®é™…æ•°æ®ï¼ˆå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼‰
    Node* next;     // æŒ‡é’ˆåŸŸ â†’ æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
};
```

> ç¤ºä¾‹å›¾ç¤ºï¼š

```
+-------+------+    +-------+------+    +-------+------+
| Data1 |  -----â†’   | Data2 |  -----â†’   | Data3 | NULL |
+-------+------+    +-------+------+    +-------+------+
   â†‘
  å¤´èŠ‚ç‚¹
```

------

### ğŸ§© é“¾è¡¨æ ¸å¿ƒç‰¹æ€§

| ç‰¹ç‚¹           | è¯´æ˜                    | ç±»æ¯”                    |
| -------------- | ----------------------- | ----------------------- |
| **åŠ¨æ€å¢é•¿**   | è¿è¡Œæ—¶æŒ‰éœ€æ·»åŠ /åˆ é™¤èŠ‚ç‚¹ | ç«è½¦å¯éšæ—¶åŠ æŒ‚/æ‘˜é™¤è½¦å¢ |
| **éè¿ç»­å†…å­˜** | èŠ‚ç‚¹å¯åˆ†æ•£åœ¨å†…å­˜å„å¤„    | è½¦å¢åœåœ¨ç«è½¦ç«™ä¸åŒè½¨é“  |
| **é¡ºåºè®¿é—®**   | åªèƒ½ä»å¤´é€ä¸ªè®¿é—®èŠ‚ç‚¹    | å¿…é¡»ä»è½¦å¤´èµ°å‘è½¦å°¾      |
| **é«˜æ•ˆå¢åˆ **   | ä¸­é—´æ’å…¥/åˆ é™¤åªéœ€æ”¹æŒ‡é’ˆ | åªéœ€è§£é’©+æŒ‚æ¥æ–°è½¦å¢     |

------

### ğŸ” åŸºç¡€æ“ä½œè¯¦è§£ï¼ˆé™„åŠ¨ç”»å›¾ç¤ºï¼‰

#### 1ï¸âƒ£ åˆ›å»ºé“¾è¡¨

```
Node* head = nullptr; // åˆå§‹åŒ–ä¸ºç©ºé“¾è¡¨
```

> âš ï¸ **ç©ºé“¾è¡¨çŠ¶æ€**ï¼š
>  `head â†’ NULL`
>  ç›¸å½“äºæ²¡æœ‰ç«è½¦è½¦å¢

#### 2ï¸âƒ£ å¤´éƒ¨æ’å…¥

```
void insertAtHead(Node* &head, int value) {
    Node* newNode = new Node;   // åˆ›å»ºæ–°èŠ‚ç‚¹
    newNode->data = value;      // å­˜å…¥æ•°æ®
    
    // å°†æ–°èŠ‚ç‚¹æŒ‚åˆ°é“¾è¡¨å¤´éƒ¨
    newNode->next = head;      // æ–°èŠ‚ç‚¹æŒ‡å‘åŸå¤´èŠ‚ç‚¹
    head = newNode;            // æ›´æ–°å¤´æŒ‡é’ˆæŒ‡å‘æ–°èŠ‚ç‚¹
}
```

> ğŸ¥ **åŠ¨ç”»ç¤ºæ„**ï¼š
>  åŸé“¾è¡¨ï¼š head â†’ A â†’ B â†’ NULL
>  æ’å…¥åï¼š head â†’ [æ–°èŠ‚ç‚¹] â†’ A â†’ B â†’ NULL

#### 3ï¸âƒ£ å°¾éƒ¨æ’å…¥

```
void insertAtTail(Node* &head, int value) {
    Node* newNode = new Node; // åˆ›å»ºæ–°èŠ‚ç‚¹
    newNode->data = value;
    newNode->next = nullptr;  // æ–°èŠ‚ç‚¹æŒ‡å‘NULLï¼ˆå› ä¸ºå®ƒæ˜¯æœ€åä¸€ä¸ªï¼‰

    // ç‰¹æ®Šæƒ…å†µï¼šç©ºé“¾è¡¨ç›´æ¥è®¾ä¸ºé¦–èŠ‚ç‚¹
    if (head == nullptr) {
        head = newNode;
        return;
    }

    // éå†è‡³å°¾èŠ‚ç‚¹
    Node* current = head;
    while (current->next != nullptr) {
        current = current->next;
    }
    
    current->next = newNode; // åŸå°¾èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
}
```

> ğŸ¥ **åŠ¨ç”»ç¤ºæ„**ï¼š
>  åŸé“¾è¡¨ï¼š head â†’ A â†’ B â†’ NULL
>  æ’å…¥åï¼š head â†’ A â†’ B â†’ [æ–°èŠ‚ç‚¹] â†’ NULL

#### 4ï¸âƒ£ ä»»æ„ä½ç½®æ’å…¥

```
void insertAfter(Node* prevNode, int value) {
    if (prevNode == nullptr) return; // å‰ç½®æ£€æŸ¥

    Node* newNode = new Node;
    newNode->data = value;
    
    // å…³é”®å››æ­¥ï¼š
    newNode->next = prevNode->next;  // æ–°èŠ‚ç‚¹æŒ‡å‘åŸåèŠ‚ç‚¹
    prevNode->next = newNode;        // å‰èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
}
```

> ğŸ¥ **åŠ¨ç”»ç¤ºæ„**ï¼š
>  åŸé“¾è¡¨ï¼š A â†’ B â†’ D â†’ NULL
>  åœ¨Aåæ’å…¥Cï¼š A â†’ [C] â†’ B â†’ D â†’ NULL

#### 5ï¸âƒ£ åˆ é™¤èŠ‚ç‚¹

```
void deleteNode(Node* &head, int target) {
    // ç©ºé“¾è¡¨ç›´æ¥è¿”å›
    if (head == nullptr) return;

    // æƒ…å†µ1ï¼šåˆ é™¤å¤´èŠ‚ç‚¹
    if (head->data == target) {
        Node* temp = head;      // æš‚å­˜åŸå¤´èŠ‚ç‚¹
        head = head->next;      // å¤´æŒ‡é’ˆåç§»
        delete temp;            // é‡Šæ”¾å†…å­˜
        return;
    }

    // æŸ¥æ‰¾ç›®æ ‡èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    Node* current = head;
    while (current->next != nullptr && current->next->data != target) {
        current = current->next;
    }

    // æ‰¾åˆ°åˆ™åˆ é™¤
    if (current->next != nullptr) {
        Node* temp = current->next;       // æš‚å­˜ç›®æ ‡èŠ‚ç‚¹
        current->next = temp->next;       // ç»•è¿‡ç›®æ ‡èŠ‚ç‚¹
        delete temp;                      // é‡Šæ”¾å†…å­˜
    }
}
```

> ğŸ¥ **åŠ¨ç”»ç¤ºæ„**ï¼š
>  åŸé“¾è¡¨ï¼š A â†’ B â†’ C â†’ D â†’ NULL
>  åˆ é™¤Cï¼š A â†’ B â†’ D â†’ NULL

------

### ğŸ”„ é“¾è¡¨éå†

```
void printList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " â†’ ";
        current = current->next;
    }
    cout << "NULL" << endl;
}
```

> ğŸš¶â™‚ï¸ **éå†è¿‡ç¨‹**ï¼š
>  head â†’ A â†’ B â†’ C â†’ NULL
>  æ‰“å°é¡ºåºï¼šA â†’ B â†’ C â†’ NULL

------

### ğŸ’¡ åˆå­¦è€…å¸¸è§é—®é¢˜è§£ç­”

#### â“ é“¾è¡¨å’Œæ•°ç»„çš„åŒºåˆ«ï¼Ÿ

|          | é“¾è¡¨                 | æ•°ç»„                 |
| -------- | -------------------- | -------------------- |
| **å†…å­˜** | éè¿ç»­ï¼ˆåˆ†æ•£å­˜å‚¨ï¼‰   | è¿ç»­å†…å­˜å—           |
| **å¤§å°** | åŠ¨æ€å¢é•¿             | å›ºå®šå¤§å°             |
| **è®¿é—®** | åªèƒ½é¡ºåºè®¿é—®ï¼ˆO(n)ï¼‰ | éšæœºè®¿é—®ï¼ˆO(1)ï¼‰     |
| **å¢åˆ ** | ä¸­é—´æ“ä½œå¿«ï¼ˆO(1)ï¼‰   | éœ€è¦ç§»åŠ¨å…ƒç´ ï¼ˆO(n)ï¼‰ |
| **å†…å­˜** | éœ€é¢å¤–å­˜å‚¨æŒ‡é’ˆ       | æ— é¢å¤–å¼€é”€           |

#### â“ ä¸ºä»€ä¹ˆç”¨é“¾è¡¨ï¼Ÿ

- **åŠ¨æ€æ•°æ®é›†**ï¼šæ•°æ®é‡æœªçŸ¥æ—¶ï¼ˆå¦‚èŠå¤©è®°å½•ï¼‰
- **é«˜é¢‘å¢åˆ **ï¼šæ–‡æœ¬ç¼–è¾‘å™¨ä¸­çš„æ’¤é”€æ“ä½œ
- **å†…å­˜æ•æ„Ÿåœºæ™¯**ï¼šå¤§æ–‡ä»¶å¤„ç†ï¼ˆæ— éœ€è¿ç»­ç©ºé—´ï¼‰

#### â“ å¦‚ä½•é€‰æ‹©é“¾è¡¨ç±»å‹ï¼Ÿ

| ç±»å‹     | ç‰¹ç‚¹                       | é€‚ç”¨åœºæ™¯             |
| -------- | -------------------------- | -------------------- |
| å•å‘é“¾è¡¨ | åªæœ‰nextæŒ‡é’ˆï¼Œå•å‘éå†     | ç®€å•é˜Ÿåˆ—ã€æµè§ˆå†å²   |
| åŒå‘é“¾è¡¨ | æœ‰prevå’ŒnextæŒ‡é’ˆï¼ŒåŒå‘éå† | æµè§ˆå™¨å‰è¿›åé€€åŠŸèƒ½   |
| å¾ªç¯é“¾è¡¨ | å°¾èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹å½¢æˆé—­ç¯   | è½®æ’­å›¾ã€éŸ³ä¹æ’­æ”¾åˆ—è¡¨ |

------

### ğŸ”§ åŠ¨æ‰‹ç»ƒä¹ ï¼ˆå°å®éªŒï¼‰

1. åˆ›å»ºç©ºé“¾è¡¨
2. å¤´éƒ¨æ’å…¥å€¼3 â†’ é“¾è¡¨ï¼š3 â†’ NULL
3. å¤´éƒ¨æ’å…¥å€¼5 â†’ é“¾è¡¨ï¼š5 â†’ 3 â†’ NULL
4. å°¾éƒ¨æ’å…¥å€¼7 â†’ é“¾è¡¨ï¼š5 â†’ 3 â†’ 7 â†’ NULL
5. åœ¨3åæ’å…¥9 â†’ é“¾è¡¨ï¼š5 â†’ 3 â†’ 9 â†’ 7 â†’ NULL
6. åˆ é™¤3 â†’ æœ€ç»ˆé“¾è¡¨ï¼š5 â†’ 9 â†’ 7 â†’ NULL

> æç¤ºï¼šæŒ‰ç…§æ“ä½œè¯¦è§£é‡Œçš„ä»£ç é€æ­¥å®ç°

------

### ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. å…ˆæŒæ¡å•å‘é“¾è¡¨çš„æ‰€æœ‰åŸºç¡€æ“ä½œ
2. å°è¯•å®ç°åŒå‘é“¾è¡¨ï¼ˆæ·»åŠ prevæŒ‡é’ˆï¼‰
3. å®ç°å¾ªç¯é“¾è¡¨ï¼ˆå°¾èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹ï¼‰
4. ç”¨é“¾è¡¨å®ç°æ ˆå’Œé˜Ÿåˆ—
5. å­¦ä¹ ç»å…¸ç®—æ³•é¢˜ï¼šé“¾è¡¨åè½¬ã€ç¯æ£€æµ‹ç­‰

è®°ä½ï¼šé“¾è¡¨çš„æ ¸å¿ƒåœ¨äºç†è§£**èŠ‚ç‚¹é—´çš„æŒ‡é’ˆè¿æ¥å…³ç³»**ï¼å¤šç”»å›¾æ¨¡æ‹Ÿæ“ä½œè¿‡ç¨‹ï¼Œå¾ˆå¿«å°±èƒ½æŒæ¡è¿™ä¸ªåŸºç¡€æ•°æ®ç»“æ„ã€‚

## å®Œæ•´ä»£ç å®ç°ï¼š

```cpp
#include <bits/stdc++.h>
using namespace std;

class node{
    public:
    int data;
    node* next;
};
//åŒ…å«å‡ ä¸ªå­˜å‚¨çš„æ•°æ®å’Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ
//nextçš„ä½œç”¨å°±æ˜¯ä¸€ä¸ªç´¢å¼•
node* head=nullptr;

void insertAthead(node* &head,int value){
    node* newnode=new node;
    newnode->data=value;

    newnode->next=head;
    head=newnode;
}

void insertAttail(node* &head,int value){
    node* newnode=new node;
    newnode->data=value;
    newnode->next=nullptr;

    if (head==nullptr){
        head=newnode;
        return;
    }
    node* cur=head;
    while (cur->next!=nullptr){
        cur=cur->next;
    }

    cur->next=newnode;
}

void insertAfter(node *&prenode,int value){
    if (prenode==nullptr) return;

    node *newnode=new node;
    newnode->data=value;

    newnode->next=prenode->next;
    prenode->next=newnode;
}

void deletenode(node *&head,int target){
    if (head==nullptr) return;

    if (head->data==target){
        node *temp=head;
        head=head->next;
        delete temp;
        return;
    }

    node *cur=head;
    while (cur->next!=nullptr&&cur->next->data==target){
        cur=cur->next;
    }

    if (cur->next!=nullptr){
        node *temp=cur->next;
        cur->next=newnode->next;
        delete temp;
        return;
    }
}

void printnode(node *&head){
    node *cur=head;
    while (cur!=nullptr){
        cout<<cur->data<<endl;
        cur=cur->next;
    }
}
```

# åŒå‘é“¾è¡¨ï¼ˆDoubly Linked Listï¼‰è¯¦è§£ï¼šä»é›¶å¼€å§‹çš„å…¨é¢è§£æ

## ğŸ“Œ ä»€ä¹ˆæ˜¯åŒå‘é“¾è¡¨ï¼Ÿ

åŒå‘é“¾è¡¨æ˜¯ä¸€ç§è¿›é˜¶çš„é“¾è¡¨æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸ä»…ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ï¼Œ**è¿˜ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€**ã€‚è¿™èµ‹äºˆé“¾è¡¨åŒå‘éå†çš„èƒ½åŠ› - æ—¢å¯ä»¥ä»å‰å‘åï¼Œä¹Ÿå¯ä»¥ä»åå‘å‰éå†ã€‚

### èŠ‚ç‚¹ç»“æ„å›¾ç¤º

```
+---------------+    +-------------+    +-------------+
|               |    |             |    |             |
|  prevæŒ‡é’ˆ      |<---|    æ•°æ®     |--->| nextæŒ‡é’ˆ    |
|               |    |             |    |             |
+---------------+    +-------------+    +-------------+
```

> ğŸ“Œ å…³é”®ç‰¹æ€§ï¼š
>
> 1. æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ï¼šæ•°æ® + prevæŒ‡é’ˆï¼ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰+ nextæŒ‡é’ˆï¼ˆæŒ‡å‘åä¸€ä¸ªèŠ‚ç‚¹ï¼‰
> 2. å¤´èŠ‚ç‚¹çš„prev = nullptrï¼Œå°¾èŠ‚ç‚¹çš„next = nullptr
> 3. æ¯”å•å‘é“¾è¡¨å¤šä¸€ä¸ªæŒ‡é’ˆï¼Œä½†æä¾›äº†æ›´å¼ºçš„åŠŸèƒ½

## ğŸ” åŒå‘é“¾è¡¨åŸºç¡€æ¦‚å¿µè§£æ

### 1ï¸âƒ£ åŒå‘é“¾è¡¨ä¸å•å‘é“¾è¡¨çš„åŒºåˆ«

| ç‰¹æ€§           | å•å‘é“¾è¡¨          | åŒå‘é“¾è¡¨             |
| -------------- | ----------------- | -------------------- |
| **èŠ‚ç‚¹ç»“æ„**   | ä»…å«nextæŒ‡é’ˆ      | å«prevå’Œnextä¸¤ä¸ªæŒ‡é’ˆ |
| **éå†æ–¹å‘**   | ä»…èƒ½ä»å¤´åˆ°å°¾      | å¯ä»å¤´åˆ°å°¾æˆ–ä»å°¾åˆ°å¤´ |
| **å†…å­˜å ç”¨**   | è¾ƒå° (1æŒ‡é’ˆ/èŠ‚ç‚¹) | è¾ƒå¤§ (2æŒ‡é’ˆ/èŠ‚ç‚¹)    |
| **åˆ é™¤èŠ‚ç‚¹**   | éœ€çŸ¥é“å‰ä¸€ä¸ªèŠ‚ç‚¹  | å¯ç›´æ¥åˆ é™¤è‡ªèº«       |
| **æ’å…¥å¤æ‚åº¦** | åªèƒ½å‘åæ’å…¥      | å¯åœ¨ä»»æ„èŠ‚ç‚¹å‰åæ’å…¥ |

### 2ï¸âƒ£ èŠ‚ç‚¹ç»“æ„ä»£ç å®ç°

```
// åŒå‘é“¾è¡¨èŠ‚ç‚¹å®šä¹‰
struct Node {
    int data;        // æ•°æ®åŸŸ
    Node* prev;      // æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
    Node* next;      // æŒ‡å‘åä¸€ä¸ªèŠ‚ç‚¹
    
    // æ„é€ å‡½æ•°ï¼šç®€åŒ–èŠ‚ç‚¹åˆ›å»º
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};
```

## ğŸ›  åŒå‘é“¾è¡¨æ ¸å¿ƒæ“ä½œè¯¦è§£

### 1ï¸âƒ£ å¤´éƒ¨æ’å…¥ï¼ˆInsert at Headï¼‰

```
void insertAtHead(Node* &head, int val) {
    Node* newNode = new Node(val); // åˆ›å»ºæ–°èŠ‚ç‚¹
    
    // ç©ºé“¾è¡¨æƒ…å†µ
    if (head == nullptr) {
        head = newNode;
        return;
    }
    
    // è¿æ¥æ–°èŠ‚ç‚¹ä¸å½“å‰å¤´èŠ‚ç‚¹
    newNode->next = head;
    head->prev = newNode; // åŒå‘è¿æ¥å…³é”®ï¼
    
    // æ›´æ–°å¤´æŒ‡é’ˆ
    head = newNode;
}
```

> ğŸ¯ **æ“ä½œè§£æ**ï¼š
>
> 1. åˆ›å»ºæ–°èŠ‚ç‚¹
> 2. æ–°èŠ‚ç‚¹â†’next = å½“å‰å¤´èŠ‚ç‚¹
> 3. å½“å‰å¤´èŠ‚ç‚¹â†’prev = æ–°èŠ‚ç‚¹ï¼ˆå»ºç«‹åŒå‘è¿æ¥ï¼‰
> 4. æ›´æ–°headæŒ‡å‘æ–°èŠ‚ç‚¹

### 2ï¸âƒ£ å°¾éƒ¨æ’å…¥ï¼ˆInsert at Tailï¼‰

```
void insertAtTail(Node* &head, int val) {
    Node* newNode = new Node(val);
    
    // ç©ºé“¾è¡¨ç‰¹æ®Šæƒ…å†µ
    if (head == nullptr) {
        head = newNode;
        return;
    }
    
    // éå†åˆ°å°¾èŠ‚ç‚¹
    Node* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
    }
    
    // è¿æ¥å°¾èŠ‚ç‚¹ä¸æ–°èŠ‚ç‚¹
    tail->next = newNode;
    newNode->prev = tail; // å»ºç«‹åŒå‘é“¾æ¥
}
```

> ğŸŒŸ **ä¼˜åŠ¿**ï¼šæ— éœ€é¢å¤–æŒ‡é’ˆï¼Œprevå±æ€§ç›´æ¥å®šä½å‰èŠ‚ç‚¹

### 3ï¸âƒ£ åœ¨æŒ‡å®šèŠ‚ç‚¹åæ’å…¥

```
void insertAfter(Node* target, int val) {
    if (target == nullptr) return;
    
    Node* newNode = new Node(val);
    
    // æ–°èŠ‚ç‚¹è¿æ¥åé¢çš„èŠ‚ç‚¹
    newNode->next = target->next;
    if (target->next != nullptr) {
        target->next->prev = newNode; // åç»­èŠ‚ç‚¹çš„prevæŒ‡å‘æ–°èŠ‚ç‚¹
    }
    
    // æ–°èŠ‚ç‚¹è¿æ¥å‰é¢çš„èŠ‚ç‚¹
    target->next = newNode;
    newNode->prev = target;
}
```

> ğŸ’¡ **çµæ´»æ€§**ï¼šå¯åœ¨ä»»æ„èŠ‚ç‚¹åæ’å…¥ï¼Œä¸å¿…ä»å¤´éå†

### 4ï¸âƒ£ åœ¨æŒ‡å®šèŠ‚ç‚¹å‰æ’å…¥

```
void insertBefore(Node* &head, Node* target, int val) {
    if (target == nullptr) return;
    
    // ç‰¹æ®Šæƒ…å†µï¼šåœ¨å¤´èŠ‚ç‚¹å‰æ’å…¥
    if (target == head) {
        insertAtHead(head, val);
        return;
    }
    
    Node* newNode = new Node(val);
    
    // æ–°èŠ‚ç‚¹è¿æ¥åé¢çš„èŠ‚ç‚¹
    newNode->next = target;
    
    // æ–°èŠ‚ç‚¹è¿æ¥å‰é¢çš„èŠ‚ç‚¹
    newNode->prev = target->prev;
    target->prev->next = newNode;
    
    target->prev = newNode; // ç›®æ ‡èŠ‚ç‚¹çš„prevæŒ‡å‘æ–°èŠ‚ç‚¹
}
```

> âœ¨ **åŒå‘é“¾è¡¨çš„ç‹¬ç‰¹ä¼˜åŠ¿**ï¼šæ— éœ€ä»å¤´éå†å³å¯å‘å‰æ’å…¥

### 5ï¸âƒ£ åˆ é™¤èŠ‚ç‚¹ï¼ˆæ ¸å¿ƒä¼˜åŠ¿æ“ä½œï¼‰

```
void deleteNode(Node* &head, Node* target) {
    if (head == nullptr || target == nullptr) return;
    
    // æƒ…å†µ1ï¼šåˆ é™¤å¤´èŠ‚ç‚¹
    if (target == head) {
        head = target->next;
        if (head != nullptr) {
            head->prev = nullptr; // æ–°å¤´èŠ‚ç‚¹prevç½®ç©º
        }
        delete target;
        return;
    }
    
    // æƒ…å†µ2ï¼šåˆ é™¤ä¸­é—´æˆ–å°¾éƒ¨èŠ‚ç‚¹
    if (target->prev != nullptr) {
        target->prev->next = target->next; // å‰èŠ‚ç‚¹è·³è¿‡target
    }
    
    if (target->next != nullptr) {
        target->next->prev = target->prev; // åèŠ‚ç‚¹è·³è¿‡target
    }
    
    delete target; // é‡Šæ”¾å†…å­˜
}
```

> ğŸš€ **æ ¸å¿ƒä¼˜åŠ¿**ï¼šåˆ é™¤èŠ‚ç‚¹æ—¶ä»…éœ€ä¿®æ”¹ç›¸é‚»èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œæ— éœ€æŸ¥æ‰¾å‰èŠ‚ç‚¹

### 6ï¸âƒ£ åŒå‘éå†å®ç°

```
// æ­£å‘éå†
void printForward(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " â†’ ";
        current = current->next;
    }
    cout << "NULL" << endl;
}

// åå‘éå†ï¼ˆéœ€å…ˆåˆ°è¾¾å°¾éƒ¨ï¼‰
void printBackward(Node* head) {
    Node* current = head;
    
    // éå†åˆ°å°¾éƒ¨
    while (current != nullptr && current->next != nullptr) {
        current = current->next;
    }
    
    // ä»å°¾éƒ¨å‘å¤´éƒ¨åå‘éå†
    while (current != nullptr) {
        cout << current->data << " â†’ ";
        current = current->prev;
    }
    cout << "START" << endl;
}
```

## ğŸŒ åŒå‘é“¾è¡¨çš„å®é™…åº”ç”¨åœºæ™¯

1. **æµè§ˆå™¨å†å²è®°å½•**ï¼š
   - å‰è¿›ï¼šnextæŒ‡é’ˆ
   - åé€€ï¼šprevæŒ‡é’ˆ
   - åˆ é™¤è®°å½•ï¼šè½»æ¾ç§»é™¤ä»»æ„èŠ‚ç‚¹
2. **éŸ³ä¹æ’­æ”¾åˆ—è¡¨**ï¼š
   - ä¸‹ä¸€æ›²ï¼šnextæŒ‡é’ˆ
   - ä¸Šä¸€æ›²ï¼šprevæŒ‡é’ˆ
   - åˆ é™¤æ­Œæ›²ï¼šç›´æ¥åˆ é™¤å½“å‰èŠ‚ç‚¹
3. **æ–‡æœ¬ç¼–è¾‘å™¨æ’¤é”€/é‡åšåŠŸèƒ½**ï¼š
   - æ¯æ¬¡æ“ä½œä½œä¸ºæ–°èŠ‚ç‚¹
   - æ’¤é”€ï¼šç§»åŠ¨åˆ°prev
   - é‡åšï¼šç§»åŠ¨åˆ°next
4. **LRUç¼“å­˜æ·˜æ±°ç®—æ³•**ï¼š
   - å¿«é€Ÿç§»åŠ¨èŠ‚ç‚¹åˆ°åˆ—è¡¨å¤´éƒ¨
   - é«˜æ•ˆåˆ é™¤å°¾èŠ‚ç‚¹

## ğŸ“Š æ€§èƒ½å¯¹æ¯”ï¼šåŒå‘é“¾è¡¨ vs å•å‘é“¾è¡¨

| æ“ä½œ             | å•å‘é“¾è¡¨     | åŒå‘é“¾è¡¨   | åˆ†æ         |
| ---------------- | ------------ | ---------- | ------------ |
| **å¤´æ’/å¤´åˆ **    | O(1)         | O(1)       | æ€§èƒ½ç›¸å½“     |
| **å°¾æ’/å°¾åˆ **    | O(n)         | O(n)       | æ€§èƒ½ç›¸å½“     |
| **å·²çŸ¥ä½ç½®æ’å…¥** | O(1)         | O(1)       | æ€§èƒ½ç›¸å½“     |
| **æœªçŸ¥ä½ç½®æ’å…¥** | O(n)         | O(n)       | éƒ½éœ€è¦éå†   |
| **åˆ é™¤ä»»æ„èŠ‚ç‚¹** | O(1)éœ€å‰èŠ‚ç‚¹ | O(1)       | åŒå‘æœ‰ä¼˜åŠ¿   |
| **é€†å‘è®¿é—®**     | ä¸å¯èƒ½       | O(n)       | åŒå‘ç‰¹æœ‰     |
| **å‰å‘æ’å…¥**     | O(n)         | O(1)       | åŒå‘ä¼˜åŠ¿     |
| **å†…å­˜å ç”¨**     | 1æŒ‡é’ˆ/èŠ‚ç‚¹   | 2æŒ‡é’ˆ/èŠ‚ç‚¹ | å•å‘èŠ‚çœå†…å­˜ |

## ğŸ’» å®Œæ•´å®ç°ç¤ºä¾‹

```
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

void insertAtHead(Node* &head, int val) {
    Node* newNode = new Node(val);
    if (head != nullptr) {
        head->prev = newNode;
    }
    newNode->next = head;
    head = newNode;
}

void insertAtTail(Node* &head, int val) {
    Node* newNode = new Node(val);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    
    Node* current = head;
    while (current->next != nullptr) {
        current = current->next;
    }
    
    current->next = newNode;
    newNode->prev = current;
}

void deleteNode(Node* &head, Node* target) {
    if (head == nullptr || target == nullptr) return;
    
    // è°ƒæ•´ç›¸é‚»èŠ‚ç‚¹çš„æŒ‡é’ˆ
    if (target->prev != nullptr) {
        target->prev->next = target->next;
    }
    if (target->next != nullptr) {
        target->next->prev = target->prev;
    }
    
    // å¤„ç†å¤´èŠ‚ç‚¹æƒ…å†µ
    if (target == head) {
        head = target->next;
    }
    
    delete target;
}

void printForward(Node* head) {
    Node* current = head;
    cout << "æ­£å‘éå†: ";
    while (current != nullptr) {
        cout << current->data;
        if (current->next != nullptr) cout << " â†’ ";
        current = current->next;
    }
    cout << " â†’ NULL" << endl;
}

void printBackward(Node* head) {
    Node* current = head;
    // å®šä½åˆ°å°¾éƒ¨
    while (current != nullptr && current->next != nullptr) {
        current = current->next;
    }
    
    cout << "åå‘éå†: NULL â† ";
    while (current != nullptr) {
        cout << current->data;
        if (current->prev != nullptr) cout << " â† ";
        current = current->prev;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    
    insertAtTail(head, 10);
    insertAtTail(head, 20);
    insertAtHead(head, 5);
    
    printForward(head); // è¾“å‡º: 5 â†’ 10 â†’ 20 â†’ NULL
    printBackward(head); // è¾“å‡º: NULL â† 20 â† 10 â† 5
    
    // åœ¨20èŠ‚ç‚¹å‰æ’å…¥15ï¼ˆéœ€æ‰¾åˆ°20èŠ‚ç‚¹ï¼‰
    Node* node20 = head->next->next;
    Node* newNode = new Node(15);
    
    // è¿æ¥æ–°èŠ‚ç‚¹å’Œnode20çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    newNode->prev = node20->prev;
    node20->prev->next = newNode;
    
    // è¿æ¥æ–°èŠ‚ç‚¹å’Œnode20
    newNode->next = node20;
    node20->prev = newNode;
    
    printForward(head); // 5 â†’ 10 â†’ 15 â†’ 20 â†’ NULL
    
    // åˆ é™¤å€¼ä¸º10çš„èŠ‚ç‚¹
    Node* node10 = head->next;
    deleteNode(head, node10);
    printForward(head); // 5 â†’ 15 â†’ 20 â†’ NULL
    
    return 0;
}
```

## ğŸ“š å­¦ä¹ å»ºè®®

1. **å›¾è§£æ³•**ï¼šåœ¨çº¸ä¸Šç”»å‡ºæ¯ä¸ªæ“ä½œæ­¥éª¤çš„æŒ‡é’ˆå˜åŒ–
2. **åˆ†æ­¥è°ƒè¯•**ï¼šç”¨ç®€å•æ•°æ®é›†ï¼ˆ3-4ä¸ªèŠ‚ç‚¹ï¼‰è§‚å¯Ÿæ¯ä¸€æ­¥çŠ¶æ€
3. **å®é™…åº”ç”¨**ï¼šå®ç°ä¸€ä¸ªç®€å•çš„æµè§ˆå™¨å†å²è®°å½•ç®¡ç†å™¨
4. **å¯¹æ¯”å­¦ä¹ **ï¼šä¸å•å‘é“¾è¡¨å¹¶è¡Œæ¯”è¾ƒå„è‡ªæ“ä½œ

# C++ä¸­çš„ `std::unordered_map`ï¼šå“ˆå¸Œè¡¨çš„å®Œç¾å®ç°

æ˜¯çš„ï¼Œ**`std::unordered_map` æ˜¯ C++ æ ‡å‡†åº“æä¾›çš„å“ˆå¸Œè¡¨å®ç°**ï¼Œå¯ä»¥ç›´æ¥ç”¨äºå“ˆå¸Œè¡¨çš„éœ€æ±‚ã€‚

## ğŸ§  `std::unordered_map` æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§           | è¯´æ˜                                         |
| -------------- | -------------------------------------------- |
| **æ•°æ®ç»“æ„**   | åŸºäºå“ˆå¸Œè¡¨ï¼ˆå¼€æ”¾å¯»å€æ³•æˆ–é“¾åœ°å€æ³•ï¼‰           |
| **æ—¶é—´å¤æ‚åº¦** | å¹³å‡ O(1)ï¼Œæœ€å O(n)                         |
| **é”®å”¯ä¸€æ€§**   | é”®å¿…é¡»å”¯ä¸€ï¼ˆç±»ä¼¼æ•°å­¦é›†åˆï¼‰                   |
| **å…ƒç´ é¡ºåº**   | **æ— åº**å­˜å‚¨ï¼ˆä¸ `std::map` æœ‰åºçº¢é»‘æ ‘å¯¹æ¯”ï¼‰ |
| **æ ‡å‡†æ”¯æŒ**   | C++11 å¼•å…¥ï¼Œæ‰€æœ‰ç°ä»£ç¼–è¯‘å™¨æ”¯æŒ               |

## ğŸ” åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

```
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // åˆ›å»º unordered_map
    std::unordered_map<std::string, int> ageMap;
    
    // æ’å…¥æ•°æ®çš„ä¸‰ç§æ–¹å¼
    ageMap["Alice"] = 30;              // ä¸‹æ ‡æ“ä½œç¬¦
    ageMap.insert({"Bob", 25});         // insert æ–¹æ³•
    ageMap.emplace("Charlie", 28);     // åŸåœ°æ„é€ ï¼ˆé«˜æ•ˆï¼‰
    
    // è®¿é—®å…ƒç´ 
    std::cout << "Alice is " << ageMap["Alice"] << " years old\n";
    
    // å®‰å…¨çš„å…ƒç´ è®¿é—®
    if (ageMap.find("David") != ageMap.end()) {
        std::cout << "David's age: " << ageMap["David"] << "\n";
    } else {
        std::cout << "David not found!\n";
    }
    
    // éå†æ‰€æœ‰å…ƒç´ 
    std::cout << "\nAll entries:\n";
    for (const auto& pair : ageMap) {
        std::cout << pair.first << ": " << pair.second << "\n";
    }
    
    // åˆ é™¤å…ƒç´ 
    ageMap.erase("Bob");
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«é”®
    std::cout << "\nContains Charlie? "
              << (ageMap.count("Charlie") ? "Yes" : "No") << "\n";
    
    return 0;
}
```

## âš™ï¸ ä¸»è¦æˆå‘˜å‡½æ•°è¯¦è§£

### 1. æ’å…¥æ“ä½œ

| æ–¹æ³•                              | æè¿°          | è¿”å›å€¼                      |
| --------------------------------- | ------------- | --------------------------- |
| `insert(const value_type& value)` | æ’å…¥é”®å€¼å¯¹    | `std::pair<iterator, bool>` |
| `emplace(Args&&... args)`         | åŸåœ°æ„é€ æ’å…¥  | `std::pair<iterator, bool>` |
| `operator[](const key_type& k)`   | ä¸‹æ ‡è®¿é—®/æ’å…¥ | `mapped_type` å¼•ç”¨          |

### 2. è®¿é—®æ“ä½œ

| æ–¹æ³•                       | æè¿°                 | å®‰å…¨çº§åˆ«                        |
| -------------------------- | -------------------- | ------------------------------- |
| `at(const key_type& k)`    | å¸¦è¾¹ç•Œæ£€æŸ¥çš„è®¿é—®     | æŠ›å‡º `std::out_of_range`        |
| `operator[]`               | ä¸‹æ ‡è®¿é—®ï¼ˆè‡ªåŠ¨æ’å…¥ï¼‰ | **ä¸å®‰å…¨**ï¼ˆå¯èƒ½æ„å¤–åˆ›å»ºæ–°é”®ï¼‰  |
| `find(const key_type& k)`  | æŸ¥æ‰¾è¿­ä»£å™¨           | å®‰å…¨ï¼ˆè¿”å› `end()` è¡¨ç¤ºæœªæ‰¾åˆ°ï¼‰ |
| `count(const key_type& k)` | é”®å­˜åœ¨æ€§æ£€æŸ¥         | è¿”å› 0 æˆ– 1                     |

### 3. åˆ é™¤æ“ä½œ

| æ–¹æ³•                       | æè¿°           |
| -------------------------- | -------------- |
| `erase(iterator pos)`      | é€šè¿‡è¿­ä»£å™¨åˆ é™¤ |
| `erase(const key_type& k)` | é€šè¿‡é”®åˆ é™¤     |
| `clear()`                  | æ¸…ç©ºæ‰€æœ‰å†…å®¹   |

### 4. å®¹é‡ä¸ä¿¡æ¯

| æ–¹æ³•                | æè¿°                  |
| ------------------- | --------------------- |
| `size()`            | è¿”å›å…ƒç´ æ•°é‡          |
| `empty()`           | æ£€æŸ¥æ˜¯å¦ä¸ºç©º          |
| `bucket_count()`    | è¿”å›æ¡¶æ•°é‡            |
| `load_factor()`     | å½“å‰è´Ÿè½½å› å­          |
| `max_load_factor()` | è·å–/è®¾ç½®æœ€å¤§è´Ÿè½½å› å­ |

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. è®¾ç½®åˆå§‹å®¹é‡

```
// é¢„åˆ†é…å¤§å®¹é‡é¿å…å¤šæ¬¡rehash
std::unordered_map<int, std::string> bigMap;
bigMap.reserve(10'000);  // é¢„åˆ†é…ç©ºé—´ï¼ˆä¸åˆå§‹åŒ–æ¡¶ï¼‰
```

### 2. æ§åˆ¶è´Ÿè½½å› å­

```
std::unordered_map<std::string, double> scores;
scores.max_load_factor(0.7);  // è®¾ç½®æœ€å¤§è´Ÿè½½å› å­ä¸º0.7
scores.reserve(1000);         // ç¡®ä¿è¶³å¤Ÿç©ºé—´
```

### 3. ä¼˜åŒ–å“ˆå¸Œå‡½æ•°

```
struct Point {
    int x, y;
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

// è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°
struct PointHash {
    size_t operator()(const Point& p) const {
        // ç®€å•ä½†æœ‰æ•ˆçš„ç»„åˆå“ˆå¸Œ
        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);
    }
};

// ä½¿ç”¨è‡ªå®šä¹‰å“ˆå¸Œ
std::unordered_map<Point, std::string, PointHash> pointMap;
```

### 4. é«˜æ•ˆè¿­ä»£å’Œåˆ é™¤

```
std::unordered_map<std::string, int> tempMap = {{"a",1}, {"b",2}, {"c",3}};

// åˆ é™¤ç‰¹å®šæ¡ä»¶çš„å…ƒç´ 
for (auto it = tempMap.begin(); it != tempMap.end(); ) {
    if (it->second % 2 == 0) {
        it = tempMap.erase(it);  // eraseè¿”å›ä¸‹ä¸€ä¸ªæœ‰æ•ˆè¿­ä»£å™¨
    } else {
        ++it;
    }
}
```

## ğŸ†š `std::unordered_map` vs `std::map`

| ç‰¹æ€§           | `std::unordered_map`  | `std::map`       |
| -------------- | --------------------- | ---------------- |
| **åº•å±‚å®ç°**   | å“ˆå¸Œè¡¨                | çº¢é»‘æ ‘           |
| **æŸ¥æ‰¾å¤æ‚åº¦** | O(1) å¹³å‡ / O(n) æœ€å | O(log n)         |
| **å­˜å‚¨é¡ºåº**   | æ— åº                  | æŒ‰é”®æ’åº         |
| **å†…å­˜å ç”¨**   | ç•¥é«˜ï¼ˆæ¡¶ç»“æ„ï¼‰        | ç•¥ä½             |
| **è¿­ä»£æ€§èƒ½**   | ç¨æ…¢ï¼ˆéè¿ç»­å†…å­˜ï¼‰    | æ›´å¿«ï¼ˆè¿ç»­éå†ï¼‰ |
| **é”®è¦æ±‚**     | å¯å“ˆå¸Œ + å¯ç›¸ç­‰æ¯”è¾ƒ   | ä¸¥æ ¼å¼±åº         |

**é€‰æ‹©ä¾æ®**ï¼š

- éœ€è¦æé€ŸæŸ¥æ‰¾ â†’ **`std::unordered_map`**
- éœ€è¦å…ƒç´ æœ‰åº â†’ **`std::map`**
- å†…å­˜æåº¦å—é™ â†’ è€ƒè™‘å¼€æºåº“æ›¿ä»£ï¼ˆå¦‚ Abseil, Follyï¼‰

## ğŸš¨ å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šè‡ªåŠ¨æ’å…¥å±é™©

```
std::unordered_map<std::string, int> scores;
// å±é™©æ“ä½œï¼šè®¿é—®ä¸å­˜åœ¨çš„é”®ä¼šåˆ›å»ºæ–°å…ƒç´ 
if (scores["Alice"] > 90) { /* ... */ } // åˆ›å»ºäº†Alice:0ï¼

// è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨find()æ›¿ä»£
auto it = scores.find("Bob");
if (it != scores.end() && it->second > 90) { /* ... */ }
```

### é—®é¢˜2ï¼šå¼•ç”¨å¤±æ•ˆ

```
auto& ref = scores["Alice"]; // è·å–å¼•ç”¨
scores.rehash(100);          // é‡å“ˆå¸Œå¯¼è‡´å¼•ç”¨å¤±æ•ˆï¼

// è§£å†³æ–¹æ¡ˆï¼šé¿å…é•¿æœŸä¿å­˜å¼•ç”¨
if (scores.find("Alice") != scores.end()) {
    // å±€éƒ¨ä½œç”¨åŸŸå†…ä½¿ç”¨å¼•ç”¨
    auto& safeRef = scores["Alice"];
    // ç«‹å³ä½¿ç”¨safeRef...
}
```

### é—®é¢˜3ï¼šè‡ªå®šä¹‰é”®ç±»å‹é”™è¯¯

```
struct Key {
    int id;
    // ç¼ºå°‘å“ˆå¸Œå‡½æ•°å’Œ==è¿ç®—ç¬¦
};

// ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘å“ˆå¸Œç‰¹åŒ–
std::unordered_map<Key, std::string> errorMap; 

// è§£å†³æ–¹æ¡ˆï¼šæä¾›å®Œæ•´æ”¯æŒ
struct Key {
    int id;
    bool operator==(const Key& other) const { 
        return id == other.id; 
    }
};

namespace std {
    template<> 
    struct hash<Key> {
        size_t operator()(const Key& k) const {
            return std::hash<int>()(k.id);
        }
    };
}
```

## ğŸŒ é«˜çº§åº”ç”¨åœºæ™¯

### 1. LRU ç¼“å­˜å®ç°

```
#include <unordered_map>
#include <list>

template <typename K, typename V>
class LRUCache {
private:
    size_t capacity;
    std::list<std::pair<K, V>> items;
    std::unordered_map<K, typename std::list<std::pair<K, V>>::iterator> cacheMap;

public:
    LRUCache(size_t cap) : capacity(cap) {}
    
    V* get(const K& key) {
        auto it = cacheMap.find(key);
        if (it == cacheMap.end()) return nullptr;
        
        // ç§»åŠ¨æœ€è¿‘è®¿é—®é¡¹åˆ°é“¾è¡¨å‰ç«¯
        items.splice(items.begin(), items, it->second);
        return &(it->second->second);
    }
    
    void put(const K& key, const V& value) {
        auto it = cacheMap.find(key);
        if (it != cacheMap.end()) {
            // æ›´æ–°ç°æœ‰å€¼å¹¶åˆ·æ–°ä½ç½®
            it->second->second = value;
            items.splice(items.begin(), items, it->second);
            return;
        }
        
        // æ’å…¥æ–°é¡¹
        items.emplace_front(key, value);
        cacheMap[key] = items.begin();
        
        // æ£€æŸ¥å®¹é‡å¹¶æ·˜æ±°æœ€æ—§é¡¹
        if (items.size() > capacity) {
            auto last = items.end();
            --last;
            cacheMap.erase(last->first);
            items.pop_back();
        }
    }
};
```

### 2. åˆ†ç»„è®¡æ•°

```
std::vector<std::string> names = {"Alice", "Bob", "Alice", "Charlie", "Bob"};

std::unordered_map<std::string, size_t> nameCount;
for (const auto& name : names) {
    ++nameCount[name]; // è‡ªåŠ¨åˆå§‹åŒ–æ–°é”®å€¼ä¸º0
}

// è¾“å‡ºç»“æœ
for (const auto& [name, count] : nameCount) {
    std::cout << name << ": " << count << " times\n";
}
```

### 3. å¤šç´¢å¼•æŸ¥æ‰¾

```
struct Person {
    int id;
    std::string name;
    std::string email;
};

// å¤šç´¢å¼•å®¹å™¨
std::unordered_map<int, Person> idIndex;        // æŒ‰IDç´¢å¼•
std::unordered_map<std::string, Person*> emailIndex; // æŒ‰emailç´¢å¼•

void addPerson(const Person& p) {
    auto [it, inserted] = idIndex.emplace(p.id, p);
    if (inserted) {
        emailIndex[p.email] = &it->second;
    }
}

Person* findByEmail(const std::string& email) {
    auto it = emailIndex.find(email);
    return (it != emailIndex.end()) ? it->second : nullptr;
}
```

## ğŸš€ æ›¿ä»£ä¼˜åŒ–æ–¹æ¡ˆï¼ˆå½“æ ‡å‡†åº“ä¸è¶³æ—¶ï¼‰

1. **Abseil çš„ `flat_hash_map`**
   - Google ä¼˜åŒ–çš„å¼€æ”¾å¯»å€å“ˆå¸Œè¡¨
   - å†…å­˜æ›´ç´§å‡‘ï¼ŒCPU ç¼“å­˜æ›´å‹å¥½
   - æ¥å£å…¼å®¹ `std::unordered_map`
2. **Folly F14 å®¹å™¨**
   - Facebook å¼€å‘çš„é«˜æ€§èƒ½å“ˆå¸Œè¡¨
   - æ”¯æŒ SIMD ä¼˜åŒ–æŸ¥æ‰¾
   - ç‰¹åˆ«é€‚åˆå¤§æ•°æ®é›†
3. **Bloomberg çš„ BDE å®¹å™¨**
   - ä¼ä¸šçº§é«˜æ€§èƒ½å“ˆå¸Œè¡¨å®ç°
   - æä¾›æ›´å¤šè°ƒä¼˜å‚æ•°
   - å†…å­˜åˆ†é…å™¨é›†æˆæ›´æ·±å…¥
4. **Robin Hood Hashing**
   - ç°ä»£å¼€æ”¾å¯»å€æ–¹æ¡ˆ
   - æ›´å‡åŒ€çš„æ¢æµ‹è·ç¦»
   - å®ç°è§ `robin_hood.h` å•æ–‡ä»¶åº“

## ğŸ’ æ€»ç»“

`std::unordered_map` æ˜¯ C++ å“ˆå¸Œè¡¨çš„å®˜æ–¹å®ç°ï¼š

- **ç›´æ¥å¯ç”¨**ï¼šæ— éœ€å®ç°åŸºç¡€æ•°æ®ç»“æ„
- **é«˜æ€§èƒ½**ï¼šè‡ªåŠ¨ç®¡ç†å†…å­˜å’Œå“ˆå¸Œå†²çª
- **ç±»å‹å®‰å…¨**ï¼šå¼ºç±»å‹é”®å€¼å¯¹
- **å¯æ‰©å±•**ï¼šæ”¯æŒè‡ªå®šä¹‰å“ˆå¸Œå’Œæ¯”è¾ƒå‡½æ•°

é€‚ç”¨åœºæ™¯ï¼š

- é«˜é¢‘æŸ¥æ‰¾/æ’å…¥/åˆ é™¤æ“ä½œ
- ä¸éœ€è¦å…ƒç´ æ’åº
- æ•°æ®é‡ä¸ç¡®å®šæˆ–è¾ƒå¤§
- é”®å¯å“ˆå¸Œä¸”å…·æœ‰ç›¸ç­‰æ¯”è¾ƒ

ä½¿ç”¨æœ€ä½³å®è·µï¼š

1. é¢„åˆ†é…è¶³å¤Ÿç©ºé—´ï¼ˆ`reserve()`ï¼‰
2. ä½¿ç”¨ `emplace` åŸåœ°æ„é€ 
3. é¿å…é•¿æœŸä¿å­˜å¼•ç”¨
4. ä¸ºè‡ªå®šä¹‰ç±»å‹ç‰¹åŒ– `std::hash`

å¯¹äºç»å¤§å¤šæ•°åº”ç”¨åœºæ™¯ï¼Œ`std::unordered_map` æä¾›äº†è¶³å¤Ÿä¼˜ç§€ä¸”å¯é çš„å“ˆå¸Œè¡¨å®ç°ï¼Œæ˜¯ç°ä»£ C++ å¼€å‘çš„å¿…å¤‡å·¥å…·ä¹‹ä¸€ã€‚

## ä¾‹é¢˜ï¼š

## é¢˜ç›®èƒŒæ™¯

å‡ºé¢˜æ˜¯ä¸€ä»¶ç—›è‹¦çš„äº‹æƒ…ï¼

ç›¸åŒçš„é¢˜ç›®çœ‹å¤šäº†ä¹Ÿä¼šæœ‰å®¡ç¾ç–²åŠ³ï¼Œäºæ˜¯æˆ‘èˆå¼ƒäº†å¤§å®¶æ‰€ç†Ÿæ‚‰çš„ A+B Problemï¼Œæ”¹ç”¨ A-B äº†å“ˆå“ˆï¼

## é¢˜ç›®æè¿°

ç»™å‡ºä¸€ä¸²æ­£æ•´æ•°æ•°åˆ—ä»¥åŠä¸€ä¸ªæ­£æ•´æ•° $C$ï¼Œè¦æ±‚è®¡ç®—å‡ºæ‰€æœ‰æ»¡è¶³ $A - B = C$ çš„æ•°å¯¹çš„ä¸ªæ•°ï¼ˆä¸åŒä½ç½®çš„æ•°å­—ä¸€æ ·çš„æ•°å¯¹ç®—ä¸åŒçš„æ•°å¯¹ï¼‰ã€‚

## è¾“å…¥æ ¼å¼

è¾“å…¥å…±ä¸¤è¡Œã€‚

ç¬¬ä¸€è¡Œï¼Œä¸¤ä¸ªæ­£æ•´æ•° $N,C$ã€‚

ç¬¬äºŒè¡Œï¼Œ$N$ ä¸ªæ­£æ•´æ•°ï¼Œä½œä¸ºè¦æ±‚å¤„ç†çš„é‚£ä¸²æ•°ã€‚

## è¾“å‡ºæ ¼å¼

ä¸€è¡Œï¼Œè¡¨ç¤ºè¯¥ä¸²æ­£æ•´æ•°ä¸­åŒ…å«çš„æ»¡è¶³ $A - B = C$ çš„æ•°å¯¹çš„ä¸ªæ•°ã€‚

## è¾“å…¥è¾“å‡ºæ ·ä¾‹ #1

### è¾“å…¥ #1

```
4 1
1 1 2 3
```

### è¾“å‡º #1

```
3
```

## è¯´æ˜/æç¤º

å¯¹äº $75\%$ çš„æ•°æ®ï¼Œ$1 \leq N \leq 2000$ã€‚

å¯¹äº $100\%$ çš„æ•°æ®ï¼Œ$1 \leq N \leq 2 \times 10^5$ï¼Œ$0 \leq a_i <2^{30}$ï¼Œ$1 \leq C < 2^{30}$ã€‚

2017/4/29 æ–°æ·»æ•°æ®ä¸¤ç»„

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N;
    long long C;
    cin >> N >> C;
    vector<long long> nums(N);
    unordered_map<long long, long long> count;
    
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°
    for (int i = 0; i < N; i++) {
        cin >> nums[i];
        count[nums[i]]++;
    }
    
    long long result = 0;
    
    if (C != 0) {
        // å¤„ç† C â‰  0 çš„æƒ…å†µ
        for (int i = 0; i < N; i++) {
            long long target = nums[i] + C;
            result += count[target];
        }
    } else {
        // å¤„ç† C = 0 çš„æƒ…å†µï¼ˆç›¸åŒæ•°å­—é…å¯¹ï¼‰
        for (int i = 0; i < N; i++) {
            result += (count[nums[i]] - 1);
        }
    }
    
    cout << result << endl;
    return 0;
}
```

å“ˆå¸Œè¡¨ï¼Œç§’äº†ï¼Œæœ‰ä»€ä¹ˆå¥½è¯´çš„ï¼ˆï¼‰