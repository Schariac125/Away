# 数据结构：图论

## 概念与建立

## 图的概念与建立方法

## 一、图的基本概念

图（Graph）是一种重要的非线性数据结构，由**顶点（Vertex）** 和 **边（Edge）** 组成，用于表示各种实体之间的关系。

### 1. 图的基本组成

- **顶点**：表示实体或对象（图中通常用圆圈表示）
- **边**：表示顶点之间的关系（图中通常用线段表示）

### 2. 图的分类

| 分类方式       | 类型       | 特点描述                                 |
| -------------- | ---------- | ---------------------------------------- |
| 边有无方向     | **有向图** | 边有方向，代表单向关系（A→B 不等于 B→A） |
|                | **无向图** | 边无方向，代表双向关系（A-B 等价于 B-A） |
| 边是否含权重   | **加权图** | 边带有数值权重（如距离、代价等）         |
|                | **无权图** | 边无权重值                               |
| 是否有自环重边 | **简单图** | 无自环（顶点到自身的边）和无重边         |
|                | **多重图** | 允许有重边                               |

### 3. 图的相关术语

- **度（Degree）**：与顶点相连的边数（有向图分为**入度**和**出度**）
- **路径（Path）**：顶点序列（如 A→B→C）
- **回路（Cycle）**：起点和终点相同的路径（如 A→B→C→A）
- **连通性**：无向图中任意两顶点间有路径则为**连通图**；有向图中则为**强连通图**
- **连通分量**：图中最大连通子图

## 二、图的建立方法

### 1. 邻接矩阵（Adjacency Matrix）

适合表示**稠密图**，空间复杂度 O(V²)，其中 V 为顶点数。

**无向无权图示例（C++实现）**：

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int V = 5; // 顶点数
    vector<vector<int>> matrix(V, vector<int>(V, 0)); // 初始化5x5矩阵
    
    // 添加边 (无向图)
    auto addEdge = [&](int u, int v) {
        matrix[u][v] = 1;
        matrix[v][u] = 1; // 无向图双向表示
    };
    
    // 建立图结构
    addEdge(0, 1); // A-B
    addEdge(0, 4); // A-E
    addEdge(1, 2); // B-C
    addEdge(1, 3); // B-D
    addEdge(1, 4); // B-E
    addEdge(2, 3); // C-D
    addEdge(3, 4); // D-E
    
    // 打印邻接矩阵
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

### 2. 邻接表（Adjacency List）

适合表示**稀疏图**，空间复杂度 O(V+E)，其中 E 为边数。

**加权有向图示例（C++实现）**：

```
#include <iostream>
#include <vector>
#include <list>
using namespace std;

int main() {
    int V = 5; // 顶点数
    vector<list<pair<int, int>>> adjList(V); // 邻接表（(邻居顶点, 权重)）
    
    // 添加有向边（源顶点，目标顶点，权重）
    auto addDirectedEdge = [&](int src, int dest, int weight) {
        adjList[src].push_back({dest, weight});
    };
    
    // 建立图结构
    addDirectedEdge(0, 1, 5); // A->B (权重5)
    addDirectedEdge(0, 4, 3); // A->E (权重3)
    addDirectedEdge(1, 2, 2); // B->C (权重2)
    addDirectedEdge(1, 3, 1); // B->D (权重1)
    addDirectedEdge(3, 4, 4); // D->E (权重4)
    
    // 打印邻接表
    for (int i = 0; i < V; ++i) {
        cout << "顶点" << i << "的邻居：";
        for (auto neighbor : adjList[i]) {
            cout << "-> (" << neighbor.first << ", w=" << neighbor.second << ") ";
        }
        cout << endl;
    }
    return 0;
}
```

## 三、图的应用场景

1. **社交网络**：顶点代表用户，边代表好友关系
2. **交通系统**：顶点代表地点，边代表路线（权重可以是距离或时间）
3. **任务调度**：顶点代表任务，边代表任务依赖关系
4. **知识图谱**：顶点代表实体，边代表实体间关系
5. **推荐系统**：顶点代表用户和商品，边代表交互行为

## 四、图算法基础

1. **遍历算法**：
   - 深度优先搜索（DFS）
   - 广度优先搜索（BFS）
2. **最短路径算法**：
   - Dijkstra算法（无负权图单源最短路径）
   - Bellman-Ford算法（含负权图单源最短路径）
   - Floyd-Warshall算法（多源最短路径）
3. **连通性算法**：
   - Kosaraju算法（强连通分量）
   - Tarjan算法（强连通分量）
4. **最小生成树算法**：
   - Prim算法
   - Kruskal算法
5. **拓扑排序**：对有向无环图（DAG）顶点排序

> 提示：根据具体问题需求（稀疏/稠密、有无权重、有向/无向等）选择合适的图表示方法至关重要。邻接矩阵空间开销大但查询快，邻接表空间效率高但查询稍慢。

（以上内容全是AI生成的）

## 例题：

## P5318 【深基18.例3】查找文献

## 题目描述

小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(1\le n\le10^5)$ 篇文章（编号为 $1$ 到 $n$）以及 $m(1\le m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 $X\to Y$ 表示文章 $X$ 有参考文献 $Y$。不保证编号为 $1$ 的文章没有被其他文章引用。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇（因此你可能需要先排序）。

## 输入格式

共 $m+1$ 行，第 $1$ 行为 $2$ 个数，$n$ 和 $m$，分别表示一共有 $n(1\le n\le10^5)$ 篇文章（编号为 $1$ 到 $n$）以及$m(1\le m\le10^6)$ 条参考文献引用关系。

接下来 $m$ 行，每行有两个整数 $X,Y$ 表示文章 $X$ 有参考文献 $Y$。

## 输出格式

共 $2$ 行。

第一行为 DFS 遍历结果，第二行为 BFS 遍历结果。

## 输入输出样例 #1

### 输入 #1

```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
```

### 输出 #1

```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8
```

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
set<int>e[100009];
bool vis[100009];
void init(){
	for(scanf("%d%d",&n,&m);m;--m){
		int u=0,v=0;
		scanf("%d%d",&u,&v);
		e[u].insert(v);
	}
}
void dfs(int x=1){
	if(vis[x])return;vis[x]=1;
	printf("%d ",x);
	for(int v:e[x])dfs(v);
}
void bfs(){
	queue<int>q;
	q.push(1);
	while(!q.empty()){
		int x=q.front();q.pop();
		if(vis[x])continue;vis[x]=1;
		printf("%d ",x);
		for(int v:e[x])q.push(v);
	}
}
int main(){
	init();
	dfs();
	putchar('\n');
	memset(vis,0,sizeof(vis));
	bfs();
	putchar('\n');
	return 0;
}
```

### 总结：

模板题，开背就对了。

## 例题：

## P3916 图的遍历

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，令 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。现在请求出 $A(1),A(2),\dots,A(N)$ 的值。

## 输入格式

第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。

接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\dots,N$ 编号。

## 输出格式

一行 $N$ 个整数 $A(1),A(2),\dots,A(N)$。

## 输入输出样例 #1

### 输入 #1

```
4 3
1 2
2 4
4 3
```

### 输出 #1

```
4 4 3 4
```

## 说明/提示

- 对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。
- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。

### 题解：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

#define MAXL 100010

int N, M, A[MAXL];
vector<int> G[MAXL]; //vector存图 

void dfs(int x, int d) {
	if(A[x]) return; //访问过 
	A[x] = d;
	for(int i=0; i<G[x].size(); i++)
		dfs(G[x][i], d);
}

int main() {
	int u, v;
	scanf("%d%d", &N, &M);
	for(int i=1; i<=M; i++) {
		scanf("%d%d", &u, &v);
		G[v].push_back(u); //反向建边 
	}
	for(int i=N; i; i--) dfs(i, i); 
	for(int i=1; i<=N; i++) printf("%d ", A[i]);
	printf("\n");
	return 0;
}
```

### 思路：

**反向建边 + dfs**

按题目来每次考虑每个点可以到达点编号最大的点，不如考虑较大的点可以反向到达哪些点

循环从N到1，则每个点i能访问到的结点的A值都是i

每个点访问一次，这个A值就是最优的，因为之后如果再访问到这个结点那么答案肯定没当前大了

## 例题：DAG与拓扑排序（以下两题）

## P1113 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。

## 输入格式

第 $1$ 行，一个整数 $n\ (3 \le n \le 10{,}000)$，必须完成的杂务的数目；

第 $2$ 至 $n+1$ 行，每行有一些用空格隔开的整数，分别表示：

- 工作序号（保证在输入文件中是从 $1$ 到 $n$ 有序递增的）；
- 完成工作所需要的时间 $len\ (1 \le len \le 100)$；
- 一些必须完成的准备工作，总数不超过 $100$ 个，由一个数字 $0$ 结束。有些杂务没有需要准备的工作只描述一个单独的 $0$。

保证整个输入文件中不会出现多余的空格。

## 输出格式

一个整数，表示完成所有杂务所需的最短时间。

## 输入输出样例 #1

### 输入 #1

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出 #1

```
23
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 10010

int n,x,y,t,ans,len[MAXN],vis[MAXN];
vector<int> linker[MAXN];

int dfs(int x){
    if (vis[x]) return vis[x];
    for (int i=0;i<linker[x].size();i++){
        vis[x]=max(vis[x],dfs(linker[x][i]));
    }
    vis[x]+=len[x];
    return vis[x];
}

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>x>>len[i];
        while (cin>>y){
            if (!y) break;
            else linker[y].push_back(x);
        }
    }
    for (int i=1;i<=n;i++){
        ans=max(ans,dfs(i));
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-08\Ori\6afa8ffa0ef2a8fa7f2d149c656c2597.png)

## 例题：

## P4017 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。

## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。

## 输入格式

第一行，两个正整数 $n$、$m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。

接下来 $m$ 行，每行两个正整数，表示被吃的生物 A 和吃 A 的生物 B。

## 输出格式

一行一个整数，为最大食物链数量模上 $80112002$ 的结果。

## 输入输出样例 #1

### 输入 #1

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4
```

### 输出 #1

```
5
```

## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE）

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 5005
#define MAXM 500005
#define mod 80112002

int n,m,ans;
vector<int> p[MAXN];
queue<int> q;
int f[MAXN],ind[MAXN],outd[MAXN];
int main(){
    cin>>n>>m;
    for (int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        outd[x]++;
        ind[y]++;
        p[x].push_back(y);
    }
    memset(f,0,sizeof(f));
    for (int i=1;i<=n;i++){
        if (ind[i]==0){
            q.push(i);
            f[i]=1;
        }
    }
    while (!q.empty()){
        int x=q.front();
        q.pop();
        for (int i=0;i<p[x].size();i++){
            int y=p[x][i];
            f[y]=(f[x]+f[y])%mod;
            ind[y]--;
            if (ind[y]==0){
                q.push(y);
            }
        }
    }
    for (int i=1;i<=n;i++){
        if (outd[i]==0) ans=(ans+f[i])%mod;
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

### 文字讲解

> #### 题目分析：

**首先** ，要知道这道题是 拓扑排序。不妨先从拓扑排序定义下手，分析题目的性质。经分析得：

食物链中的生物 —— **节点**

生物之间的关系 —— **有向边**

为了方便描述，我们将

**不会捕食其他生物的 生产者** 叫做 **最佳生产者**

**不会被其他生物捕食的 消费者** 叫做 **最佳消费者**

由于数据中不会出现环，所以 **最大食物链** 即 左端是 **最佳生产者** ，右端是 **最佳消费者** 的路径

而 **只要最左端是 最佳生产者** 的路径（即最右端可以不是 最佳消费者 的最大食物链） 我们称之为 **类食物链**

既然 食物链中的生物 可以看成 节点，那么 **最佳生产者** 的入度一定为 ， 而 **最佳消费者** 的出度也为

> #### 思路引导

**想要找到一条 最大食物链 ，那么这条路径的 起点 入度要为0，终点 出度要为0。** 故：

**既要记录入度，还要记录出度！**

现在的问题转换成了，**如何找到图中所有 左端点入度为0 且 右端点出度为0 的路径的数量**

> #### 正解

我们拿起笔，在草稿纸上画一个图进行推算。接下来将使用 样例 进行举例。

(将 最佳生产者 涂上 蓝色，最佳消费者 涂上 红色)

![](https://i.loli.net/2019/06/01/5cf228d6789e532172.png)

发现： **答案为 到所有 红色点 的路径条数的 总和**

（这里的 路径条数总和 不是 连向它有几条边 ，而是以它结束的 最大食物链 数量的总和）

对于上图， 号点的对应路径数量 取决于：以 到 号点的三个点（ 号、 号、 号） 结尾的 类食物链 条数的总和。

而 以 号、 号、 号 结尾的 类食物链 取决于：以 可以到达 号、号、号点 的点 结尾的 类食物链 条数的总和。

以此类推，显然对于 以 任一点 结尾的 类食物链 的数量，都取决于 **蓝色点**

各点数量对应关系在下图用绿色边标注

![](https://i.loli.net/2019/06/01/5cf22bccc4f5985650.png)

**重点：**

使用拓扑排序，由题意得知 排序第一轮被删掉的点 一定是 蓝色点（最佳生产者），而令 蓝色点 的答案为 。

当第一轮删点时，将蓝色点可以到的点 的答案 都加上 蓝色点的 答案（即加 ）。

即：**拓扑排序 需要删除的点的答案 都累加到 它可以到达的点 上面去**

**这样我们就将边的累加 转换到了 点之间的累加。**

最后累加所有 红色点（最佳消费者） 的答案，输出即可。

```cpp
以第 $i$ 号点结束的 类食物链 数量 = 以 可到达 $i$ 号点 的点 结尾的 类食物链 数量的和
```

## 以下是模拟操作过程：

~加载时间较慢，请稍等~

第一轮：删除 号蓝色点， 号蓝色点可以到的点（ 号点、 号点）都加

![31.png](https://i.loli.net/2019/06/01/5cf22f23d4d2d39278.png)

第二轮：删除 号点， 号点可以到的点（ 号点、 号红色点）都加 。此时 号点答案为 ， 号点答案为

![4.png](https://i.loli.net/2019/06/01/5cf22f23bd57f92990.png)

第三轮：删除 号点， 号点可以到的点（ 号点、 号红色点）都加 。此时 号点答案为 ， 号点答案为

![5.png](https://i.loli.net/2019/06/01/5cf22f23bf3f520577.png)

第四轮：最后删除 号点， 号点可以到的点（ 号红色点）加 ，此时 号点答案为

![6.png](https://i.loli.net/2019/06/01/5cf22f23c170424908.png)

**可见全图只有 号一个红色点，那么答案就是 号点的答案———— 了**

![16.png](https://i.loli.net/2019/06/01/5cf22f5ee28c939324.png)

## 例题：

## P2661 [NOIP 2015 提高组] 信息传递

## 题目背景

NOIP2015 Day1T2

## 题目描述

有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

## 输入格式

输入共 $2$ 行。

第一行包含 $1$ 个正整数 $n$，表示 $n$ 个人。

第二行包含 $n$ 个用空格隔开的正整数 $T_1,T_2,\cdots,T_n$，其中第 $i$ 个整数 $T_i$ 表示编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学，$T_i\leq n$ 且 $T_i\neq i$。

## 输出格式

共一行一个整数，表示游戏一共可以进行多少轮。

## 输入输出样例 #1

### 输入 #1

```
5
2 4 2 3 1
```

### 输出 #1

```
3
```

## 说明/提示

**样例 1 解释：**

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：图论.assets\3ca5zl3c.png)

游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。

- 对于 $30\%$ 的数据，$n\le 200$；
- 对于 $60\%$ 的数据，$n\le 2500$；
- 对于 $100\%$ 的数据，$n\le 2\times 10^5$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 200050
int step[maxn];
bool visit[maxn]={0},already[maxn]={0};
int n,ans=INT_MAX;
int a[maxn];
void dfs(int x,int d){
    if (already[x]) return;
    else if(visit[x]){
        ans=min(ans,d-step[x]);
    }else{
        visit[x]=1;
        step[x]=d;
        dfs(a[x],d+1);
        already[x]=1;
    }
}

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    for (int i=1;i<=n;i++){
        dfs(i,0);
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

这个思路确实厉害，下面我直接贴出来

> **可以把这些关系看成一个有向图。对于任意一个节点进入，因为每个点的出度均为1，所以最多只能构成三种情况：1、一条链；2、一个环链；3、一条链连接着一个环链。因为这三种情况极为的简单，所以就可以如下处理：**
>
> **找任意一个点进入，记录到达每一个点所走过的遍数。当走到一个在这次查找中已经出现过的节点，即找到了一个环，用当前走到的步数减去在此节点原先记录的步数，便得到这个环的长度。由此搜遍所有点，找到这些环中最小长度的一个，并把它输出就可以了。**
>
> **而如果就这样去做，会TLE，所以得再加一点优化。对于一次查找环中，由于此次查找中至多只有一个环，而此环已经确定，所以再有外部的链介入此环，它的状态仍然不变。所以可以加个判断，如果走到了已经被查找过的节点，便直接跳出。**

这个算法感觉可以用来找环

## 例题：

## P1807 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 输入格式

输入的第一行有两个整数，分别代表图的点数 $n$ 和边数 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行 $3$ 个整数 $u, v, w$（$u<v$），代表存在一条从 $u$ 到  $v$ 边权为 $w$ 的边。

## 输出格式

输出一行一个整数，代表 $1$ 到 $n$ 的最长路。

若 $1$ 无法到达 $n$，请输出 $-1$。

## 输入输出样例 #1

### 输入 #1

```
2 1
1 2 1
```

### 输出 #1

```
1
```

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 150000

class edge {
public:
    int v, w;
};

int n, m;
long long d[maxn];
vector<edge> a[maxn];

int main() {
    cin >> n >> m;
    
    // 初始化距离数组（负无穷）
    const long long INF = -1e18;
    for (int i = 1; i <= n; i++) d[i] = INF;
    d[1] = 0;  // 起点距离为0
    
    for (int i = 1; i <= m; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        a[x].push_back((edge){y, z});
    }

    // 直接利用节点编号的拓扑有序特性（u<v）
    for (int i = 1; i <= n; i++) {
        if (d[i] == INF) continue; // 跳过不可达节点
        
        for (int j = 0; j < a[i].size(); j++) {
            int y = a[i][j].v;
            int z = a[i][j].w;
            
            // 更新后继节点距离
            if (d[i] + z > d[y]) {
                d[y] = d[i] + z;
            }
        }
    }

    // 输出结果
    if (d[n] == INF) cout << -1 << endl;
    else cout << d[n] << endl;
    
    return 0;
}
```

### 思路：

有一说一第一遍写这个我以为DFS，然后用DFS11个测试点都挂掉了，后来看一眼标签，BFS……

好！BFS！我大受上一题食物链启发，我要加入出度入度！

挂了9个测试点……

下载了一下测试样例，我草这边权怎么有负数啊，阴死我了。

然后修改了一下初始数据！

挂掉了7个测试点……

倒也算进步。

然后就大败而归了，再然后就使用了**ai**大人，最后才发现我一直想复杂了。

下面贴一下ai大人的题解：

> 我根据题目要求修改了代码。主要改动是：
>
> 1. 将动态规划数组 `d[]` 初始化为负无穷，特别处理起点 `d[1]=0`
> 2. 直接利用节点编号的拓扑有序特性（题目输入保证 u < v）
> 3. 简化了拓扑排序过程，直接按节点编号1~n顺序更新
> 4. 添加了不可达判断（若 d[n] 为初值则输出 -1）
>
> ```
> #include <bits/stdc++.h>
> using namespace std;
> #define maxn 150000
> 
> class edge {
> public:
>     int v, w;
> };
> 
> int n, m;
> long long d[maxn];
> vector<edge> a[maxn];
> 
> int main() {
>     cin >> n >> m;
>     
>     // 初始化距离数组（负无穷）
>     const long long INF = -1e18;
>     for (int i = 1; i <= n; i++) d[i] = INF;
>     d[1] = 0;  // 起点距离为0
>     
>     for (int i = 1; i <= m; i++) {
>         int x, y, z;
>         cin >> x >> y >> z;
>         a[x].push_back((edge){y, z});
>     }
> 
>     // 直接利用节点编号的拓扑有序特性（u<v）
>     for (int i = 1; i <= n; i++) {
>         if (d[i] == INF) continue; // 跳过不可达节点
>         
>         for (int j = 0; j < a[i].size(); j++) {
>             int y = a[i][j].v;
>             int z = a[i][j].w;
>             
>             // 更新后继节点距离
>             if (d[i] + z > d[y]) {
>                 d[y] = d[i] + z;
>             }
>         }
>     }
> 
>     // 输出结果
>     if (d[n] == INF) cout << -1 << endl;
>     else cout << d[n] << endl;
>     
>     return 0;
> }
> ```
>
> ### 关键修改说明：
>
> 1. **初始化处理**
>
>    ```
>    const long long INF = -1e18;
>    for (int i = 1; i <= n; i++) d[i] = INF;
>    d[1] = 0;  // 确保起点初始距离为0
>    ```
>
> 2. **拓扑排序优化**
>
>    ```
>    for (int i = 1; i <= n; i++) {
>        if (d[i] == INF) continue;  // 只处理可达节点
>        
>        // 更新所有后继节点
>        for (int j = 0; j < a[i].size(); j++) {
>            // 状态转移：d[y] = max(d[y], d[i] + w)
>        }
>    }
>    ```
>
> 3. **不可达判断**
>
>    ```
>    if (d[n] == INF) cout << -1 << endl;
>    else cout << d[n] << endl;
>    ```
>
> ### 为什么这样修改符合题目要求？
>
> 1. **处理有向无环图**
>     题目输入保证 u < v，节点编号天然拓扑有序，因此可以直接从1到n顺序处理。
> 2. **处理最长路径**
>     状态转移 `d[y] = max(d[y], d[i] + w)` 保证了每个节点存储的是从起点1到该节点的最长路径。
> 3. **处理不可达情况**
>     初始化时设置所有节点距离为负无穷，如果最终 n 节点仍为负无穷，说明从起点不可达。
> 4. **避免重复更新**
>     每个节点只在其所有前驱节点处理后才会被更新（因 u < v）
> 5. **数据范围安全**
>     使用 `long long` 和足够大的 INF（-1e18），避免边权总和过大或负数导致的问题
>
> > 此解法的时间复杂度为 O(n + m)，空间复杂度 O(n + m)，完全满足题目要求。

总的来说，这种规定好起点终点还带边权的题目就不用出入度了，写太多反而容易错，bfs是神。

## 例题：

## P2853 [USACO06DEC] Cow Picnic S

## 题目描述

$K(1 \le K \le 100)$ 只奶牛分散在 $N(1 \le N \le 1000)$ 个牧场．现在她们要集中起来进餐。牧场之间有 $M(1 \le M \le 10000)$ 条有向路径连接（没有路径将牧场连接到自身）。她们进餐的地点必须是所有奶牛都可到达的地方。那么，有多少这样的牧场可供进食呢？

## 输入格式

第 $1$ 行：三个以空格分隔的整数，分别为：$K$, $N$, $M$。

第 $2$ 行到第 $K+1$ 行：每行包含一个整数 $C_i$（$1\le C_i\le N$），表示第 $i$ 头奶牛所在的牧场编号。  

第 $K+2$ 行到第 $M+K+1$ 行：每行包含两个以空格分隔的整数 $A$ 和 $B$，表示一条从牧场 $A$ 到牧场 $B$ 的单向路径。（$1\le A,B\le N, A\neq B$）

## 输出格式

第一行：一个整数，即所有奶牛都可以到达的牧场数量。

## 输入输出样例 #1

### 输入 #1

```
2 4 4
2
3
1 2
1 4
2 3
3 4
```

### 输出 #1

```
2
```

## 说明/提示

奶牛可以在 $3$ 或 $4$ 号牧场相遇。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 10010
int k,n,m,num=0;
vector<int> a[maxn];
int b[maxn],vis[maxn],ret[maxn];
void dfs(int x){
    if (vis[x]){
        return;
    }
    vis[x]=1;
    for (int i=0;i<a[x].size();i++){
        if (!vis[a[x][i]]){
            ret[a[x][i]]++;
            dfs(a[x][i]);
        }
    }
}
int main(){
    cin>>k>>n>>m;
    for (int i=1;i<=k;i++){
        int x;
        cin>>x;
        if (!b[x]){
            b[x]++;
            num++;
        }
    }
    for (int i=1;i<=m;i++){
        int c,d;
        cin>>c>>d;
        a[c].push_back(d);
    }
    for (int i=1;i<=n;i++){
        if (b[i]){
            ret[i]++;
        }
    }
    for (int i=1;i<=n;i++){
        if (b[i]){
            memset(vis,0,sizeof(vis));
            dfs(i);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i ++){
        if (ret[i]==num){
            ans++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

这个一眼就可以看出来是图论的题目，我们就用邻接表存图，好用，有口皆碑。

由于我们要尝试让每一个奶牛都走过那个结点，于是我们就可以用DFS来进行遍的历

关于邻接表的遍历与搜索无需多言

我们现在是要找到每个奶牛都可以到的地方，那么由于数据并不是非常大，我们可以用搜索，从每一个有奶牛的节点开始遍历，遍历到一个点，就把那个点的数据加上1，能被所有奶牛都去到的节点一定被遍历到的次数等于奶牛节点总数。

需要注意的是，不用在意每个节点有多少奶牛，这个是一个误导信息

同时要记得把每个初始奶牛节点都加上1，这很重要。不然你会测试样例都不过了的。

## 例题：

## P1330 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。

## 输入格式

第一行两个正整数，表示节点数和边数。
接下来 $m$ 行，每行两个整数 $u,v$，表示点 $u$ 到点 $v$ 之间有道路相连。

## 输出格式

仅一行如果河蟹无法封锁所有道路，则输出 `Impossible`，否则输出一个整数，表示最少需要多少只河蟹。

## 输入输出样例 #1

### 输入 #1

```
3 3
1 2
1 3
2 3
```

### 输出 #1

```
Impossible
```

## 输入输出样例 #2

### 输入 #2

```
3 2
1 2
2 3
```

### 输出 #2

```
1
```

## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 10010

int n, m;
vector<int> p[maxn];
int color[maxn]; // 替换novis，记录染色状态
bool valid = true; // 全局标记是否成功染色

void bfs(int u, int &cnt0, int &cnt1) {
    queue<int> q;
    q.push(u);
    color[u] = 0; // 初始染0
    cnt0++; // 计数增加

    while (!q.empty() && valid) {
        int uu = q.front();
        q.pop();
        for (int i = 0; i < p[uu].size(); i++) {
            int v = p[uu][i];
            if (color[v] == -1) { // 未访问节点
                color[v] = color[uu] ^ 1; // 染相反颜色
                if (color[v] == 0) cnt0++;
                else cnt1++;
                q.push(v);
            } else {
                if (color[v] == color[uu]) { // 相邻节点同色冲突
                    valid = false;
                    return;
                }
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        p[x].push_back(y);
        p[y].push_back(x);
    }

    // 初始化color为-1（未染色）
    memset(color, -1, sizeof(color));
    valid = true;
    int ans = 0; // 总河蟹数

    for (int i = 1; i <= n; i++) {
        if (color[i] == -1) {
            int cnt0 = 0, cnt1 = 0; // 当前连通分量染色计数
            bfs(i, cnt0, cnt1);
            if (!valid) break; // 发现冲突立即终止
            ans += min(cnt0, cnt1); // 取较小集合
        }
    }

    if (valid) cout << ans << endl;
    else cout << "Impossible" << endl;
    
    return 0;
}
```

### 思路：

先说，主播没学过二分图染色，然后这个题自己想了一个很抽象的方法，可能有点像二分图染色。

结果挂了6个点……

然后使用我们伟大的ai大人帮我修改了一下代码，并且瞻仰了一下二分图染色大法

> 根据题目要求，您的代码需要解决以下问题：用河蟹封锁所有道路（每条边至少有一个端点被封锁），且相邻节点不能同时有河蟹。这本质上是求图的最小顶点覆盖，同时满足独立集条件（相邻节点不同时被选）。通过分析，我们发现这等价于判断图是否为二分图，并在是二分图时取每个连通分量中较小染色集合的大小之和。
>
> 您的原始代码存在以下问题：
>
> 1. 使用`novis`标记访问时，错误地将整个连通分量都选中（违反相邻节点限制）
> 2. 边数统计错误（重复计算且与总边数`m`比较）
> 3. 未处理多个连通分量的情况
> 4. 算法逻辑不符合二分图染色原理
>
> 以下是修改后的代码，保留了您的变量命名风格，但重写了核心逻辑：
>
> ```
> #include <bits/stdc++.h>
> using namespace std;
> #define maxn 10010
> 
> int n, m;
> vector<int> p[maxn];
> int color[maxn]; // 替换novis，记录染色状态
> bool valid = true; // 全局标记是否成功染色
> 
> void bfs(int u, int &cnt0, int &cnt1) {
>     queue<int> q;
>     q.push(u);
>     color[u] = 0; // 初始染0
>     cnt0++; // 计数增加
> 
>     while (!q.empty() && valid) {
>         int uu = q.front();
>         q.pop();
>         for (int i = 0; i < p[uu].size(); i++) {
>             int v = p[uu][i];
>             if (color[v] == -1) { // 未访问节点
>                 color[v] = color[uu] ^ 1; // 染相反颜色
>                 if (color[v] == 0) cnt0++;
>                 else cnt1++;
>                 q.push(v);
>             } else {
>                 if (color[v] == color[uu]) { // 相邻节点同色冲突
>                     valid = false;
>                     return;
>                 }
>             }
>         }
>     }
> }
> 
> int main() {
>     cin >> n >> m;
>     for (int i = 1; i <= m; i++) {
>         int x, y;
>         cin >> x >> y;
>         p[x].push_back(y);
>         p[y].push_back(x);
>     }
> 
>     // 初始化color为-1（未染色）
>     memset(color, -1, sizeof(color));
>     valid = true;
>     int ans = 0; // 总河蟹数
> 
>     for (int i = 1; i <= n; i++) {
>         if (color[i] == -1) {
>             int cnt0 = 0, cnt1 = 0; // 当前连通分量染色计数
>             bfs(i, cnt0, cnt1);
>             if (!valid) break; // 发现冲突立即终止
>             ans += min(cnt0, cnt1); // 取较小集合
>         }
>     }
> 
>     if (valid) cout << ans << endl;
>     else cout << "Impossible" << endl;
>     
>     return 0;
> }
> ```
>
> ### 关键修改说明：
>
> 1. **算法重构**：
>    - 使用 **BFS进行二分图染色**（避免递归栈溢出）
>    - `color`数组：`-1`表示未访问，`0/1`表示两种颜色
>    - 每个连通分量统计两种颜色的节点数，取较小值累加
> 2. **变量调整**：
>    - 保留 `p`（邻接表）和全局变量风格
>    - 移除 `num`, `us`, `novis` 等无关变量
>    - 新增 `valid` 全局标志检测冲突
> 3. **正确性保障**：
>    - **冲突检测**：相邻节点同色时立即置 `valid=false` 并退出
>    - **边覆盖**：每条边连接两种颜色，较小集合即最小顶点覆盖
>    - **多连通分量**：独立处理每个分量，结果累加
> 4. **复杂度优化**：
>    - BFS保证 O(n+m) 时间复杂度
>    - 空间复杂度保持 O(n+m)
>
> 此实现已通过样例测试：
>
> - 样例1（三角形）：检测到奇环 → `Impossible`
> - 样例2（链式结构）：最小集合为1 → 输出`1`
>
> > **注意**：由于原题数据规模较大（n≤104），BFS避免了递归深度问题，确保运行效率。

关于什么时候用二分图染色，ai大人有话要说

> # 二分图染色适用题型详解
>
> 二分图染色是图论中的一种重要技术，主要用于解决以下类型的题目：
>
> ## 一、核心应用领域
>
> ### 1. **二分图判断类问题**
>
> - 判断一个图是否是二分图（二着色图）
>
> - 需要验证相邻节点能否成功染上不同颜色
>
> - 
>
>   经典题目
>
>   ：
>
>   - LeetCode 785：判断二分图
>   - LintCode 1031：图的二着色问题
>
> ### 2. **集合划分问题**
>
> - 将图中节点划分为两个集合，满足集合内无连边
>
> - 要求每个节点必须属于且仅属于一个集合
>
> - 
>
>   经典题目
>
>   ：
>
>   - LeetCode 886：可能的二分法
>   - 团队分配问题（不同导师的学生分组）
>
> ### 3. **冲突检测与解决**
>
> - 发现并解决节点间的冲突关系
>
> - 适合表达反对/敌对关系的场景
>
> - 
>
>   经典题目
>
>   ：
>
>   - 狼人杀身份推理
>   - 国际象棋棋盘问题
>
> ### 4. **双色覆盖问题**
>
> - 每条边至少有一个端点被选中
>
> - 相邻节点不能同时被选中
>
> - 
>
>   经典题目
>
>   ：
>
>   - P1330：河蟹封锁问题（你本次处理的题目）
>   - 最小顶点覆盖问题（二分图特殊解）
>
> ### 5. **奇环检测**
>
> - 判断图中是否存在长度为奇数的环
>
> - 奇环的存在等价于图不是二分图
>
> - 
>
>   经典题目
>
>   ：
>
>   - P1525：关押罪犯（最大矛盾值最小化）
>   - 代码逻辑环检测
>
> ## 二、识别特征（何时考虑使用二分图染色）
>
> 当题目出现以下关键词或特征时，应考虑二分图染色解法：
>
> 1. "划分两组"、"两种状态"、"对立关系"等表述
> 2. "相邻元素不能相同/不能共存"等约束条件
> 3. "冲突检测"、"矛盾关系"等场景
> 4. "覆盖所有边"且节点有约束
> 5. 数据结构明显是图或可转化为图
> 6. 节点间有明显的配对/反对称关系
>
> ## 三、算法特点
>
> 1. **时间复杂度**：O(V+E) - 高效解决方案
>
> 2. **空间复杂度**：O(V) - 只需存储节点颜色
>
> 3. 
>
>    算法思想
>
>    ：
>
>    - 初始节点染颜色A
>    - 所有邻居染颜色B
>    - 邻居的邻居再染颜色A
>    - 发现相邻同色则检测到冲突
>
> ## 四、不适用场景
>
> 1. 需要三种或更多颜色的复杂染色问题
> 2. 节点间关系不是简单的二元对立
> 3. 图中存在多维约束条件
> 4. 带权染色问题（需考虑权重影响）
>
> ## 五、扩展应用
>
> 1. **交叉应用领域**：
>    - 编译器设计（寄存器分配）
>    - PCB布线设计
>    - 时间表调度问题
> 2. **高级变形**：
>    - 多重染色（k种颜色）
>    - 带权染色（节点有染色权重）
>    - 概率染色（随机染色算法）
>
> > 二分图染色的核心在于利用图的**二着色性**解决**二元冲突问题**。掌握这项技术能高效解决一大类图论问题，尤其是涉及划分、冲突检测和边覆盖的题目。

## 例题：

## P1363 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 输入格式

输入包含多组数据。

每组数据的第一行是两个整数 $N,M$。

接下来是一个 $N\times M$ 的字符矩阵，表示迷宫里 $(0,0)$ 到 $(n-1,m-1)$ 这个矩阵单元。

## 输出格式

对于每组数据，输出一个字符串，`Yes` 或者 `No`。

## 输入输出样例 #1

### 输入 #1

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出 #1

```
Yes
No
```

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

### 题解：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAXN = 1500 + 1;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

int n, m;
int st_x, st_y;
int vis[MAXN][MAXN][3];
bool fl, a[MAXN][MAXN];
char ch;

void dfs(int x, int y, int lx, int ly) {
	if(fl) return;
	if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
		fl = 1;
		return;
	}
	vis[x][y][1] = lx, vis[x][y][2] = ly, vis[x][y][0] = 1;
	for(int i=0; i<4; ++i) {
		int xx = (x + dx[i] + n) % n, yy = (y + dy[i] + m) % m;
		int lxx = lx + dx[i], lyy = ly + dy[i];
		if(!a[xx][yy]) {
			if(vis[xx][yy][1]!=lxx || vis[xx][yy][2]!=lyy || !vis[xx][yy][0])
				dfs(xx, yy, lxx, lyy);
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	while(cin >> n >> m) {
		fl = 0;
		memset(a, 0, sizeof(a));
		memset(vis, 0, sizeof(vis));
		for(int i=0; i<n; ++i)
			for(int j=0; j<m; ++j) {
				cin >> ch;
				if(ch == '#') a[i][j] = 1;
				if(ch == 'S') st_x = i, st_y = j;
			}
		dfs(st_x, st_y, st_x, st_y);
		if(fl) puts("Yes");
		else puts("No");
	}
}
```

### 思路：

我没想出来，刚刚开始我以为就是一个很普通的走迷宫问题，我BFS的表都打好了，后面发现不对，这怎么是无穷的。

贴一下大佬思路吧

> #### 下面是正解：
>
> 所以不能拓展迷宫而对坐标取模就好了.
>
> 如果走到过某个点现在又走到了这个点，那显然是可以走无限远的。
>
> 现在出现了一些~~（堆）~~问题：
>
> 如何判断是否走到过这个点呢？
>
> 有一个比较巧妙的方法：
>
> 记录取模的横纵坐标x, y时，同时记录没有取模的坐标lx, ly
>
> 当第一次走这个迷宫的时候，x, y和lx, ly肯定是分别相等的
>
> 所以只要走到的一个点的x, y和lx, ly不相等（x\\\=lx ∣∣ y\\\=ly），那这个点一定是被走了第二遍.

## 例题：

## P1347 排序

## 题目描述

一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 $A,B,C,D$ 表示 $A<B,B<C,C<D$。在这道题中，我们将给你一系列形如 $A<B$ 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。

## 输入格式

第一行有两个正整数 $n,m$，$n$ 表示需要排序的元素数量，$2\leq n\leq 26$，第 $1$ 到 $n$ 个元素将用大写的 $A,B,C,D,\dots$ 表示。$m$ 表示将给出的形如 $A<B$ 的关系的数量。

接下来有 $m$ 行，每行有 $3$ 个字符，分别为一个大写字母，一个 `<` 符号，一个大写字母，表示两个元素之间的关系。

## 输出格式

若根据前 $x$ 个关系即可确定这 $n$ 个元素的顺序 `yyy..y`（如 `ABC`），输出

`Sorted sequence determined after x relations: yyy...y.`

其中 $x$ 表示上述的前 $x$ 个关系。

若根据前 $x$ 个关系即发现存在矛盾（如 $A<B,B<C,C<A$），输出

`Inconsistency found after x relations.`

其中 $x$ 表示的意义同上。

若根据这 $m$ 个关系无法确定这 $n$ 个元素的顺序，输出

`Sorted sequence cannot be determined.`

（提示：确定 $n$ 个元素的顺序后即可结束程序，可以不用考虑确定顺序之后出现矛盾的情况）

## 输入输出样例 #1

### 输入 #1

```
4 6
A<B
A<C
B<C
C<D
B<D
A<B
```

### 输出 #1

```
Sorted sequence determined after 4 relations: ABCD.
```

## 输入输出样例 #2

### 输入 #2

```
3 2
A<B
B<A
```

### 输出 #2

```
Inconsistency found after 2 relations.
```

## 输入输出样例 #3

### 输入 #3

```
26 1
A<Z
```

### 输出 #3

```
Sorted sequence cannot be determined.
```

## 说明/提示

$2 \leq n \leq 26,1 \leq m \leq 600$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30;
int n,m,path[N];//记录前驱
vector<int> G[N];
bool g[N][N];//保证没有重边的干扰
  
void dfs(int v)//输出序列
{
	if(path[v]) dfs(path[v]);
	cout<<char('A'+v-1);
}
  
void bfs(int k)//正经最长路，k就是目前知道的关系
{
	queue<int> p;
	int dis[N]={0};
	dis[0]=1;
	p.push(0);
	while (!p.empty())
	{
		int u=p.front();
			p.pop();
		for(int i=0;i<G[u].size();i++)
		{
			int v=G[u][i];
			if(dis[v]<dis[u]+1)
			{
				path[n+1]=v;
				path[v]=u;
				dis[v]=dis[u]+1;
				p.push(v);
			}
			if(dis[v]>n+2)//发现矛盾直接打断程序
			{
				printf("Inconsistency found after %d relations.",k);
				exit(0);//终止一切	
			}
		}
	}
	if(k==m&&dis[n+1]!=n+2) //到最后还是不行
		cout<<"Sorted sequence cannot be determined.";
	if(dis[n+1]==n+2)//口以啦
	{
		printf("Sorted sequence determined after %d relations: ",k);
		dfs(path[n+1]);
		cout<<".";
		exit(0);
	}	
}
  
int main()
{
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++)//建立每个点和超级点的联系
	{
		G[0].push_back(i);
		G[i].push_back(n+1);
	}	
	
	for(int i=1;i<=m;i++)
	{
		char a,b,c;
		cin>>a>>b>>c;
		//getchar();
		if(!g[a-'A'+1][c-'A'+1])
		{
			G[a-'A'+1].push_back(c-'A'+1);
			g[a-'A'+1][c-'A'+1]=1;
		}
		
		bfs(i);
	}
}
```

### 思路：

我写了两个小时，最后卡在了如何判断是矛盾还是条件不足上

真写不出来了，哈气了。

直接贴大佬题解吧，我不想再写图论了。

> # **最长路做法**
>
> ~毕竟……数据量小的可怜……~
>
> ## 通过题意易得：
>
> ### 如果要确定一个序列，那么一定得从头到尾有个n个点构成的路径，也就是说通过一条单向道路走到底刚好能走遍全部n个点
>
> #### 那么这时候我们要通过什么来确定他的起点呢？当然有同学说可以统计入度的方法，这边呢我用了个超级原点和超级终点，香啊！
>
> ### 那么这时候我们要是能走出一个以超级原点到超级终点不带重复点的路径——就成咯！
>
> #### 但是万一有环怎么办（样例2），万一走不到怎么办（样例3）
>
> #### 这时候最长路就出来露脸了，~所以说别把图论学死了~\*\*
>
> ### 我们通过一遍输入关系一遍统计统计超级原点到超级终点的最长路（点权都设1）：
>
> ```
> 1. 如果能走出来长度为n+2的最长路，证明使用目前为止给的k条关系（边）就能得到所有点的完整序列
> 2. 如果在统计最长路时路径长度已经超过了n+2，那么肯定是到目前给的关系（边）中一定有环路的存在（想不明白？细品！一个完整序列怎么可能有重复的点？）
> 3. 如果关系输入到最后，发现根本走不到终点，那么就证明无法得出整张序列
> ```
>
> ### 这样可发现，我们不仅解决了三种情况，而且刚好符合题目的意思（如果无法排列但是给的条件中有矛盾也会当做矛盾处理）一旦找到情况（情况三要等到最后输入完关系才能证明）就能直接结束程序！