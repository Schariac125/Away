# 数据结构：集合

## 并查集：数据结构笑传之查查并

我现在可以给出一个通用的，好理解的，而且不容易爆栈的模板：

```cpp
int find(int x){
if(f[x]==x) return x;
    else
    {
        f[x]=find(f[x]);
        return f[x];
    }
}//查

void hb(int x,int y){
    int fx = find(x), fy = find(y);
	if (fx != fy) {
		f[fx] = fy;//或者f[fy]=fx 区别在于你要让谁被合成进去
	}
}//并
```

## 例题：

## P1551 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 输入格式

第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。

以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le n$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。

接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。

## 输出格式

$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。

## 输入输出样例 #1

### 输入 #1

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```

### 输出 #1

```
Yes
Yes
No
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[10005],n,m,p;
int find(int x){
    if (f[x]==x) return x;
    else return f[x]=find(f[x]);
}
void hb(int x,int y){
    f[find(y)]=find(x);
    return;
}
int main(){
    cin>>n>>m>>p;
    for (int i=1;i<=n;i++) f[i]=i;
    for (int i=1;i<=m;i++){
        int a1,b1;
        cin>>a1>>b1;
        hb(a1,b1);
    }
    for (int i=1;i<=p;i++){
        int a2,b2;
        cin>>a2>>b2;
        if (find(a2)==find(b2)){
            cout<<"Yes"<<endl;
        }else{
            cout<<"No"<<endl;
        }
    }
    return 0;
}
```

## 例题：

## P1536 村村通

## 题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

## 输入格式

输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。

注意：两个城市间可以有多条道路相通。

**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**

## 输出格式

对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。

## 输入输出样例 #1

### 输入 #1

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

### 输出 #1

```
1
0
2
998
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[10005],n,m;
int find(int x){
    if (f[x]==x) return x;
    else return f[x]=find(f[x]);
}

void hb(int x,int y){
    f[find(y)]=find(x);
    return;
}


int main(){
    while (1){
        cin>>n>>m;
        int ans=0;
        if (n==0) break;
        for (int i=1;i<=n;i++){
            f[i]=i;
        }
        for (int i=1;i<=m;i++){
            int a1,b1;
            cin>>a1>>b1;
            hb(a1,b1);
        }
        for (int i=1;i<=n;i++){
            if (find(i)==i){
                ans++;
            }
        }
        cout<<ans-1<<endl;
    }
    return 0;
}
```

### 思路：

并查集我目前做了两题就是感觉特别公式，公公又式式

首先就是递归写一个查找函数，然后再写一个合并函数，就结束了，详细可以见洛谷那本书。

```cpp
int f[10005],n,m;
int find(int x){
    if (f[x]==x) return x;
    else return f[x]=find(f[x]);
}

void hb(int x,int y){
    f[find(y)]=find(x);
    return;
}//需要注意的是，这个写法很容易爆栈，真的
```

## 哈希表：

## 例题：

## P3370 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。


**友情提醒：如果真的想好好练习哈希的话，请自觉。**

## 输入格式

第一行包含一个整数 $N$，为字符串的个数。

接下来 $N$ 行每行包含一个字符串，为所提供的字符串。

## 输出格式

输出包含一行，包含一个整数，为不同的字符串个数。

## 输入输出样例 #1

### 输入 #1

```
5
abc
aaaa
abc
abcc
12345
```

### 输出 #1

```
4
```

## 说明/提示

### 数据范围

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$M_{\max}\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$M_{\max}\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$M_{\max}\leq 1500$。

### 样例说明

样例中第一个字符串 $\tt{abc}$ 和第三个字符串 $\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\{\tt{aaaa},\tt{abc},\tt{abcc},\tt{12345}\}$，故共计 $4$ 个不同的字符串。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,ans=0;
set<string> ha;
string a;

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>a;
        ha.insert(a);
    }
    cout<<ha.size()<<endl;
    return 0;
}
```

```cpp
#include <iostream>//字符串哈希写法
#include <vector>
#include <iomanip>
#define MAXN 1510
#define base 261//base只需要大于128即可
#define mod 23333 //一般而言这个数是10007或者999983

using namespace std;

int n, ans = 0;
char s[MAXN];
vector<string> linker[mod]; 

inline void insert() {
    int hash_val = 0; // 修复1
    for (int i = 0; s[i]; i++) {
        hash_val = (hash_val * base + s[i]) % mod;//这个是哈希值的计算公式。
    }
    string t = s;
    bool exists = false;
    for (const auto& str : linker[hash_val]) {
        if (str == t) {
            exists = true;
            break;
        }
    }
    if (!exists) {
        linker[hash_val].push_back(t);
        ans++;
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> setw(MAXN) >> s; 
        insert();
    }
    cout << ans << endl;
    return 0;
}
```

### 思路：

我说set太好用了有没有懂的

关于字符串哈希可以详细看看洛谷那本书里讲的。

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：集合.assets\6d3df432a722a74038ad8292e74cfe8d.png)

## 例题：

## P3405 [USACO16DEC] Cities and States S

## 题目描述

Farmer John 有若干头奶牛。为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。地图上表明了每个城市及其所在州的代码（前两位大写字母）。

由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，FLINT 的前两个字母就是 MIAMI 所在的 `FL` 州，MIAMI 的前两个字母则是 FLINT 所在的 `MI` 州。  
确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。

我们称两个城市是一个一对「特殊」的城市，如果他们具有上面的特性，并且来自不同的州。对于总共 $N$ 座城市，奶牛想知道有多少对「特殊」的城市存在。请帮助他们解决这个有趣的地理难题！

## 输入格式

输入共 $N + 1$ 行。

第一行一个正整数 $N$，表示地图上的城市的个数。  
接下来 $N$ 行，每行两个字符串，分别表示一个城市的名称（$2 \sim 10$ 个大写字母）和所在州的代码（$2$ 个大写字母）。同一个州内不会有两个同名的城市。

## 输出格式

输出共一行一个整数，代表特殊的城市对数。

## 输入输出样例 #1

### 输入 #1

```
6
MIAMI FL
DALLAS TX
FLINT MI
CLEMSON SC
BOSTON MA
ORLANDO FL
```

### 输出 #1

```
1
```

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10 ^ 5$，城市名称长度不超过 $10$。

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int city[676][676], n, x, y, ans;//x表示城市前两个字母的26进制下的数，y是省份的。数相等则对应的省的两个字母和城市的前两个字母就相等。
int main() {
    string a, b;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a>>b;
        x = (a[0] - 'A') * 26 + a[1] - 'A';//不减的话数据太大，数组开不了那么大（map的优势） 
        y = (b[0] - 'A') * 26 + b[1] - 'A';
        if (x != y) {//x==y的话如果要配对的话只会配到自己省。题目说了不在同一省，所以要排除。
            city[x][y]++;
            ans += city[y][x];
        }
    }
    cout<<ans;
    return 0;
}

```

### 思路：

我说map真乃哈希表神器也

## 例题：学哈希表不看这题等于白学(出自力扣第一题)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

-   `2 <= nums.length <= 10<sup>4</sup>`
-   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
-   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`
-   **只会存在一个有效答案**

### 题解：

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hashmap;
        int n=nums.size();
        for (int i=0;i<n;i++){
            auto ans=hashmap.find(target-nums[i]);
            if (ans!=hashmap.end()){
                return {ans->second,i};
            }
            hashmap[nums[i]]=i;
        }
        return {};
    }
};
```

## 集合及其应用：

## 例题：

## P5250 【深基17.例5】木材仓库

## 题目描述

博艾市有一个木材仓库，里面可以存储各种长度的木材，但是保证没有两个木材的长度是相同的。作为仓库负责人，你有时候会进货，有时候会出货，因此需要维护这个库存。有不超过 $10^5$ 条的操作：

- 进货，格式 `1 Length`：在仓库中放入一根长度为 $Length$（不超过 $10^9$）的木材。如果已经有相同长度的木材那么输出 `Already Exist`。
- 出货，格式 `2 Length`：从仓库中取出长度为 $Length$ 的木材。如果没有刚好长度的木材，取出仓库中存在的和要求长度最接近的木材。如果有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的，输出 `Empty`。

## 输入格式

第一行一个数 $m$ 代表操作次数。

接下来 $m$ 行，每行一次操作，格式如题目描述所示。

## 输出格式

对于每次操作，按照题目描述要求输出答案。

## 输入输出样例 #1

### 输入 #1

```
7
1 1
1 5
1 3
2 3
2 3
2 3
2 3
```

### 输出 #1

```
3
1
5
Empty
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
set<int> r;
int m, x, l1, l2;

int main() {
    cin >> m;
    for (int i = 1; i <= m; i++) {
        cin >> x;
        if (x == 1) {
            cin >> l1;
            if (r.count(l1)) {
                cout << "Already Exist" << endl;
            } else {
                r.insert(l1);
            }
        } else if (x == 2) {
            cin >> l2;
            if (r.empty()) {
                cout << "Empty" << endl;
            } else if (r.count(l2)) {
                cout << l2 << endl;
                r.erase(l2);
            } else {
                // 处理寻找最近木材的逻辑
                auto it = r.lower_bound(l2);
                // 情况1：l2超过最大值（取最后一个元素）
                if (it == r.end()) {
                    auto last = prev(it);
                    cout << *last << endl;
                    r.erase(last);
                } 
                // 情况2：l2小于最小值（取第一个元素）
                else if (it == r.begin()) {
                    cout << *it << endl;
                    r.erase(it);
                } 
                // 情况3：l2在中间位置
                else {
                    auto prev_it = prev(it);//prev相当于it--
                    int diff_prev = l2 - *prev_it;
                    int diff_next = *it - l2;
                    
                    // 选择距离更近的（距离相等时取较小的）
                    if (diff_prev > diff_next) {
                        cout << *it << endl;
                        r.erase(it);
                    } else {
                        cout << *prev_it << endl;
                        r.erase(prev_it);
                    }
                }
            }
        }
    }
    return 0;
}
```

### 思路：

集合应用模板题。

## 例题：map应用模板题

## P5266 【深基17.例6】学籍管理

## 题目描述

您要设计一个学籍管理系统，最开始学籍数据是空的，然后该系统能够支持下面的操作（不超过 $10^5$ 条）：

- 插入与修改，格式`1 NAME SCORE`：在系统中插入姓名为 NAME(由字母和数字组成不超过 20 个字符的字符串，区分大小写) ，分数为 $\texttt{SCORE}$（$0<\texttt{SCORE}<2^{31}$） 的学生。如果已经有同名的学生则更新这名学生的成绩为 SCORE。如果成功插入或者修改则输出`OK`。
- 查询，格式`2 NAME`：在系统中查询姓名为 NAME 的学生的成绩。如果没能找到这名学生则输出`Not found`，否则输出该生成绩。
- 删除，格式`3 NAME`：在系统中删除姓名为 NAME 的学生信息。如果没能找到这名学生则输出`Not found`，否则输出`Deleted successfully`。
- 汇总，格式`4`：输出系统中学生数量。

## 输入格式

无

## 输出格式

无

## 输入输出样例 #1

### 输入 #1

```
5
1 lxl 10
2 lxl
3 lxl
2 lxl
4
```

### 输出 #1

```
OK
10
Deleted successfully
Not found
0
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

map<string,int> add;
int n,m,l;
string b;
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>m;
        if (m==1){
            cin>>b>>l;
            add[b]=l;
            cout<<"OK"<<endl;
        }
        else if(m==2){
            cin>>b;
            auto r2=add.find(b);
            if (r2!=add.end()){
                cout<<add[b]<<endl;
            }else{
                cout<<"Not found"<<endl;
            }
        }
        else if(m==3){
            cin>>b;
            auto r3=add.find(b);
            if (r3!=add.end()){
                add.erase(r3);
                cout<<"Deleted successfully"<<endl;
            }else{
                cout<<"Not found"<<endl;
            }
        }
        else if (m==4){
            cout<<add.size()<<endl;
        }
    }
    return 0;
}
```

### 思路：

如果遇到了一些有多个元素的，可以尝试用map求解。

## 例题：

## P1918 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1. $\bigcirc \bigcirc \bigcirc$

2. $\bigcirc \bigcirc \bigcirc\ \bigcirc$

3. $\bigcirc$

4. $\bigcirc\ \bigcirc$

如上图，每个 “$\bigcirc$” 代表一个瓶子。如果 DL 想要打倒 $3$ 个瓶子就在 $1$ 位置发球，想要打倒 $4$ 个瓶子就在 $2$ 位置发球。

现在他想要打倒 $m$ 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 输入格式

第一行包含一个正整数 $n$，表示位置数。

第二行包含 $n$ 个正整数 $a_i$ ，表示第 $i$ 个位置的瓶子数，保证各个位置的瓶子数不同。

第三行包含一个正整数 $Q$，表示 DL 发球的次数。

第四行至文件末尾，每行包含一个正整数 $m$，表示 DL 需要打倒 $m$ 个瓶子。

## 输出格式

共 $Q$ 行。每行包含一个整数，第 $i$ 行的整数表示 DL 第 $i$ 次的发球位置。若无解，则输出 $0$。

## 输入输出样例 #1

### 输入 #1

```
5
1 2 4 3 5
2
4
7
```

### 输出 #1

```
3
0
```

## 说明/提示

【数据范围】

对于 $50\%$ 的数据，$1 \leq n, Q \leq 1000, 1 \leq a_i, m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,Q \leq 100000, 1 \leq a_i, m \leq 10^9$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,q,x;
map<int,int> ball;

int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>x;
        ball[x]=i;
    }
    cin>>q;
    for (int i=1;i<=q;i++){
        cin>>x;
        auto p=ball.find(x);
        if (p!=ball.end()){
            cout<<ball[x]<<endl;
        }else{
            cout<<0<<endl;
        }
    }
    return 0;
}
```

## 例题：

## P1525 [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？

## 输入格式

每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1\le a_j< b_j\leq N, 0 < c_j\leq 10^9$，且每对罪犯组合只出现一次。

## 输出格式

共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 `0`。

## 输入输出样例 #1

### 输入 #1

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884
```

### 输出 #1

```
3512
```

## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：集合.assets\uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

class man{
    public:
    int x,y,v;
};
int n,m;
int f[40005];
man a[100005];
bool cmp(man a,man b){
    return a.v>b.v;
}
int find(int x){
    if (f[x]==x) return x;
    else return f[x]=find(f[x]);
}

void hb(int x,int y){
    int fx = find(x), fy = find(y);
	if (fx != fy) {
		f[fy] = fx;
	}
}//这个地方我爆了一次栈，无语死了
int main(){
    cin>>n>>m;
    for (int i=1;i<=m;i++){
        cin>>a[i].x>>a[i].y>>a[i].v;
    }
    sort(a+1,a+1+m,cmp);
    for (int i=1;i<=2*n;i++){
        f[i]=i;
    }
    for (int i=1;i<=m;i++){
        if (find(a[i].x)==find(a[i].y)){
            cout<<a[i].v<<endl;
            return 0;
        }
        hb(a[i].x+n,a[i].y);
        hb(a[i].x,a[i].y+n);
    }
    cout<<0;
    return 0;
}

```

### 思路：

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：集合.assets\8e678ebbae403de218db5ecaa2e15fee.png)

如果不看题解我说白了

我也不会做。这个假想敌有点太难想了哥们。

不过这题其实说明了一件事，并查集真的很模板（）

## 例题：

## P1621 集合

## 题目描述

Caima 给你了所有 $[a,b]$ 范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 $p$ 的公共质因数，那么把它们所在的集合合并。

重复如上操作，直到没有可以合并的集合为止。

现在 Caima 想知道，最后有多少个集合。

## 输入格式

一行，共三个整数 $a,b,p$，用空格隔开。

## 输出格式

一个数，表示最终集合的个数。

## 输入输出样例 #1

### 输入 #1

```
10 20 3
```

### 输出 #1

```
7
```

## 说明/提示

#### 样例 1 解释

对于样例给定的数据，最后有 $\{10,20,12,15,18\},\{13\},\{14\},\{16\},\{17\},\{19\},\{11\}$ 共 $7$ 个集合，所以输出应该为 $7$。

#### 数据规模与约定
- 对于 $80\%$ 的数据，$1 \leq a \leq b \leq 10^3$。
- 对于 $100%$ 的数据，$1 \leq a \leq b \leq 10^5,2 \leq p \leq b$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int f[100005],a,b,q,vis[100005];
int find(int x){
    if(f[x]==x) return x;
    else
    {
        f[x]=find(f[x]);
        return f[x];
    }
}
void hb(int x,int y){
    int fx=find(x);
    int fy=find(y);
    if (fx!=fy){
        f[fy]=fx;
    }
    return;
}
bool isprime(int x){
    if (x==1) return 0;
    else if (x==2) return 1;
    else{
        for (int i=2;i*i<=x;i++){
            if (x%i==0) return 0;
        }
    }
    return 1;
}
int main(){
    cin>>a>>b>>q;
    for (int i=a;i<=b;i++){
        f[i]=i;
    }
    int ans=0,cnt=0;//下面的部分是一种叫做欧拉筛法的东西，很神秘
    for (int i=q;i<=b;i++){
        if (isprime(i)) vis[++cnt]=i;
    }
    for (int i=1;i<=cnt;i++){
        int cc=0;
        while (cc*vis[i]<a) cc++;
        while (vis[i]*(cc+1)<=b){
            hb(vis[i]*cc,vis[i]*(cc+1));
            cc++;
        }
    }
    for (int i=a;i<=b;i++){
        if (f[i]==i) ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

又要查又要合并，一看就是要用并查集去维护啊

但这题最神必的地方不在于这个并查集，而在于那个最关键的欧拉筛法。不会那个即使知道要用并查集也没用

### 欧拉筛法（线性筛法）

欧拉筛法是一种**线性时间复杂度的素数筛法**，能在 O(n) 的时间复杂度内筛选出 [1, n] 范围内的所有素数。它是比传统埃拉托斯特尼筛法（埃氏筛）更高效的算法。

#### 核心思想

1. **每个合数只被标记一次**
2. **用最小质因子筛选合数**
3. **及时中断冗余标记**

#### 算法流程

```c++
vector<int> eulerSieve(int n) {
    vector<bool> isPrime(n+1, true); // 标记数组
    vector<int> primes;              // 素数容器
    isPrime[0] = isPrime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i); // i是素数，加入列表
        }
        
        // 用已知素数标记合数
        for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            isPrime[i * primes[j]] = false;
            // 关键中断：当i能被当前素数整除时终止
            if (i % primes[j] == 0) break;
        }
    }
    return primes;
}
```

#### 关键机制图解

```c++
graph TD
    A[开始循环i=2->n] --> B{i为素数?}
    B -->|是| C[加入素数列表]
    B -->|否| D[继续]
    C --> D
    D[对每个素数p_j] --> E{计算 i×p_j ≤ n?}
    E -->|是| F[标记i×p_j为合数]
    E -->|否| G[结束内循环]
    F --> H{i能被p_j整除?}
    H -->|是| I[终止内循环]
    H -->|否| D
```

#### 算法特点

1. **时间复杂度 O(n)**

   - 每个合数只被标记一次
   - 每个素数只被访问一次

2. **关键中断机制**

   ```c++
   if (i % primes[j] == 0) break;
   ```

   - 保证每个合数只被**最小质因子**筛除
   - 避免重复标记（如12只会被3 * 4筛除，不会被2 * 6筛除）

3. **效率对比**

   | 筛法   | 时间复杂度    | 是否线性 |
   | ------ | ------------- | -------- |
   | 埃氏筛 | O(n log logn) | ×        |
   | 欧拉筛 | O(n)          | √        |

#### 应用场景

1. 需要高效获取大范围素数
2. 需要素数表进行因数分解
3. 数论问题中的预处理
4. 算法竞赛中处理 ≤10⁷ 级别的素数筛选

> **为什么是最小质因子？**
>  当 `i % primes[j] == 0` 时：
>
> - 说明 `primes[j]` 是 `i` 的最小质因子
> - 那么 `i×primes[j+k]` 的最小质因子也是 `primes[j]`（不是 `primes[j+k]`）
> - 中断保证这些数后续会被 `primes[j]` 筛除
>
> 例如：当 i=4 时：
>
> - 标记 4×2 = 8 后中断
> - 不会标记 4×3 = 12（因为12的最小质因子是2）
> - 12会在 i=6 (6×2) 时被标记

欧拉筛法通过最小质因子的精妙控制，实现了线性的筛选效率，是素数处理领域的重要算法突破。

在这一题的应用主要体现在

**1.看到集合这个定义，我们瞬间会想到用并查集来维护这个集合，那么对于这个集合，他满足一个性质，就是如果我们，起始的时候初始化每一个数的父亲都是自己，那么每一个集合中有且只有一个数的父亲是自己。根据这个性质，我们明确了求解答案的条件，就是将所有有大于等于P的质因数的一堆数合并起来，统计父亲是自己的个数。**

**2.那么我们如何将有同样大于等于P的质因数找出来呢，我们选择通过中转的方式来进行，即如果我们找到1个大于等于P的质因数是这个数的因数，那么我们把这两个数放在一个集合中，最终与这个数有同样质因数的数也会在这个集合中。**

**3.那么我们应该如何找这些质因数呢，我们自然而然的想到通过筛法进行预处理，这次我们采用的是欧拉筛法，时间复杂度为O(N）。**

### 例题：

## P1892 [BalticOI 2003] 团伙

## 题目描述

现在有 $n$ 个人，他们之间有两种关系：朋友和敌人。我们知道：

- 一个人的朋友的朋友是朋友
- 一个人的敌人的敌人是朋友

现在要对这些人进行组团。两个人在一个团体内当且仅当这两个人是朋友。请求出这些人中最多可能有的团体数。

## 输入格式

第一行输入一个整数 $n$ 代表人数。

第二行输入一个整数 $m$ 表示接下来要列出 $m$ 个关系。

接下来 $m$ 行，每行一个字符 $opt$ 和两个整数 $p,q$，分别代表关系（朋友或敌人），有关系的两个人之中的第一个人和第二个人。其中 $opt$ 有两种可能：

- 如果 $opt$ 为 `F`，则表明 $p$ 和 $q$ 是朋友。
- 如果 $opt$ 为 `E`，则表明 $p$ 和 $q$ 是敌人。

## 输出格式

一行一个整数代表最多的团体数。

## 输入输出样例 #1

### 输入 #1

```
6
4
E 1 4
F 3 5
F 4 6
E 1 2
```

### 输出 #1

```
3
```

## 说明/提示

对于 $100\%$ 的数据，$2 \le n \le 1000$，$1 \le m \le 5000$，$1 \le p,q \le n$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

class man{
    public:
    char g;
    int x,y;
};
man a[5050];
int f[10100],n,m;
int find(int x){
    if (f[x]==x) return x;
    else{
        f[x]=find(f[x]);
        return f[x];
    }
}
void hb(int x,int y){
    int fx=find(x);
    int fy=find(y);
    if (fx!=fy){
        f[fx]=fy;
    }
    return;
}
int main(){
    cin>>n>>m;
    int ans=0;
    for (int i=1;i<=2*n;i++){
        f[i]=i;
    }
    for (int i=1;i<=m;i++){
        cin>>a[i].g>>a[i].x>>a[i].y;
        if (a[i].g=='F'){
            hb(a[i].x,a[i].y);
        }else{
            hb(a[i].x+n,a[i].y);
            hb(a[i].y+n,a[i].x);
        }
    }
    for (int i=1;i<=n;i++){
        if (f[i]==i) ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```

还可以这么写，区别只在于合并部分，下面那个可能还更好写吧

```cpp
#include <bits/stdc++.h>
using namespace std;

class man {
public:
    char g;
    int x, y;
};
man a[5050];
int f[10100], n, m;

int find(int x) {
    if (f[x] != x) f[x] = find(f[x]);
    return f[x];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= 2 * n; i++) {
        f[i] = i;
    }

    for (int i = 1; i <= m; i++) {
        cin >> a[i].g >> a[i].x >> a[i].y;
        if (a[i].g == 'F') {
            f[find(a[i].x)] = find(a[i].y);//区别在这里
        } else {
            f[find(a[i].x + n)] = find(a[i].y);
            f[find(a[i].y + n)] = find(a[i].x);
        }
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (find(i) == i) ans++;
    }
    cout << ans << "\n";

    return 0;
}

```

### 总结：

这题和上面那题囚犯很像，思路我贴一个大佬的吧

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：集合.assets\44b2df29d43ea6978ed0f71ee7243ddf.png)

需要注意一下合并的部分，那个地方很重要，是把反集合到原集里面，不是原集合反集。

糖麻了，测试样例一直没过后来才发现是这里的问题。

## 例题：

## P1955 [NOI2015] 程序自动分析

## 题目描述

在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如 $x_i=x_j$ 或 $x_i\neq x_j$ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

## 输入格式

输入的第一行包含一个正整数 $t$，表示需要判定的问题个数。注意这些问题之间是相互独立的。

对于每个问题，包含若干行：

第一行包含一个正整数 $n$，表示该问题中需要被满足的约束条件个数。接下来 $n$ 行，每行包括三个整数 $i,j,e$，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $e=1$，则该约束条件为 $x_i=x_j$。若$e=0$，则该约束条件为 $x_i\neq x_j$。

## 输出格式

输出包括 $t$ 行。

输出文件的第 $k$ 行输出一个字符串 `YES` 或者 `NO`（字母全部大写），`YES` 表示输入中的第 $k$ 个问题判定为可以被满足，`NO` 表示不可被满足。

## 输入输出样例 #1

### 输入 #1

```
2
2
1 2 1
1 2 0
2
1 2 1
2 1 1
```

### 输出 #1

```
NO
YES
```

## 输入输出样例 #2

### 输入 #2

```
2
3
1 2 1
2 3 1
3 1 1
4
1 2 1
2 3 1
3 4 1
1 4 0
```

### 输出 #2

```
YES
NO
```

## 说明/提示

【样例解释1】

在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。

在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。

【样例说明2】

在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得 $x_1=x_2=x_3$，即可同时满足所有的约束条件。

在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出 $x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。

【数据范围】

所有测试数据的范围和特点如下表所示：

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：集合.assets\6f34qrmu.png)

### 题解：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <cstdlib>
using namespace std;
int t,n,f[1000007],book[1000007*3];  //t表示t组数据，n表示有n个操作，f[]是我们并查集的数字，book[]是离散化的数组 
struct node{
    int x,y,e;
}a[1000001];  
bool cmp(node a,node b){
    return a.e>b.e;
}//排 序将e==1的放在前面 
inline void first(int kkk){
    for(int i=1;i<=kkk;i++)  f[i]=i;
}//初 始 化 
int get(int x){
    if(x==f[x]) return x;
    return f[x]=get(f[x]);
}
int main(){
    scanf("%d",&t);
    while(t--){
      int tot=-1;
      memset(book,0,sizeof(book));
      memset(a,0,sizeof(a));
      memset(f,0,sizeof(f));
    int flag=1;
        scanf("%d",&n);
       
        for(int i=1;i<=n;i++){
            scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].e);
            book[++tot]=a[i].x;
            book[++tot]=a[i].y;
        }
        sort(book,book+tot);//排序 
        int reu=unique(book,book+tot)-book;  //去重 
        for(int i=1;i<=n;++i){
           a[i].x=lower_bound(book,book+reu,a[i].x)-book;
           a[i].y=lower_bound(book,book+reu,a[i].y)-book;   
        } 
        first(reu);   //初始化 
        sort(a+1,a+n+1,cmp);  //按e排序 
        for(int i=1;i<=n;i++){
            int r1=get(a[i].x);
            int r2=get(a[i].y);
            if(a[i].e){
                f[r1]=r2;  //就是我们的merge操作 
            }else if(r1==r2){
                printf("NO\n");
                flag=0;  //如果不满足条件，标记为否 
                break;
            }
        }
        if(flag)    printf("YES\n");   //都满足条件了 
    }
    return 0;
}
```

### 思路：

我发现现在并查集的题目越来越奇怪了

重点从来不在并查集这里，在其他一些奇奇怪怪的地方，例如最前面那题的欧拉筛，这一题的重点在于离散化，不爆炸。

总的来说就是先对每一个关系进行排序，1在前，0在后

先对e=1的情况进行处理，把两个对应关系放在同一个集合里面去，在处理为0的时候时，如果发现这两个数在同一个集合里面，那么直接输出不行。

思路就是这么简单。

然后我们来看看什么是离散化。

**离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。这是百度百科上的定义。那么举个栗子，某个题目告诉你有1e5个数，每个数大小不超过1e9，要你对这些数进行操作（比如并查集之类的）。那么肯定不能直接开1e9大小的数组，但是1e5的范围就完全没问题。在举个栗子，现在对{4,7,6,9}进行离散化，那么得到的结果是{1,3,2,4}，也就是说，当我们并不需要这些数据具体是多少时，就只需要知道他们的相对大小就行了。**

```cpp
const int N=1e5+7;
int t[N],a[N];
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++)
    cin>>a[i],t[i]=a[i];
  sort(t+1,t+n+1);
  m=unique(t+1,t+n+1)-t-1;
  for(int i=1;i<=n;i++)
    a[i]=lower_bound(t+1,t+m+1,a[i])-t;
}
```

感觉就是找到数组最小减一，然后比较每个数

## 例题：

## P4305 [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 输入格式

**本题有多组数据。**

第一行一个整数 $T$，表示数据组数。

对于每组数据：

第一行一个整数 $n$。

第二行 $n$ 个数，表示给定的数。

## 输出格式

对于每组数据，输出一行，为去重后剩下的数，两个数之间用一个空格隔开。

## 输入输出样例 #1

### 输入 #1

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出 #1

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int t,n,b;
vector<int> a;
int main(){
    cin>>t;
    for (int i=1;i<=t;i++){
        cin>>n;
        unordered_map<int,int> hash1;
        for (int j=1;j<=n;j++){
            cin>>b;
            auto p=hash1[b];
            if (p==0){
                a.push_back(b);
            }else{
                continue;
            }
            hash1[b]++;
        }
        for (int k=0;k<a.size();k++){
            cout<<a[k]<<" ";
        }
        cout<<endl;
        a.clear();
        hash1.clear();
    }
    return 0;
}
```

### 思路：

我第一反应，哈希表没跑了

然后我尝试使用set，结果挂掉了两个测试点大败而归。

最后看了题解才知道这个数据加强了，set会被卡，但是unordered_map并不会。

服了。

## 例题：

## P3879 [TJOI2010] 阅读理解

## 题目描述

英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。

## 输入格式

第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。

按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。

然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。

## 输出格式

对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。

## 输入输出样例 #1

### 输入 #1

```
3
9 you are a good boy ha ha o yeah
13 o my god you like bleach naruto one piece and so do i
11 but i do not think you will get all the points
5
you
i
o
all
naruto
```

### 输出 #1

```
1 2 3
2 3
1 2
3
2
```

## 说明/提示

对于 $30\%$ 的数据， $1\le M\le 10^3$ 。

对于 $100\%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。

每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,l,m;
string word;
unordered_map<string,set<int>> a;
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>l;
        for (int j=1;j<=l;j++){
            cin>>word;
            a[word].insert(i);
        }
    }
    cin>>m;
    for (int i=1;i<=m;i++){
        cin>>word;
        if (a[word].empty()){
            cout<<endl;
            continue;
        }else{
            for (auto it:a[word]){
                cout<<it<<" ";
            }
        }
        cout<<endl;
    }
    return 0;
}
```

### 思路：

我做了一个大胆的决定，就是在unordered_map里面内置了一个set

我以为会爆，实际上没有，皆大欢喜。

## 例题：

## P2814 家谱（建议反复观摩，评价是神题）

## 题目背景

现代的人对于本家族血统越来越感兴趣。

## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。

## 输入格式

输入由多行组成，首先是一系列有关父子关系的描述，其中每一组父子关系中父亲只有一行，儿子可能有若干行，用 `#name` 的形式描写一组父子关系中的父亲的名字，用 `+name` 的形式描写一组父子关系中的儿子的名字；接下来用 `?name` 的形式表示要求该人的最早的祖先；最后用单独的一个 `$` 表示文件结束。

## 输出格式

按照输入文件的要求顺序，求出每一个要找祖先的人的祖先，格式为：本人的名字 $+$ 一个空格 $+$ 祖先的名字 $+$ 回车。

## 输入输出样例 #1

### 输入 #1

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$
```

### 输出 #1

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur
```

## 说明/提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。

### 题解：

```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
map<string,string>p;
string find(string x)
{
    if(x!=p[x]) 
        p[x]=find(p[x]);
    return  p[x];
}
string s,s1;
int main()
{
    char ch;
    cin>>ch;
    while(ch!='$')
    {
        cin>>s;
        if(ch=='#')
        {
            s1=s;
            if(p[s]=="") p[s]=s;
        }
        else if(ch=='+')
            p[s]=s1;
        else 
            cout<<s<<' '<<find(s)<<endl;    
        cin>>ch;
    }
    return 0;
}
```

### 思路：

孩子们，**不要用序号**，这是我写了一个小时没写出来的教训，这种非序号题首先考虑map

题目给你什么你就用什么，给你数字你就用数字，给你字符串你就用字符串

**不要用序号！！！**
