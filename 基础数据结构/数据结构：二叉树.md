# 数据结构：二叉树

## 概念与建立：

二叉树是一种特别的树，每次分叉不超过两部分。可以延伸出二叉堆，线段树以及平衡树等其他数据结构，多叉树可以转化为二叉树。

## P4913 【深基16.例3】二叉树深度

## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好这棵二叉树之后，请求出它的深度。二叉树的**深度**是指从根节点到叶子结点时，最多经过了几层。

## 输入格式

第一行一个整数 $n$，表示结点数。

之后 $n$ 行，第 $i$ 行两个整数 $l$、$r$，分别表示结点 $i$ 的左右子结点编号。若 $l=0$ 则表示无左子结点，$r=0$ 同理。

## 输出格式

一个整数，表示最大结点深度。

## 输入输出样例 #1

### 输入 #1

```
7
2 7
3 6
4 5
0 0
0 0
0 0
0 0
```

### 输出 #1

```
4
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+7;

class node{
    public:
    int left,right;
};
node t[maxn];
int n;
void build(){
    for (int i=1;i<=n;i++){
        cin>>t[i].left>>t[i].right;
    }
}
int dfs(int x){
    if (!x) return 0;
    return max(dfs(t[x].left),dfs(t[x].right))+1;
}
int main(){
    cin>>n;
    build();
    cout<<dfs(1);
    return 0;
}
```

### 总结：

DFS可以用于二叉树节点的遍历，这是我这题的唯一感觉。

x一般表示的是这个二叉树的深度。

## 二叉树的遍历模板：

```cpp
void dfs(int x){//前序遍历，先访问根结点，然后再依次遍历左右
    cout<<x<<endl;
    if (t[x].left){
        dfs(t[x].left);
    }
    if (t[x].right){
        dfs(t[x].right);
    }
}

void dfs(int x){//中序遍历，先遍历左边，再访问根节点，最后遍历右边
    if (t[x].left){
        dfs(t[x].left);
    }
    cout<<x<<endl;
    if (t[x].right){
        dfs(t[x].right);
    }
}

void dfs(int x){//后序遍历，先遍历左右，最后访问根节点
    if (t[x].left){
        dfs(t[x].left);
    }
    if (t[x].right){
        dfs(t[x].right);
    }
    cout<<x<<endl;
}
```

二叉树的遍历从本质上讲就是DFS。

## 例题：

## P1827 [USACO3.4] 美国血统 American Heritage

## 题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。

这是在样例输入和样例输出中的树的图形表达方式：


```plain
　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

```

附注：

- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。

## 输入格式

第一行一个字符串，表示该树的中序遍历。

第二行一个字符串，表示该树的前序遍历。

## 输出格式

单独的一行表示该树的后序遍历。

## 输入输出样例 #1

### 输入 #1

```
ABEDFCHG
CBADEFGH
```

### 输出 #1

```
AEFDBHGC
```

## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a, b;
void dfs(string x, string y){
	if(!(int)y.size()) return;//递归边界 
	int pos = x.find(y[0]);//在中序遍历中找到根节点 
	dfs(x.substr(0, pos), y.substr(1, pos));//递归1 
	dfs(x.substr(pos + 1), y.substr(pos + 1));//递归2 
	printf("%c", y[0]);//再输出根节点 
	return;//陋习qwq 
}
int main(){
	cin >> a >> b;
	dfs(a, b);
	system("pause");//日常防伪代码 
	return 0;
}
```

```cpp
//一定要看清题目中为先中序，再是前序
#include <bits/stdc++.h>  //万能头文件
using namespace std;
string a,b;   //把中前遍历当做字符串输入
void houxu(int x,int y,int p,int q) {  //x~y为前序遍历 p~q为中序遍历
    if(x>y||p>q) return ;//规定边界条件
    else {
        int i=b.find(a[x]);   //利用根左右的特性来在中序队列中查找
    houxu(x+1,x+i-p,p,i-1);      //递归左子树
    houxu(x+i-p+1,y,i+1,q);    //递归右子树
    cout<<a[x];
}
}
int main() {
    cin>>b>>a;//反一下输入
    int l=a.length()-1;//因为是0开始，所以要减一
    houxu(0,l,0,l);//递归
    return 0;
}
```

给出后序时的模板

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s1[10];
char s2[10];
int len;
inline int find(char ch)
{
    for(int i=0;i<len;i++)
    {
        if(s1[i]==ch) return i;
    }
}
void dfs(int l1,int r1,int l2,int r2)//s1为中，s2为后
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) /*具有左子树*/dfs(l1,m-1,l2,r2-r1+m-1);//r1-m为右子树结点数 
    if(m<r1) /*具有右子树*/dfs(m+1,r1,l2+m-l1,r2-1);//m-l1为左子树节点数
}
int main()
{
    cin>>s1;
    cin>>s2;
    len=strlen(s1);
    dfs(0,len-1,0,len-1);
}


```



### 思路：

前序遍历的第一个字符就是根节点，然后我们在中序遍历里面找出根节点，左边的就是左树，右边的就是右树。然后截取出来，按照后序遍历来递归就行了。

记得要把前序的第一个节点剔除掉。

背个模板吧家人们。

## 二叉搜索树

## 题目描述

您需要写一种数据结构，来维护一些数（都是绝对值 $10^9$ 以内的数）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 $q$ 不超过 $10^4$：

1. 定义数 $x$ 的排名为集合中小于 $x$ 的数的个数 $+1$。查询数 $x$ 的排名。**注意 $x$ 不一定在集合里**。
2. 查询排名为 $x(x\ge 1)$ 的数。**保证集合里至少有 $x$ 个数**。
3. 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。若不存在则输出 $-2147483647$。
4. 求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。若不存在则输出 $2147483647$。
5. 插入一个数 $x$，本题的数据保证插入前 $x$ 不在集合中。

保证执行 $1,3,4$ 操作时，集合中有至少一个元素。

## 输入格式

第一行是一个整数 $q$，表示操作次数。

接下来 $q$ 行，每行两个整数 $op,x$，分别表示操作序号以及操作的参数 $x$。

## 输出格式

输出有若干行。对于操作 $1,2,3,4$，输出一个整数，表示该操作的结果。

## 输入输出样例 #1

### 输入 #1

```
7
5 1
5 3
5 5
1 3
2 2
3 3
4 3
```

### 输出 #1

```
2
3
1
5
```

```cpp
#include<iostream>
#include<cstdio>
#define re register
using namespace std;
const int INF=0x7fffffff;
int cont;
struct node{
    int val,siz,cnt,ls,rs;//其中 val 是权值，ls / rs 是左/右 孩子的下标，cnt 是当前的权值出现了几次，siz 是子树大                           //小和自己的大小的和。
}tree[1000010];
int n,opt,xx;
inline void add(int x,int v)
{
    tree[x].siz++;
    if(tree[x].val==v){
        tree[x].cnt++;
        return ;
    }
    if(tree[x].val>v){
        if(tree[x].ls!=0)
          add(tree[x].ls,v);
        else{
            cont++;
            tree[cont].val=v;
            tree[cont].siz=tree[cont].cnt=1;
            tree[x].ls=cont;
        }
    }
    else{
        if(tree[x].rs!=0)
          add(tree[x].rs,v);
        else{
            cont++;
            tree[cont].val=v;
            tree[cont].siz=tree[cont].cnt=1;
            tree[x].rs=cont;
        }
    }
}
int queryfr(int x, int val, int ans) {
    if (tree[x].val>=val)
    {
        if (tree[x].ls==0)
            return ans;
        else
            return queryfr(tree[x].ls,val,ans);
    }
    else
    {
        if (tree[x].rs==0)
            return tree[x].val;
        return queryfr(tree[x].rs,val,tree[x].val);
    }
}
int queryne(int x, int val, int ans) {
    if (tree[x].val<=val)
    {
        if (tree[x].rs==0)
            return ans;
        else
            return queryne(tree[x].rs,val,ans);
    }
    else
    {
        if (tree[x].ls==0)
            return tree[x].val;
        return queryne(tree[x].ls,val,tree[x].val);
    }
}
int queryrk(int x,int rk)
{
    if(x==0) return INF;
    if(tree[tree[x].ls].siz>=rk)
        return queryrk(tree[x].ls,rk);
    if(tree[tree[x].ls].siz+tree[x].cnt>=rk)
        return tree[x].val;
    return queryrk(tree[x].rs,rk-tree[tree[x].ls].siz-tree[x].cnt);
}
int queryval(int x,int val)
{
    if(x==0) return 0;
    if(val==tree[x].val) return tree[tree[x].ls].siz;
    if(val<tree[x].val) return queryval(tree[x].ls,val);
    return queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt;
}
inline int read()
{
    re int r=0;
    re char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9'){
        r=(r<<3)+(r<<1)+(ch^48);
        ch=getchar();
    }
    return r;
}
signed main()
{
    n=read();
    while(n--){
        opt=read();xx=read();
        if(opt==1) printf("%d\n",queryval(1,xx)+1);
        else if(opt==2) printf("%d\n",queryrk(1,xx));
        else if(opt==3) printf("%d\n",queryfr(1,xx,-INF));
        else if(opt==4) printf("%d\n",queryne(1,xx,INF));
        else{
            if(cont==0){
                cont++;
                tree[cont].cnt=tree[cont].siz=1;
                tree[cont].val=xx;
            }
            else add(1,xx);
        }
    }
    return 0;
}

```

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：二叉树.assets\306a1dd4cd8c4a02da4ebdfa6c6769c8.png)

对于这一题而言，我觉得multiset是真的王朝了，内置红黑树天生高贵

## 例题：二叉树与DFS的一封情书

## P1364 医院设置

## 题目描述

设有一棵二叉树，如图：

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：二叉树.assets\kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 输入格式

第一行一个整数 $n$，表示树的结点数。

接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。

## 输出格式

一个整数，表示最小距离和。

## 输入输出样例 #1

### 输入 #1

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出 #1

```
81
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 110
class node{
	public:
	int father,left,right,val;
};

node t[maxn];
int ans=INT_MAX,n;
int vis[maxn];

int dfs(int x,int d){//x是第几个节点，d是深度
	if (!x||vis[x]==1) return 0;
	vis[x]=1;
	return dfs(t[x].left,d+1)+dfs(t[x].right,d+1)+dfs(t[x].father,d+1)+t[x].val*d;
}

int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>t[i].val>>t[i].left>>t[i].right;
	}
	for (int i=1;i<=n;i++){
		t[t[i].left].father=i;
		t[t[i].right].father=i;
	}
	for (int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		ans=min(ans,dfs(i,0));
	}
	cout<<ans<<endl;
	return 0;
}
```

### 思路：

首先，我们需要建立一棵二叉树。

接着使用DFS进行遍历，指定每一个节点为原点，然后开始计算代价，最后再加上父节点和两个子节点的代价就可以了。

## 例题：

## P1229 遍历问题

## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：二叉树.assets\w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。

## 输入格式

共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。


保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。

## 输出格式

输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。

## 输入输出样例 #1

### 输入 #1

```
abc                           
cba
```

### 输出 #1

```
4
```

### 题解：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int ans;
char str1[233],str2[233];
int main()
{
        scanf("%s",str1);
        scanf("%s",str2);
        for(int i=0;i<strlen(str1);i++)
         for(int j=1;j<strlen(str2);j++)
          if(str1[i]==str2[j]&&str1[i+1]==str2[j-1])
           ans++;
        printf("%d",1<<ans);
        return 0;
}

```

### 思路：

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：二叉树.assets\493933d443a63348d80033a93050664d.png)

这尼玛我一辈子都想不出来

## 例题：二叉树遍历

# P1305 新二叉树

## 题目描述

输入一串二叉树，输出其前序遍历。

## 输入格式

第一行为二叉树的节点数 $n$。($1 \leq n \leq 26$)

后面 $n$ 行，每一个字母为节点，后两个字母分别为其左右儿子。特别地，数据保证第一行读入的节点必为根节点。

空节点用 `*` 表示

## 输出格式

二叉树的前序遍历。

## 输入输出样例 #1

### 输入 #1

```
6
abc
bdi
cj*
d**
i**
j**
```

### 输出 #1

```
abdicj
```

### 题解

```cpp
#include <bits/stdc++.h>
using namespace std;

class node{
    public:
    char left,right;
};
node t[110];
void dfs(char x){
    if (x=='*') return;
    cout<<x;
    dfs(t[x].left);
    dfs(t[x].right);
}
int main(){
    int n;
    cin>>n;
    char h1,h;
    char l1,r1;
    cin>>h1;
    cin>>t[h1].left>>t[h1].right;
    for (int i=2;i<=n;i++){
        cin>>h;
        cin>>t[h].left>>t[h].right;
    }
    dfs(h1);
    return 0;
}
```

## 例题

## P1087 [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。

## 输入格式

第一行是一个整数 $N(0 \le N \le 10)$，  

第二行是一个长度为 $2^N$ 的 01 串。

## 输出格式

一个字符串，即 FBI 树的后序遍历序列。

## 输入输出样例 #1

### 输入 #1

```
3
10001011
```

### 输出 #1

```
IBFBBBFIBFIIIFF
```

## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题

### 题解：

```cpp
#include <iostream>
#include <string>
using namespace std;//输入字符串。
string a;//递归函数哈，用于构建并输出后序遍历，稍乱，谅解。
char b(int c, int d) {
    //当前子串的起始位置。
    //当前子串的结束位置。
    if (c == d) {//如果子串长度为一，直接返回对应的类型。
        if (a[c] == '0') {
            cout << 'B';
            return 'B';
        } else {
            cout << 'I';
            return 'I';
        }
    }
    int e = (c + d) / 2;//中间位置。
    char f = b(c, e);//左子树的类型。
    char g = b(e + 1, d);//右子树的类型。
    char h;//当前子串的类型。
    if (f == 'B' && g == 'B') {
        h = 'B';
    } else if (f == 'I' && g == 'I') {
        h = 'I';
    } else {
        h = 'F';
    }
    cout << h;
    return h;
}
int main() {
    int N;
    cin >> N;
    cin >> a;
    int j = a.length();//字符串的长度。
    b(0, j - 1);//调用递归函数构建并输出后序遍历。
    return 0;//终于完事了。
}
```

