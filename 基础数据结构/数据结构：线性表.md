# 数据结构：线性表

## 栈：

栈是一种满足后进先出已经先进后出的线性表数据结构，在STL中一般使用stack，以下是一些有关于栈的基本操作

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数据结构\数据结构：线性表.assets\b4dc61b28af5b39b046a609a60b68276.png)

### 例题：

## P1449 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 $\texttt{+-*/}$。保证对于 $\texttt{/}$ 运算除数不为 0。特别地，其中 $\texttt{/}$ 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。

## 输入格式

输入一行一个字符串 $s$，表示后缀表达式。

## 输出格式

输出一个整数，表示表达式的值。

## 输入输出样例 #1

### 输入 #1

```
3.5.2.-*7.+@
```

### 输出 #1

```
16
```

## 输入输出样例 #2

### 输入 #2

```
10.28.30./*7.-@
```

### 输出 #2

```
-7
```

## 说明/提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

stack<int> a;
int main(){
    char ch;
    int n,m,s=0;
    do{
        cin>>ch;
        if (ch>='0'&&ch<='9'){
            s=s*10+ch-'0';
        }
        else if(ch=='.'){
            a.push(s);
            s=0;
        }
        else if(ch!='@'){
            n=a.top();
            a.pop();
            m=a.top();
            a.pop();
            switch (ch){
                case '+':a.push(n+m);break;
                case '-':a.push(m-n);break;
                case '*':a.push(n*m);break;
                case '/':a.push(m/n);break;
            }
        }
    }while (ch!='@');
    cout<<a.top()<<endl;
    return 0;
}
```

### 简评：

这一题充分体现了栈的性质，后进先出以及先进后出，反复观摩。

## 队列：

队列是一种遵从规律先进先出的数据结构，其只能在尾部插入元素，以下是一些有关于队列的操作：/

![img](file:///C:\Users\asus\Documents\Tencent Files\3321095604\nt_qq\nt_data\Pic\2025-08\Ori\0af706c2197633dc97d43532ae46287b.png)

### 例题：

# P1996 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**

## 输入格式

输入两个整数 $n,m$。

## 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。

## 输入输出样例 #1

### 输入 #1

```
10 3
```

### 输出 #1

```
3 6 9 2 7 1 8 5 10 4
```

## 说明/提示

$1 \le m, n \le 100$

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

queue<int> q;
int n,m;

int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        q.push(i);
    }
    int x,a=m;
    while (!q.empty()){
        while (a>1){
            x=q.front();
            q.pop();
            q.push(x);
            a--;
        }
        cout<<q.front()<<" ";
        q.pop();
        a=m;
    }
    return 0;
}
```

### 思路：

这一题乍看很抽象，但实际上只要用队列模拟一下就行了，没报到那个数字就出队然后再加入到队尾去。

如果这个数据有先进先出的性质，那么可以使用队列，一般用于BFS上

还有一种双端队列deque，用于单调双端队列的问题。

## 例题：队列相关

## P1540 [NOIP 2010 提高组] 机器翻译

## 题目背景

NOIP2010 提高组 T1

## 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

## 输入格式

共 $2$ 行。每行中两个数之间用一个空格隔开。

第一行为两个正整数 $M,N$，代表内存容量和文章的长度。

第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。

## 输出格式

一个整数，为软件需要查词典的次数。

## 输入输出样例 #1

### 输入 #1

```
3 7
1 2 1 5 4 4 1
```

### 输出 #1

```
5
```

## 说明/提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int in[1005];
int n,m;
queue<int> q;
int main(){
    cin>>m>>n;
    int sum=0;
    memset(in,0,sizeof(in));
    while (n--){
        int a;
        cin>>a;
        if (in[a]==0){
            sum++;
            q.push(a);
            in[a]=1;
            while (q.size()>m){
                in[q.front()]=0;
                q.pop();
            }
        }
    }
    cout<<sum<<endl;
    return 0;
}
```

### 思路：

怎么说呢，这题我做的很唐。

我看出来这东西用队列了但是第一遍就是死活写不出来

总的来说，就是读入每一个元素的时候都要进行一次判定，然后如果这个元素已经在队列中存在了那么就不加入这个元素，如果队列的大小已经超出了规定的内存大小，那么就弹出首个元素，把这个元素是否存在的数组重置为0。

## 例题：队列相关2：

## P2058 [NOIP 2016 普及组] 海港

## 题目背景

NOIP2016 普及组 T3

## 题目描述

小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。

小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。

小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $=86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。

形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400<t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。

## 输入格式

第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。

接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。

保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。

保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。


其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。

## 输出格式

输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。

## 输入输出样例 #1

### 输入 #1

```
3
1 4 4 1 2 2
2 2 2 3
10 1 3
```

### 输出 #1

```
3
4
4
```

## 输入输出样例 #2

### 输入 #2

```
4
1 4 1 2 2 3
3 2 2 3
86401 2 3 4
86402 1 5
```

### 输出 #2

```
3
3
3
4
```

## 说明/提示

【样例解释 1】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；

第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 = 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；

第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1=7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。

【样例解释 2】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。

第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2=6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。

第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2=4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。

第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1=5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。

【数据范围】

- 对于 $10\%$ 的测试点，$n=1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。
- 对于 $20\%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。
- 对于 $40\%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。
- 对于 $70\%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。
- 对于 $100\%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。

### 思路：

```cpp
#include <bits/stdc++.h>
using namespace std;
class node{
    public:
    int t,x;
};
int in[100005];
queue<node> q;
int n,t,k,x;

int main(){
    cin>>n;
    int ans=0;
    while (n--){
        cin>>t>>k;
        while (k--){
            cin>>x;
            q.push((node){t,x});
            in[x]++;
            if (in[x]==1) ans++;
        }
        if (t>86400){
            while (1){
                if (q.front().t<=t-86400){
                    node lin=q.front();
                    in[lin.x]--;
                    if (in[lin.x]==0) ans--;
                    q.pop();
                }else{
                    break;
                }
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

### 思路：

思路其实不难啊，用队列去打时间轴然后存储每个人国籍，这个其实可以理解为是时间轴上面的一个窗口，队列在处理窗口这一类上具有一定的优势。

## 例题：栈相关：

## P1241 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 输入格式

输入只有一行一个字符串，表示 $s$。

## 输出格式

输出一行一个字符串表示你的答案。

## 输入输出样例 #1

### 输入 #1

```
([()
```

### 输出 #1

```
()[]()
```

## 输入输出样例 #2

### 输入 #2

```
([)
```

### 输出 #2

```
()[]()
```

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
stack<int> k;
int mark[105];
int main(){
    getline(cin,s);
    int n=s.length();
    char a;
    memset(mark,0,sizeof(mark));
    for (int i=0;i<n;i++){
        if (s[i]==')'){
            if (!k.empty()){
                a=s[k.top()];
                if (a=='('){
                    mark[i]=1;
                    mark[k.top()]=1;
                    k.pop();
                }
            }
        }else if(s[i]==']'){
            if (!k.empty()){
                a=s[k.top()];
                if (a=='['){
                    mark[i]=1;
                    mark[k.top()]=1;
                    k.pop();
                }
            }
        }else{
            k.push(i);
        }
    }
    string ans;
    for (int i=0;i<n;i++){
        if (mark[i]==0){
            if (s[i]=='('){
                ans+=s[i];
                ans+=')';
            }else if(s[i]==')'){
                ans+='(';
                ans+=s[i];
            }else if(s[i]=='['){
                ans+=s[i];
                ans+=']';
            }else if(s[i]==']'){
                ans+='[';
                ans+=s[i];
            }
        }else{
            ans+=s[i];
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

神笔题目我都不知道卡了我多久

字符串匹配一眼栈结构，想都不用想了，思路就是从头往尾遍历，如果找到了）或者]就开始看一看栈顶的元素，如果能匹配，那就标记为1，并且弹出，匹配不了，那就过去了。

别用栈存储右括号，试过了，很难做，而且会错。

遇到其他的就放到栈里就行了。

## 例题：栈相关2：

## P4387 【深基15.习9】验证栈序列

## 题目描述

给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 $n(n\le100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。

为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。

## 输入格式

第一行一个整数 $q$，询问次数。

接下来 $q$ 个询问，对于每个询问：

第一行一个整数 $n$ 表示序列长度；

第二行 $n$ 个整数表示入栈序列；

第三行 $n$ 个整数表示出栈序列；

## 输出格式

对于每个询问输出答案。

## 输入输出样例 #1

### 输入 #1

```
2
5
1 2 3 4 5
5 4 3 2 1
4
1 2 3 4
2 4 1 3
```

### 输出 #1

```
Yes
No
```

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int q,n;
int pushn[100005],popn[100005];
stack<int> a;

int main(){
    cin>>q;
    while (q--){
        cin>>n;
        int ptr=1;
        for (int i=1;i<=n;i++){
            cin>>pushn[i];
        }
        for (int i=1;i<=n;i++){
            cin>>popn[i];
        }
        for (int i=1;i<=n;i++){
            a.push(pushn[i]);
            while (a.top()==popn[ptr]){
            a.pop();
            ptr++;
            if (a.empty()) break;
            }
        }
        if (!a.empty()) cout<<"No"<<endl;
        else cout<<"Yes"<<endl;
        while (!a.empty()) a.pop();
    }  
    return 0;
}
```

### 思路：

用栈去模拟就行了，简单到让我怀疑这是不是十分有九分的不对劲。

## 例题：

## P2234 [HNOI2002] 营业额统计

## 题目描述

Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。

Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。

而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。

我们定义，一天的最小波动值 = $\min\{|\text{该天以前某一天的营业额}-\text{该天营业额}|\}$。

特别地，第一天的最小波动值为第一天的营业额。

## 输入格式

第一行为正整数 $n$（$n \leq 32767$） ，表示该公司从成立一直到现在的天数，接下来的 $n$ 行每行有一个整数 $a_i$（$|a_i| \leq 10^6$) ，表示第 $i$ 天公司的营业额，可能存在负数。

## 输出格式

输出一个整数，即每一天最小波动值的和，保证结果小于 $2^{31}$。

## 输入输出样例 #1

### 输入 #1

```
6
5
1
2
5
4
6
```

### 输出 #1

```
12
```

## 说明/提示

结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
set<int> a;
set<int>::iterator ptr1,ptr2;//t
signed main(){
    cin>>n;
    int ans=0;
    a.insert(INT_MAX);//写了这个一定要开long long
    a.insert(INT_MIN);
    for (int i=1;i<=n;i++){
        int x;
        cin>>x;
        if (a.size()==2){
            ans+=x;
            a.insert(x);
        }else{
            ptr1=a.lower_bound(x);
            if (*ptr1!=x){
                ptr2=ptr1;//这里只能这么赋值
                ptr2--;
                ans+=min(abs(x-*ptr1),abs(x-*ptr2));
                a.insert(x);
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 思路：

众所周知，set能有序地维护同一类型的元素，但相同的元素只能出现一次。

对于这道题来说，我们可以用set来记录下之前出现过的所有营业额。

每次输入一个新的数x后，通过lowerbound操作找到set中大于等于x的第一个数。

0.如果这是第一个数，直接插入到set里。

1.这个数等于x,显然最小波动值为0，我们也不需要再插入一个x放到set里了。

2.这个数大于x,通过set的特性可以很轻松的找到这个数的前驱，也就是小于x的第一个数。将两个数分别减去x,对绝对值取个min就好了。此时要将x插入到set中。

还有我要引用圣经了

> 十年oi一场空，不开long long见祖宗

从本质上看这题应该是一个平衡树问题，set内部自带平衡树（）