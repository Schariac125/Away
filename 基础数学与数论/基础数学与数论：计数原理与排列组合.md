# 基础数学与数论：计数原理与排列组合

## 例题：

## P1866 编号

## 题目描述

太郎有 $N$ 只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子 $i$ 想要一个整数，介于 $1$ 和 $M_i$ 之间（可以为 $1$ 或 $M_i$）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。

你只用输出答案对 $10^9+7$ 取余的结果即可。如果这是不可能的，就输出 $0$。

## 输入格式

第一行是一个整数 $N$。

第二行 $N$ 个整数 $M_i$。

## 输出格式

一个整数，表示方案总数。

## 输入输出样例 #1

### 输入 #1

```
2
5 8
```

### 输出 #1

```
35
```

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 50$，$1\le M_i\le 1000$。

### 题解：

```cpp
一道简单的题，排完序就做完了
从小到大排序后，乘起来
注意第二个要减一，第二个要减二，以此类推
我的代码：
#include<iostream>
#include<algorithm>//sort的头文件，不加会编译错误
using namespace std;
int main()
{
int n,a[51],i;
long long s=1;//数据范围有点大
cin>>n;
for(i=1;i<=n;i++)
	cin>>a[i];
sort(a+1,a+n+1);//sort快排序，不然可能会超时
for(i=1;i<=n;i++)
{
	s*=(a[i]-i+1);//每个可选的都会减一
	s%=1000000007;
}
cout<<s;
return 0;
}
```

### 思路：

做这种纯数学题给我一种纯良感，可能是写图论写崩溃了。

总的来说，就是选择范围最小的那个人先选，然后依次乘就行了，高中题。

## 题外话：

讲组合数这种问题一定躲不开一点，那就是阶乘算法

给一个递归和记忆化搜索实现的阶乘模板。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100;      // 阶乘最大计算到 100 (可以自己设)
long long memo[MAXN + 1]; // 记忆数组，初始化为 -1

// 带记忆化的递归阶乘
long long factorial(int n) {
    if (n == 0 || n == 1) return 1;     // 基础情况
    
    if (memo[n] != -1) return memo[n];  // 如果已经计算过，直接返回
    
    // 否则递归计算并存入缓存
    memo[n] = n * factorial(n - 1);
    return memo[n];
}

int main() {
    memset(memo, -1, sizeof(memo)); // 初始化记忆数组
    
    int n;
    cout << "请输入n: ";
    cin >> n;
    
    cout << n << "! = " << factorial(n) << endl;
    return 0;
}
```

## 例题：

## P2822 [NOIP 2016 提高组] 组合数问题

## 题目背景

NOIP2016 提高组 D2T1

## 题目描述

组合数 $\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\binom{n}{m}$ 的一般公式：

$$\binom{n}{m}=\frac{n!}{m!(n-m)!}$$

其中 $n!=1\times2\times\cdots\times n$；特别地，定义 $0!=1$。

小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 有多少对 $(i,j)$ 满足 $k\mid\binom{i}{j}$。

## 输入格式

第一行有两个整数 $t,k$，其中 $t$ 代表该测试点总共有多少组测试数据，$k$ 的意义见问题描述。

接下来 $t$ 行每行两个整数 $n,m$，其中 $n,m$ 的意义见问题描述。

## 输出格式

共 $t$ 行，每行一个整数代表所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 中有多少对 $(i,j)$ 满足 $k\mid\binom{i}{j}$。

## 输入输出样例 #1

### 输入 #1

```
1 2
3 3
```

### 输出 #1

```
1
```

## 输入输出样例 #2

### 输入 #2

```
2 5
4 5
6 7
```

### 输出 #2

```
0
7
```

## 说明/提示

【样例1说明】

在所有可能的情况中，只有 $\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。

【子任务】

![](C:\Users\asus\Desktop\程序设计\算法笔记\基础数学与数论\基础数学与数论：计数原理与排列组合.assets\3457.png)

- 对于全部的测试点，保证 $0 \leq n, m \leq 2 \times 10^3$，$1 \leq t \leq 10^4$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int f[2010][2010];
int b[2010][2010];

signed main(){
	int t,k,n,m;
	cin>>t>>k;
	for (int i=0;i<=2000;i++){
		f[i][0]=1;
		f[i][i]=1;
		for (int j=1;j<i;j++){
			f[i][j]=(f[i-1][j]+f[i-1][j-1])%k;
		}
	}
	for (int i=0;i<=2000;i++){
		for (int j=0;j<=2000;j++){
			if (j<=i) b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+(f[i][j]==0);
			else b[i][j]=b[i][i];//处理非法区间，全部设置为最后一个前缀和
		}
	}
	while (t--){
		cin>>n>>m;
		cout<<b[n][min(n,m)]<<endl;
	}
	return 0;
}
```

### 思路：

思路很简单，建立杨辉三角，然后判断每个数是否都能被整除，能就是0，不能就是1

再二维前缀和处理答案即可。

解释一下二维前缀和的else部分为什么这么做（谢谢你,GPT桑）

> 好👌 我帮你画一个小规模的例子，方便直观理解。
>
> 假设我们只算到 `i=3`（即杨辉三角前四行）。
>
> ------
>
> ### 1. 杨辉三角 (组合数 `C(i,j)`)
>
> ```
> i\j   0   1   2   3
> 0     1
> 1     1   1
> 2     1   2   1
> 3     1   3   3   1
> ```
>
> 如果取 `k=2`，那我们关心 `(C(i,j) % 2 == 0)` 的格子：
>
> ```
> i\j   0   1   2   3
> 0     1   .   .   .
> 1     1   1   .   .
> 2     1   0   1   .
> 3     1   1   0   1
> ```
>
> 其中 `0` 表示该位置模 2 结果为 0。
>
> ------
>
> ### 2. 构造二维前缀和 b[i][j]
>
> 我们要统计从 `(0,0)` 到 `(i,j)` 这个矩形内，多少个 `C(i,j) % k == 0`。
>
> 按照代码公式：
>
> - 如果 `j <= i`：用正常前缀和公式。
> - 如果 `j > i`：直接 `b[i][j] = b[i][i]`。
>
> ------
>
> ### 3. b 数组的值
>
> 计算后得到（数字表示有多少个为 0 的点）：
>
> ```
> i\j   0   1   2   3
> 0     0   0   0   0
> 1     0   0   0   0
> 2     0   1   1   1
> 3     0   1   2   2
> ```
>
> 注意：
>
> - 比如 `(2,2)` 范围内一共有 1 个 0（就是 `C(2,1)=2`）。
> - `(3,2)` 范围内有 2 个 0（`C(2,1)` 和 `C(3,2)`）。
> - `(3,3)` 也有 2 个 0。
> - **当 j > i（右边空白区域）**：例如 `(2,3)`，它被强制设成和 `(2,2)` 一样，等于 1；`(3,4)` 会被设成和 `(3,3)` 一样等于 2。
>
> ------
>
> ### 4. 为什么要这样“拉平”？
>
> 如果不处理 `j > i` 的情况，访问 `b[n][m]` 时（当 `m > n`），会越界或得到错误的值。
>  拉平后，`b[i][j]` 在横向上保持稳定：
>
> ```
> b[i][i] = b[i][i+1] = b[i][i+2] = ...
> ```
>
> 就相当于：**超过三角形右边的地方没有新贡献**。
>
> ------
>
> 要不要我帮你再画一张 **图形化的二维矩阵格子图（带颜色）**，把 `f` 和 `b` 的关系标出来？这样能一眼看出 else 是在“填补空白”。

还有我要吐槽，洛谷你那个神必OJ什么时候修？

## 例题：

## P2789 直线交点数

## 题目描述

假设平面上有 $N$ 条直线，且无三线共点，那么这些直线有多少种可能的交点数？

## 输入格式

一行，一个整数 $N$，代表有 $N$ 条直线。

## 输出格式

一行，一个整数，表示方案总数。

## 输入输出样例 #1

### 输入 #1

```
4
```

### 输出 #1

```
5
```

## 说明/提示

对于所有数据，满足 $1 \le N \le 25$。

### 题解：

```cpp
#include <bits/stdc++.h>
using namespace std;

int f[50010],n,ans=0,maxn=-1;
void find(int n,int k){
	if (n==0){
		f[k]=1;
		maxn=max(k,maxn);
	}else{
		for (int i=n;i>=1;i--){
			find(n-i,i*(n-i)+k);
		}
	}
}

int main(){
	cin>>n;
	memset(f,0,sizeof(f));
	find(n,0);
	for (int i=0;i<=maxn;i++){
		if (f[i]) ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

### 思路：

纯数学题，比较抽象

![img](C:\Users\asus\Desktop\程序设计\算法笔记\基础数学与数论\基础数学与数论：计数原理与排列组合.assets\bfa84dc69f29e06ad7d7c7626e41d481.png)

## 例题：

## P3913 车的攻击

## 题目描述

$N \times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。

车可以攻击所有同一行或者同一列的地方。

## 输入格式

第1 行，2 个整数$N,K$。

接下来K 行，每行2 个整数$R_i,C_i$。

## 输出格式

1 个整数，表示被攻击的格子数量。

## 输入输出样例 #1

### 输入 #1

```
3 2
1 2
2 2
```

### 输出 #1

```
7
```

## 说明/提示

• 对于30% 的数据，$1 \le N \le 10^3; 1 \le K \le 10^3$；

• 对于60% 的数据，$1 \le N \le 10^6; 1 \le K \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^9; 1 \le K \le 10^6; 1 \le R_i , C_i \le N$。

### 题解：

```cpp
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <queue>
#define ll long long
const int maxn=1e6+5;
using namespace std;
ll n,k;
ll x[maxn],y[maxn];
int main(){
 //       freopen("test.in","r",stdin);
        //cin>>n>>k;
        scanf("%lld%lld",&n,&k);
        for(ll i=0;i<k;i++){
                //cin>>x[i]>>y[i];
            scanf("%lld%lld",&x[i],&y[i]);
        }
        sort(x,x+k);
        sort(y,y+k);
        ll sizex=unique(x,x+k)-x;
        ll sizey=unique(y,y+k)-y;
        //cout<<n*n-(n-sizex)*(n-sizey);
        printf("%lld",n*n-(n-sizex)*(n-sizey));
        return 0;
}
```

### 思路：

第一遍看

什么东西，我模拟一个棋盘不就行了，然后打标记遍历一下棋盘不就皆大欢喜了

第二遍看

数据范围1e9是什么意思？

总的来说，这一题模拟棋盘绝对是AC不了的，因为数据范围太大了，如果是1e6还好说，1e9的话你开个棋盘数组就MLE了。

易错点就是上面这些，下面贴AC思路：

> **本题数据已增强，但是做法不变，仅将读入和输出换成stdio的即可**
>
> 题解好少啊，赶紧水一波。
>
> 题目要咱求能被攻击到的格子，但是如果硬处理的话超时是妥妥的，所以咱得想个数学办法，不能只靠模拟来打暴力。
>
> 首先考虑能不能直接将x轴与y轴有车的点先全部记录下来，然后将有车的行的数量和有车的列的数量记录下来，然后*n再相加，但是这样显然不可行，因为这样会导致在行列交汇处的点呗重新算2次。
>
> 既然被重新计算了，那我们把他们都删掉不就可以了吗？
>
> 不难看出，交叉点的个数就是有车的行数*有车的列数，那么就不难导出公式：
> *ans*=*s**i**zex*∗*n*+*s**i**zey*∗*n*−*s**i**zey*∗*s**i**zex*
> 然后就是统计一共有几行几列有车了，这里就要用到我大stl中的一员大将：unique,也就是去重，通俗来讲，这个玩应的用法一般是
>
> unique(数组名,数组名+大小)
> (没错和sort几乎一模一样）
>
> 然后值得注意的有两点：
> 第一点：在*u**ni**q**u**e*之前必须保证去重数组有序，也就是得*sort*一下。
> 第二点：*u**ni**q**u**e*并不会生成一个新的数组，而是将原数组多余的部分“移”到了数组之后，同时*u**ni**q**u**e*本身还会返回一个指针，指向去重之后的最后一位。
>
> 利用c++可以指针相加减的特点，我们可以通过 unique-数组指针 来知道去重之后数组的“大小”（这里听不懂没关系，往下看代码，背住用法就好）

