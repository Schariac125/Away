# 基础数学与数论：位运算与进制转换

## 基础知识（？）：

这其实是一个很老生常谈的东西了，该不会有人到现在还不会进制转换吧？

## 例题：

## P1143 进制转换

## 题目描述

请你编一程序实现两种不同进制之间的数据转换。

## 输入格式

共三行，第一行是一个正整数，表示需要转换的数的进制 $n\ (2\le n\le 16)$，第二行是一个 $n$ 进制数，若 $n>10$ 则用大写字母 $\verb!A!\sim \verb!F!$ 表示数码 $10\sim 15$，并且该 $n$ 进制数对应的十进制的值不超过 $10^9$，第三行也是一个正整数，表示转换之后的数的进制 $m\ (2\le m\le 16)$。

## 输出格式

一个正整数，表示转换之后的 $m$ 进制数。

## 输入输出样例 #1

### 输入 #1

```
16
FF
2
```

### 输出 #1

```
11111111
```

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int c[10000000],d,e,f,g,sum,ans;
int main()
{
    scanf("%d",&d);
    cin>>a;
    scanf("%d",&f);
    for(int x=0;x<a.size();x++){
        if(a[x]<'A'){
            e=pow(d,a.size()-x-1);
            e*=(a[x]-'0');
            sum+=e;
        }
        else{
            e=pow(d,a.size()-1-x);
            e*=(a[x]-'A'+10);
            sum+=e;
        }
    }
        while(sum>0){
        c[g++]=sum%f;
        sum/=f;
    }
    for(int x=g-1;x>=0;x--){
        if(c[x]>=10)printf("%c",c[x]+'A'-10);
        else printf("%d",c[x]);
    }
    return 0;
}
```

### 思路：

本质上是一个模拟，先转成十进制然后再转成任意进制就行了。

其实我记得这题还有打表解法来着。 

## 例题：

## P1469 找筷子

## 题目描述

经过一段时间的紧张筹备，电脑小组的“RP 餐厅”终于开业了，这天，经理 LXC 接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题：筷子！

CX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮 CX 找出这只落单的筷子的长度吗？

## 输入格式

第一行是一个整数，表示筷子的数量 $n$。

第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 根筷子的长度 $a_i$。

## 输出格式

输出一行一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
9
2 2 1 3 3 3 2 3 1
```

### 输出 #1

```
2 
```

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7 + 1$，$1 \leq a_i \leq 10^9$。


#### 提示

- 请注意数据读入对程序效率造成的影响。
- 请注意本题的空间限制为 $4$ Mb。

### 题解：

```cpp
#include<cstdio>
int x,n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&x),ans^=x;
    printf("%d\n",ans);
}
```

### 思路：

卡4mb你知道意味着什么吗。

意味着这个题你连数组都用不了。

你知道这个数据范围意味着什么吗。

意味着你遍历一下这个数据都得超时。

时间和内存实在卡太死了。

附大佬思路：

> 我们考虑异或的两个小小的性质：
>
> 1. *k* 个相同的数的异或和，当 *k* 为奇数时，结果是这个数本身，否则结果是 0。
> 2. 任何数与 0 的异或值是它本身。
>
> 然后注意到题目。题目需要求 *n* 个数中出现奇数次的那个数，且保证这个数存在且只有一个。于是我们根据上面两个性质得出，答案就是这 *n* 个数的异或和。
>
> 原理：
>
> 根据性质1，成对的筷子异或后就变成 0 了，只剩下落单的那一根。把这些 0 和落单的那一根的长度异或起来，根据性质2，结果显然就是落单的那一根的长度。

## 例题：

## P1100 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。

## 输入格式

一个小于 $2^{32}$ 的非负整数。

## 输出格式

将新的数输出。

## 输入输出样例 #1

### 输入 #1

```
1314520
```

### 输出 #1

```
249036820
```

### 题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<(n>>16)+(n<<16);
	return 0;
} 
```

### 思路：

C++有32位**无符号**整形（其他语言应该也有吧）。

左移16位，就是低位转到高位；右移16位，就是高位转到低位；两者相加，就是新数。

